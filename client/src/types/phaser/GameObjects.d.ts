namespace Phaser.GameObjects {
  /**
   * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
   *
   * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to
   * match the font structure.
   *
   * Dynamic Bitmap Text objects are different from Static Bitmap Text in that they invoke a callback for each
   * letter being rendered during the render pass. This callback allows you to manipulate the properties of
   * each letter being rendered, such as its position, scale or tint, allowing you to create interesting effects
   * like jiggling text, which can't be done with Static text. This means that Dynamic Text takes more processing
   * time, so only use them if you require the callback ability they have.
   *
   * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
   * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
   * processing the font texture in an image editor, applying fills and any other effects required.
   *
   * To create multi-line text insert \r, \n or \r\n escape codes into the text string.
   *
   * To create a BitmapText data files you need a 3rd party app such as:
   *
   * BMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}
   * Glyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}
   * Littera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}
   *
   * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
   * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}
   */
  class DynamicBitmapText extends Phaser.GameObjects.BitmapText {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.
     * @param x The x coordinate of this Game Object in world space.
     * @param y The y coordinate of this Game Object in world space.
     * @param font The key of the font to use from the Bitmap Font cache.
     * @param text The string, or array of strings, to be set as the content of this Bitmap Text.
     * @param size The font size of this Bitmap Text.
     * @param align The alignment of the text in a multi-line BitmapText object. Default 0.
     */
    constructor(scene: Phaser.Scene, x: number, y: number, font: string, text?: string | string[], size?: number, align?: number);

    /**
     * The horizontal scroll position of the Bitmap Text.
     */
    scrollX: number;

    /**
     * The vertical scroll position of the Bitmap Text.
     */
    scrollY: number;

    /**
     * The crop width of the Bitmap Text.
     */
    cropWidth: number;

    /**
     * The crop height of the Bitmap Text.
     */
    cropHeight: number;

    /**
     * A callback that alters how each character of the Bitmap Text is rendered.
     */
    displayCallback: Phaser.Types.GameObjects.BitmapText.DisplayCallback;

    /**
     * The data object that is populated during rendering, then passed to the displayCallback.
     * You should modify this object then return it back from the callback. It's updated values
     * will be used to render the specific glyph.
     *
     * Please note that if you need a reference to this object locally in your game code then you
     * should shallow copy it, as it's updated and re-used for every glyph in the text.
     */
    callbackData: Phaser.Types.GameObjects.BitmapText.DisplayCallbackConfig;

    /**
     * Set the crop size of this Bitmap Text.
     * @param width The width of the crop.
     * @param height The height of the crop.
     */
    setSize(width: number, height: number): this;

    /**
     * Set a callback that alters how each character of the Bitmap Text is rendered.
     *
     * The callback receives a {@link Phaser.Types.GameObjects.BitmapText.DisplayCallbackConfig} object that contains information about the character that's
     * about to be rendered.
     *
     * It should return an object with `x`, `y`, `scale` and `rotation` properties that will be used instead of the
     * usual values when rendering.
     * @param callback The display callback to set.
     */
    setDisplayCallback(callback: Phaser.Types.GameObjects.BitmapText.DisplayCallback): this;

    /**
     * Set the horizontal scroll position of this Bitmap Text.
     * @param value The horizontal scroll position to set.
     */
    setScrollX(value: number): this;

    /**
     * Set the vertical scroll position of this Bitmap Text.
     * @param value The vertical scroll position to set.
     */
    setScrollY(value: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager, or a Texture instance.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string | Phaser.Textures.Texture, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     * @param frame The name or index of the frame within the Texture.
     * @param updateSize Should this call adjust the size of the Game Object? Default true.
     * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
     */
    setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;

    /**
     * The tint value being applied to the top-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopLeft: number;

    /**
     * The tint value being applied to the top-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopRight: number;

    /**
     * The tint value being applied to the bottom-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomLeft: number;

    /**
     * The tint value being applied to the bottom-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomRight: number;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * Clears all tint values associated with this Game Object.
     *
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     */
    clearTint(): this;

    /**
     * Sets an additive tint on this Game Object.
     *
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a fill-based tint on this Game Object.
     *
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     */
    tint: number;

    /**
     * Does this Game Object have a tint applied?
     *
     * It checks to see if the 4 tint properties are set to the value 0xffffff
     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
     */
    readonly isTinted: boolean;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  namespace RetroFont {
    /**
     * Text Set 1 =  !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~
     */
    var TEXT_SET1: string;

    /**
     * Text Set 2 =  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ
     */
    var TEXT_SET2: string;

    /**
     * Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
     */
    var TEXT_SET3: string;

    /**
     * Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789
     */
    var TEXT_SET4: string;

    /**
     * Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789
     */
    var TEXT_SET5: string;

    /**
     * Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.'
     */
    var TEXT_SET6: string;

    /**
     * Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39
     */
    var TEXT_SET7: string;

    /**
     * Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ
     */
    var TEXT_SET8: string;

    /**
     * Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!
     */
    var TEXT_SET9: string;

    /**
     * Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ
     */
    var TEXT_SET10: string;

    /**
     * Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789
     */
    var TEXT_SET11: string;

    /**
     * Parses a Retro Font configuration object so you can pass it to the BitmapText constructor
     * and create a BitmapText object using a fixed-width retro font.
     * @param scene A reference to the Phaser Scene.
     * @param config The font configuration object.
     */
    function Parse(scene: Phaser.Scene, config: Phaser.Types.GameObjects.BitmapText.RetroFontConfig): object;

  }

  /**
   * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
   *
   * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to
   * match the font structure.
   *
   * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
   * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
   * processing the font texture in an image editor, applying fills and any other effects required.
   *
   * To create multi-line text insert \r, \n or \r\n escape codes into the text string.
   *
   * To create a BitmapText data files you need a 3rd party app such as:
   *
   * BMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}
   * Glyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}
   * Littera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}
   *
   * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
   * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}
   */
  class BitmapText extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.
     * @param x The x coordinate of this Game Object in world space.
     * @param y The y coordinate of this Game Object in world space.
     * @param font The key of the font to use from the Bitmap Font cache.
     * @param text The string, or array of strings, to be set as the content of this Bitmap Text.
     * @param size The font size of this Bitmap Text.
     * @param align The alignment of the text in a multi-line BitmapText object. Default 0.
     */
    constructor(scene: Phaser.Scene, x: number, y: number, font: string, text?: string | string[], size?: number, align?: number);

    /**
     * The key of the Bitmap Font used by this Bitmap Text.
     * To change the font after creation please use `setFont`.
     */
    readonly font: string;

    /**
     * The data of the Bitmap Font used by this Bitmap Text.
     */
    readonly fontData: Phaser.Types.GameObjects.BitmapText.BitmapFontData;

    /**
     * The character code used to detect for word wrapping.
     * Defaults to 32 (a space character).
     */
    wordWrapCharCode: number;

    /**
     * The horizontal offset of the drop shadow.
     *
     * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.
     */
    dropShadowX: number;

    /**
     * The vertical offset of the drop shadow.
     *
     * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.
     */
    dropShadowY: number;

    /**
     * The color of the drop shadow.
     *
     * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.
     */
    dropShadowColor: number;

    /**
     * The alpha value of the drop shadow.
     *
     * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.
     */
    dropShadowAlpha: number;

    /**
     * Indicates whether the font texture is from an atlas or not.
     */
    readonly fromAtlas: boolean;

    /**
     * Set the lines of text in this BitmapText to be left-aligned.
     * This only has any effect if this BitmapText contains more than one line of text.
     */
    setLeftAlign(): this;

    /**
     * Set the lines of text in this BitmapText to be center-aligned.
     * This only has any effect if this BitmapText contains more than one line of text.
     */
    setCenterAlign(): this;

    /**
     * Set the lines of text in this BitmapText to be right-aligned.
     * This only has any effect if this BitmapText contains more than one line of text.
     */
    setRightAlign(): this;

    /**
     * Set the font size of this Bitmap Text.
     * @param size The font size to set.
     */
    setFontSize(size: number): this;

    /**
     * Sets the letter spacing between each character of this Bitmap Text.
     * Can be a positive value to increase the space, or negative to reduce it.
     * Spacing is applied after the kerning values have been set.
     * @param spacing The amount of horizontal space to add between each character. Default 0.
     */
    setLetterSpacing(spacing?: number): this;

    /**
     * Set the textual content of this BitmapText.
     *
     * An array of strings will be converted into multi-line text. Use the align methods to change multi-line alignment.
     * @param value The string, or array of strings, to be set as the content of this BitmapText.
     */
    setText(value: string | string[]): this;

    /**
     * Sets a drop shadow effect on this Bitmap Text.
     *
     * This is a WebGL only feature and only works with Static Bitmap Text, not Dynamic.
     *
     * You can set the vertical and horizontal offset of the shadow, as well as the color and alpha.
     *
     * Once a shadow has been enabled you can modify the `dropShadowX` and `dropShadowY` properties of this
     * Bitmap Text directly to adjust the position of the shadow in real-time.
     *
     * If you wish to clear the shadow, call this method with no parameters specified.
     * @param x The horizontal offset of the drop shadow. Default 0.
     * @param y The vertical offset of the drop shadow. Default 0.
     * @param color The color of the drop shadow, given as a hex value, i.e. `0x000000` for black. Default 0x000000.
     * @param alpha The alpha of the drop shadow, given as a float between 0 and 1. This is combined with the Bitmap Text alpha as well. Default 0.5.
     */
    setDropShadow(x?: number, y?: number, color?: number, alpha?: number): this;

    /**
     * Sets a tint on a range of characters in this Bitmap Text, starting from the `start` parameter index
     * and running for `length` quantity of characters.
     *
     * The `start` parameter can be negative. In this case, it starts at the end of the text and counts
     * backwards `start` places.
     *
     * You can also pass in -1 as the `length` and it will tint all characters from `start`
     * up until the end of the string.
     * Remember that spaces and punctuation count as characters.
     *
     * This is a WebGL only feature and only works with Static Bitmap Text, not Dynamic.
     *
     * The tint works by taking the pixel color values from the Bitmap Text texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole character will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the character range.
     *
     * To swap this from being an additive tint to a fill based tint, set the `tintFill` parameter to `true`.
     *
     * To modify the tint color once set, call this method again with new color values.
     *
     * Using `setWordTint` can override tints set by this function, and vice versa.
     *
     * To remove a tint call this method with just the `start`, and optionally, the `length` parameters defined.
     * @param start The starting character to begin the tint at. If negative, it counts back from the end of the text. Default 0.
     * @param length The number of characters to tint. Remember that spaces count as a character too. Pass -1 to tint all characters from `start` onwards. Default 1.
     * @param tintFill Use a fill-based tint (true), or an additive tint (false) Default false.
     * @param topLeft The tint being applied to the top-left of the character. If not other values are given this value is applied evenly, tinting the whole character. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the character.
     * @param bottomLeft The tint being applied to the bottom-left of the character.
     * @param bottomRight The tint being applied to the bottom-right of the character.
     */
    setCharacterTint(start?: number, length?: number, tintFill?: boolean, topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a tint on a matching word within this Bitmap Text.
     *
     * The `word` parameter can be either a string or a number.
     *
     * If a string, it will run a string comparison against the text contents, and if matching,
     * it will tint the whole word.
     *
     * If a number, if till that word, based on its offset within the text contents.
     *
     * The `count` parameter controls how many words are replaced. Pass in -1 to replace them all.
     *
     * This parameter is ignored if you pass a number as the `word` to be searched for.
     *
     * This is a WebGL only feature and only works with Static Bitmap Text, not Dynamic.
     *
     * The tint works by taking the pixel color values from the Bitmap Text texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole character will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the character range.
     *
     * To swap this from being an additive tint to a fill based tint, set the `tintFill` parameter to `true`.
     *
     * To modify the tint color once set, call this method again with new color values.
     *
     * Using `setCharacterTint` can override tints set by this function, and vice versa.
     * @param word The word to search for. Either a string, or an index of the word in the words array.
     * @param count The number of matching words to tint. Pass -1 to tint all matching words. Default 1.
     * @param tintFill Use a fill-based tint (true), or an additive tint (false) Default false.
     * @param topLeft The tint being applied to the top-left of the word. If not other values are given this value is applied evenly, tinting the whole word. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the word.
     * @param bottomLeft The tint being applied to the bottom-left of the word.
     * @param bottomRight The tint being applied to the bottom-right of the word.
     */
    setWordTint(word: string | number, count?: number, tintFill?: boolean, topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Calculate the bounds of this Bitmap Text.
     *
     * An object is returned that contains the position, width and height of the Bitmap Text in local and global
     * contexts.
     *
     * Local size is based on just the font size and a [0, 0] position.
     *
     * Global size takes into account the Game Object's scale, world position and display origin.
     *
     * Also in the object is data regarding the length of each line, should this be a multi-line BitmapText.
     * @param round Whether to round the results up to the nearest integer. Default false.
     */
    getTextBounds(round?: boolean): Phaser.Types.GameObjects.BitmapText.BitmapTextSize;

    /**
     * Gets the character located at the given x/y coordinate within this Bitmap Text.
     *
     * The coordinates you pass in are translated into the local space of the
     * Bitmap Text, however, it is up to you to first translate the input coordinates to world space.
     *
     * If you wish to use this in combination with an input event, be sure
     * to pass in `Pointer.worldX` and `worldY` so they are in world space.
     *
     * In some cases, based on kerning, characters can overlap. When this happens,
     * the first character in the word is returned.
     *
     * Note that this does not work for DynamicBitmapText if you have changed the
     * character positions during render. It will only scan characters in their un-translated state.
     * @param x The x position to check.
     * @param y The y position to check.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getCharacterAt(x: number, y: number, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Types.GameObjects.BitmapText.BitmapTextCharacter;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * Changes the font this BitmapText is using to render.
     *
     * The new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,
     * unless overridden via the arguments.
     * @param font The key of the font to use from the Bitmap Font cache.
     * @param size The font size of this Bitmap Text. If not specified the current size will be used.
     * @param align The alignment of the text in a multi-line BitmapText object. If not specified the current alignment will be used. Default 0.
     */
    setFont(font: string, size?: number, align?: number): this;

    /**
     * Sets the maximum display width of this BitmapText in pixels.
     *
     * If `BitmapText.text` is longer than `maxWidth` then the lines will be automatically wrapped
     * based on the previous whitespace character found in the line.
     *
     * If no whitespace was found then no wrapping will take place and consequently the `maxWidth` value will not be honored.
     *
     * Disable maxWidth by setting the value to 0.
     *
     * You can set the whitespace character to be searched for by setting the `wordWrapCharCode` parameter or property.
     * @param value The maximum display width of this BitmapText in pixels. Set to zero to disable.
     * @param wordWrapCharCode The character code to check for when word wrapping. Defaults to 32 (the space character).
     */
    setMaxWidth(value: number, wordWrapCharCode?: number): this;

    /**
     * Controls the alignment of each line of text in this BitmapText object.
     *
     * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.
     * Has no effect with single-lines of text.
     *
     * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.
     *
     * 0 = Left aligned (default)
     * 1 = Middle aligned
     * 2 = Right aligned
     *
     * The alignment position is based on the longest line of text.
     */
    align: number;

    /**
     * The text that this Bitmap Text object displays.
     *
     * You can also use the method `setText` if you want a chainable way to change the text content.
     */
    text: string;

    /**
     * The font size of this Bitmap Text.
     *
     * You can also use the method `setFontSize` if you want a chainable way to change the font size.
     */
    fontSize: number;

    /**
     * Adds / Removes spacing between characters.
     *
     * Can be a negative or positive number.
     *
     * You can also use the method `setLetterSpacing` if you want a chainable way to change the letter spacing.
     */
    letterSpacing: number;

    /**
     * The maximum display width of this BitmapText in pixels.
     *
     * If BitmapText.text is longer than maxWidth then the lines will be automatically wrapped
     * based on the last whitespace character found in the line.
     *
     * If no whitespace was found then no wrapping will take place and consequently the maxWidth value will not be honored.
     *
     * Disable maxWidth by setting the value to 0.
     */
    maxWidth: number;

    /**
     * The width of this Bitmap Text.
     */
    readonly width: number;

    /**
     * The height of this bitmap text.
     */
    readonly height: number;

    /**
     * Build a JSON representation of this Bitmap Text.
     */
    toJSON(): Phaser.Types.GameObjects.BitmapText.JSONBitmapText;

    /**
     * Internal destroy handler, called as part of the destroy process.
     */
    protected preDestroy(): void;

    /**
     * Left align the text characters in a multi-line BitmapText object.
     */
    static ALIGN_LEFT: number;

    /**
     * Center align the text characters in a multi-line BitmapText object.
     */
    static ALIGN_CENTER: number;

    /**
     * Right align the text characters in a multi-line BitmapText object.
     */
    static ALIGN_RIGHT: number;

    /**
     * Parse an XML Bitmap Font from an Atlas.
     *
     * Adds the parsed Bitmap Font data to the cache with the `fontName` key.
     * @param scene The Scene to parse the Bitmap Font for.
     * @param fontName The key of the font to add to the Bitmap Font cache.
     * @param textureKey The key of the BitmapFont's texture.
     * @param frameKey The key of the BitmapFont texture's frame.
     * @param xmlKey The key of the XML data of the font to parse.
     * @param xSpacing The x-axis spacing to add between each letter.
     * @param ySpacing The y-axis spacing to add to the line height.
     */
    static ParseFromAtlas(scene: Phaser.Scene, fontName: string, textureKey: string, frameKey: string, xmlKey: string, xSpacing?: number, ySpacing?: number): boolean;

    /**
     * Parse an XML font to Bitmap Font data for the Bitmap Font cache.
     * @param xml The XML Document to parse the font from.
     * @param frame The texture frame to take into account when creating the uv data.
     * @param xSpacing The x-axis spacing to add between each letter. Default 0.
     * @param ySpacing The y-axis spacing to add to the line height. Default 0.
     */
    static ParseXMLBitmapFont(xml: XMLDocument, frame: Phaser.Textures.Frame, xSpacing?: number, ySpacing?: number): Phaser.Types.GameObjects.BitmapText.BitmapFontData;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager, or a Texture instance.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string | Phaser.Textures.Texture, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     * @param frame The name or index of the frame within the Texture.
     * @param updateSize Should this call adjust the size of the Game Object? Default true.
     * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
     */
    setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;

    /**
     * The tint value being applied to the top-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopLeft: number;

    /**
     * The tint value being applied to the top-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopRight: number;

    /**
     * The tint value being applied to the bottom-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomLeft: number;

    /**
     * The tint value being applied to the bottom-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomRight: number;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * Clears all tint values associated with this Game Object.
     *
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     */
    clearTint(): this;

    /**
     * Sets an additive tint on this Game Object.
     *
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a fill-based tint on this Game Object.
     *
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     */
    tint: number;

    /**
     * Does this Game Object have a tint applied?
     *
     * It checks to see if the 4 tint properties are set to the value 0xffffff
     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
     */
    readonly isTinted: boolean;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * A Blitter Game Object.
   *
   * The Blitter Game Object is a special kind of container that creates, updates and manages Bob objects.
   * Bobs are designed for rendering speed rather than flexibility. They consist of a texture, or frame from a texture,
   * a position and an alpha value. You cannot scale or rotate them. They use a batched drawing method for speed
   * during rendering.
   *
   * A Blitter Game Object has one texture bound to it. Bobs created by the Blitter can use any Frame from this
   * Texture to render with, but they cannot use any other Texture. It is this single texture-bind that allows
   * them their speed.
   *
   * If you have a need to blast a large volume of frames around the screen then Blitter objects are well worth
   * investigating. They are especially useful for using as a base for your own special effects systems.
   */
  class Blitter extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.
     * @param x The x coordinate of this Game Object in world space. Default 0.
     * @param y The y coordinate of this Game Object in world space. Default 0.
     * @param texture The key of the texture this Game Object will use for rendering. The Texture must already exist in the Texture Manager. Default '__DEFAULT'.
     * @param frame The Frame of the Texture that this Game Object will use. Only set if the Texture has multiple frames, such as a Texture Atlas or Sprite Sheet. Default 0.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, texture?: string, frame?: string | number);

    /**
     * The children of this Blitter.
     * This List contains all of the Bob objects created by the Blitter.
     */
    children: Phaser.Structs.List<Phaser.GameObjects.Bob>;

    /**
     * Is the Blitter considered dirty?
     * A 'dirty' Blitter has had its child count changed since the last frame.
     */
    dirty: boolean;

    /**
     * Creates a new Bob in this Blitter.
     *
     * The Bob is created at the given coordinates, relative to the Blitter and uses the given frame.
     * A Bob can use any frame belonging to the texture bound to the Blitter.
     * @param x The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     * @param y The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     * @param frame The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.
     * @param visible Should the created Bob render or not? Default true.
     * @param index The position in the Blitters Display List to add the new Bob at. Defaults to the top of the list.
     */
    create(x: number, y: number, frame?: string | number | Phaser.Textures.Frame, visible?: boolean, index?: number): Phaser.GameObjects.Bob;

    /**
     * Creates multiple Bob objects within this Blitter and then passes each of them to the specified callback.
     * @param callback The callback to invoke after creating a bob. It will be sent two arguments: The Bob and the index of the Bob.
     * @param quantity The quantity of Bob objects to create.
     * @param frame The Frame the Bobs will use. It must be part of the Blitter Texture.
     * @param visible Should the created Bob render or not? Default true.
     */
    createFromCallback(callback: CreateCallback, quantity: number, frame?: string | number | Phaser.Textures.Frame | string[] | number[] | Phaser.Textures.Frame[], visible?: boolean): Phaser.GameObjects.Bob[];

    /**
     * Creates multiple Bobs in one call.
     *
     * The amount created is controlled by a combination of the `quantity` argument and the number of frames provided.
     *
     * If the quantity is set to 10 and you provide 2 frames, then 20 Bobs will be created. 10 with the first
     * frame and 10 with the second.
     * @param quantity The quantity of Bob objects to create.
     * @param frame The Frame the Bobs will use. It must be part of the Blitter Texture.
     * @param visible Should the created Bob render or not? Default true.
     */
    createMultiple(quantity: number, frame?: string | number | Phaser.Textures.Frame | string[] | number[] | Phaser.Textures.Frame[], visible?: boolean): Phaser.GameObjects.Bob[];

    /**
     * Checks if the given child can render or not, by checking its `visible` and `alpha` values.
     * @param child The Bob to check for rendering.
     */
    childCanRender(child: Phaser.GameObjects.Bob): boolean;

    /**
     * Returns an array of Bobs to be rendered.
     * If the Blitter is dirty then a new list is generated and stored in `renderList`.
     */
    getRenderList(): Phaser.GameObjects.Bob[];

    /**
     * Removes all Bobs from the children List and clears the dirty flag.
     */
    clear(): void;

    /**
     * Internal destroy handler, called as part of the destroy process.
     */
    protected preDestroy(): void;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the size of this Game Object to be that of the given Frame.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param frame The frame to base the size of this Game Object on.
     */
    setSizeToFrame(frame: Phaser.Textures.Frame): this;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager, or a Texture instance.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string | Phaser.Textures.Texture, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     * @param frame The name or index of the frame within the Texture.
     * @param updateSize Should this call adjust the size of the Game Object? Default true.
     * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
     */
    setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * A Bob Game Object.
   *
   * A Bob belongs to a Blitter Game Object. The Blitter is responsible for managing and rendering this object.
   *
   * A Bob has a position, alpha value and a frame from a texture that it uses to render with. You can also toggle
   * the flipped and visible state of the Bob. The Frame the Bob uses to render can be changed dynamically, but it
   * must be a Frame within the Texture used by the parent Blitter.
   *
   * Bob positions are relative to the Blitter parent. So if you move the Blitter parent, all Bob children will
   * have their positions impacted by this change as well.
   *
   * You can manipulate Bob objects directly from your game code, but the creation and destruction of them should be
   * handled via the Blitter parent.
   */
  class Bob {
    /**
     *
     * @param blitter The parent Blitter object is responsible for updating this Bob.
     * @param x The horizontal position of this Game Object in the world, relative to the parent Blitter position.
     * @param y The vertical position of this Game Object in the world, relative to the parent Blitter position.
     * @param frame The Frame this Bob will render with, as defined in the Texture the parent Blitter is using.
     * @param visible Should the Bob render visible or not to start with?
     */
    constructor(blitter: Phaser.GameObjects.Blitter, x: number, y: number, frame: string | number, visible: boolean);

    /**
     * The Blitter object that this Bob belongs to.
     */
    parent: Phaser.GameObjects.Blitter;

    /**
     * The x position of this Bob, relative to the x position of the Blitter.
     */
    x: number;

    /**
     * The y position of this Bob, relative to the y position of the Blitter.
     */
    y: number;

    /**
     * The frame that the Bob uses to render with.
     * To change the frame use the `Bob.setFrame` method.
     */
    protected frame: Phaser.Textures.Frame;

    /**
     * A blank object which can be used to store data related to this Bob in.
     */
    data: object;

    /**
     * The tint value of this Bob.
     */
    tint: number;

    /**
     * The horizontally flipped state of the Bob.
     * A Bob that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture.
     */
    flipX: boolean;

    /**
     * The vertically flipped state of the Bob.
     * A Bob that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture.
     */
    flipY: boolean;

    /**
     * Changes the Texture Frame being used by this Bob.
     * The frame must be part of the Texture the parent Blitter is using.
     * If no value is given it will use the default frame of the Blitter parent.
     * @param frame The frame to be used during rendering.
     */
    setFrame(frame?: string | number | Phaser.Textures.Frame): this;

    /**
     * Resets the horizontal and vertical flipped state of this Bob back to their default un-flipped state.
     */
    resetFlip(): this;

    /**
     * Resets this Bob.
     *
     * Changes the position to the values given, and optionally changes the frame.
     *
     * Also resets the flipX and flipY values, sets alpha back to 1 and visible to true.
     * @param x The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     * @param y The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     * @param frame The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.
     */
    reset(x: number, y: number, frame?: string | number | Phaser.Textures.Frame): this;

    /**
     * Changes the position of this Bob to the values given.
     * @param x The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     * @param y The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     */
    setPosition(x: number, y: number): this;

    /**
     * Sets the horizontal flipped state of this Bob.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipX(value: boolean): this;

    /**
     * Sets the vertical flipped state of this Bob.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipY(value: boolean): this;

    /**
     * Sets the horizontal and vertical flipped state of this Bob.
     * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlip(x: boolean, y: boolean): this;

    /**
     * Sets the visibility of this Bob.
     *
     * An invisible Bob will skip rendering.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

    /**
     * Set the Alpha level of this Bob. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * A Bob with alpha 0 will skip rendering.
     * @param value The alpha value used for this Bob. Between 0 and 1.
     */
    setAlpha(value: number): this;

    /**
     * Sets the tint of this Bob.
     * @param value The tint value used for this Bob. Between 0 and 0xffffff.
     */
    setTint(value: number): this;

    /**
     * Destroys this Bob instance.
     * Removes itself from the Blitter and clears the parent, frame and data properties.
     */
    destroy(): void;

    /**
     * The visible state of the Bob.
     *
     * An invisible Bob will skip rendering.
     */
    visible: boolean;

    /**
     * The alpha value of the Bob, between 0 and 1.
     *
     * A Bob with alpha 0 will skip rendering.
     */
    alpha: number;

  }

  /**
   * Builds a Game Object using the provided configuration object.
   * @param scene A reference to the Scene.
   * @param gameObject The initial GameObject.
   * @param config The config to build the GameObject with.
   */
  function BuildGameObject(scene: Phaser.Scene, gameObject: Phaser.GameObjects.GameObject, config: Phaser.Types.GameObjects.GameObjectConfig): Phaser.GameObjects.GameObject;

  /**
   * Adds an Animation component to a Sprite and populates it based on the given config.
   * @param sprite The sprite to add an Animation component to.
   * @param config The animation config.
   */
  function BuildGameObjectAnimation(sprite: Phaser.GameObjects.Sprite, config: object): Phaser.GameObjects.Sprite;

  namespace Components {
    /**
     * Provides methods used for setting the alpha properties of a Game Object.
     * Should be applied as a mixin and not used directly.
     */
    interface Alpha {
      /**
       * Clears all alpha values associated with this Game Object.
       *
       * Immediately sets the alpha levels back to 1 (fully opaque).
       */
      clearAlpha(): this;
      /**
       * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
       * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
       *
       * If your game is running under WebGL you can optionally specify four different alpha values, each of which
       * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
       * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
       * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
       * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
       * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
       */
      setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;
      /**
       * The alpha value of the Game Object.
       *
       * This is a global value, impacting the entire Game Object, not just a region of it.
       */
      alpha: number;
      /**
       * The alpha value starting from the top-left of the Game Object.
       * This value is interpolated from the corner to the center of the Game Object.
       */
      alphaTopLeft: number;
      /**
       * The alpha value starting from the top-right of the Game Object.
       * This value is interpolated from the corner to the center of the Game Object.
       */
      alphaTopRight: number;
      /**
       * The alpha value starting from the bottom-left of the Game Object.
       * This value is interpolated from the corner to the center of the Game Object.
       */
      alphaBottomLeft: number;
      /**
       * The alpha value starting from the bottom-right of the Game Object.
       * This value is interpolated from the corner to the center of the Game Object.
       */
      alphaBottomRight: number;
    }

    /**
     * Provides methods used for setting the alpha property of a Game Object.
     * Should be applied as a mixin and not used directly.
     */
    interface AlphaSingle {
      /**
       * Clears all alpha values associated with this Game Object.
       *
       * Immediately sets the alpha levels back to 1 (fully opaque).
       */
      clearAlpha(): this;
      /**
       * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
       * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
       * @param value The alpha value applied across the whole Game Object. Default 1.
       */
      setAlpha(value?: number): this;
      /**
       * The alpha value of the Game Object.
       *
       * This is a global value, impacting the entire Game Object, not just a region of it.
       */
      alpha: number;
    }

    /**
     * Provides methods used for setting the blend mode of a Game Object.
     * Should be applied as a mixin and not used directly.
     */
    interface BlendMode {
      /**
       * Sets the Blend Mode being used by this Game Object.
       *
       * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
       *
       * Under WebGL only the following Blend Modes are available:
       *
       * * ADD
       * * MULTIPLY
       * * SCREEN
       * * ERASE
       *
       * Canvas has more available depending on browser support.
       *
       * You can also create your own custom Blend Modes in WebGL.
       *
       * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
       * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
       * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
       * are used.
       */
      blendMode: Phaser.BlendModes | string;
      /**
       * Sets the Blend Mode being used by this Game Object.
       *
       * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
       *
       * Under WebGL only the following Blend Modes are available:
       *
       * * ADD
       * * MULTIPLY
       * * SCREEN
       * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
       *
       * Canvas has more available depending on browser support.
       *
       * You can also create your own custom Blend Modes in WebGL.
       *
       * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
       * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
       * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
       * are used.
       * @param value The BlendMode value. Either a string or a CONST.
       */
      setBlendMode(value: string | Phaser.BlendModes): this;
    }

    /**
     * Provides methods used for calculating and setting the size of a non-Frame based Game Object.
     * Should be applied as a mixin and not used directly.
     */
    interface ComputedSize {
      /**
       * The native (un-scaled) width of this Game Object.
       *
       * Changing this value will not change the size that the Game Object is rendered in-game.
       * For that you need to either set the scale of the Game Object (`setScale`) or use
       * the `displayWidth` property.
       */
      width: number;
      /**
       * The native (un-scaled) height of this Game Object.
       *
       * Changing this value will not change the size that the Game Object is rendered in-game.
       * For that you need to either set the scale of the Game Object (`setScale`) or use
       * the `displayHeight` property.
       */
      height: number;
      /**
       * The displayed width of this Game Object.
       *
       * This value takes into account the scale factor.
       *
       * Setting this value will adjust the Game Object's scale property.
       */
      displayWidth: number;
      /**
       * The displayed height of this Game Object.
       *
       * This value takes into account the scale factor.
       *
       * Setting this value will adjust the Game Object's scale property.
       */
      displayHeight: number;
      /**
       * Sets the internal size of this Game Object, as used for frame or physics body creation.
       *
       * This will not change the size that the Game Object is rendered in-game.
       * For that you need to either set the scale of the Game Object (`setScale`) or call the
       * `setDisplaySize` method, which is the same thing as changing the scale but allows you
       * to do so by giving pixel values.
       *
       * If you have enabled this Game Object for input, changing the size will _not_ change the
       * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
       * @param width The width of this Game Object.
       * @param height The height of this Game Object.
       */
      setSize(width: number, height: number): this;
      /**
       * Sets the display size of this Game Object.
       *
       * Calling this will adjust the scale.
       * @param width The width of this Game Object.
       * @param height The height of this Game Object.
       */
      setDisplaySize(width: number, height: number): this;
    }

    /**
     * Provides methods used for getting and setting the texture of a Game Object.
     */
    interface Crop {
      /**
       * The Texture this Game Object is using to render with.
       */
      texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;
      /**
       * The Texture Frame this Game Object is using to render with.
       */
      frame: Phaser.Textures.Frame;
      /**
       * A boolean flag indicating if this Game Object is being cropped or not.
       * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
       * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
       */
      isCropped: boolean;
      /**
       * Applies a crop to a texture based Game Object, such as a Sprite or Image.
       *
       * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
       *
       * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
       * changes what is shown when rendered.
       *
       * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
       *
       * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
       * half of it, you could call `setCrop(0, 0, 400, 600)`.
       *
       * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
       * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
       *
       * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
       *
       * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
       *
       * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
       * the renderer to skip several internal calculations.
       * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
       * @param y The y coordinate to start the crop from.
       * @param width The width of the crop rectangle in pixels.
       * @param height The height of the crop rectangle in pixels.
       */
      setCrop(x?: number | Phaser.Geom.Rectangle, y?: number, width?: number, height?: number): this;
    }

    /**
     * Provides methods used for setting the depth of a Game Object.
     * Should be applied as a mixin and not used directly.
     */
    interface Depth {
      /**
       * The depth of this Game Object within the Scene.
       *
       * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
       * of Game Objects, without actually moving their position in the display list.
       *
       * The default depth is zero. A Game Object with a higher depth
       * value will always render in front of one with a lower value.
       *
       * Setting the depth will queue a depth sort event within the Scene.
       */
      depth: number;
      /**
       * The depth of this Game Object within the Scene.
       *
       * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
       * of Game Objects, without actually moving their position in the display list.
       *
       * The default depth is zero. A Game Object with a higher depth
       * value will always render in front of one with a lower value.
       *
       * Setting the depth will queue a depth sort event within the Scene.
       * @param value The depth of this Game Object.
       */
      setDepth(value: number): this;
    }

    /**
     * Provides methods used for visually flipping a Game Object.
     * Should be applied as a mixin and not used directly.
     */
    interface Flip {
      /**
       * The horizontally flipped state of the Game Object.
       *
       * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
       * Flipping always takes place from the middle of the texture and does not impact the scale value.
       * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
       */
      flipX: boolean;
      /**
       * The vertically flipped state of the Game Object.
       *
       * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
       * Flipping always takes place from the middle of the texture and does not impact the scale value.
       * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
       */
      flipY: boolean;
      /**
       * Toggles the horizontal flipped state of this Game Object.
       *
       * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
       * Flipping always takes place from the middle of the texture and does not impact the scale value.
       * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
       */
      toggleFlipX(): this;
      /**
       * Toggles the vertical flipped state of this Game Object.
       */
      toggleFlipY(): this;
      /**
       * Sets the horizontal flipped state of this Game Object.
       *
       * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
       * Flipping always takes place from the middle of the texture and does not impact the scale value.
       * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
       * @param value The flipped state. `false` for no flip, or `true` to be flipped.
       */
      setFlipX(value: boolean): this;
      /**
       * Sets the vertical flipped state of this Game Object.
       * @param value The flipped state. `false` for no flip, or `true` to be flipped.
       */
      setFlipY(value: boolean): this;
      /**
       * Sets the horizontal and vertical flipped state of this Game Object.
       *
       * A Game Object that is flipped will render inversed on the flipped axis.
       * Flipping always takes place from the middle of the texture and does not impact the scale value.
       * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
       * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
       * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
       */
      setFlip(x: boolean, y: boolean): this;
      /**
       * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
       */
      resetFlip(): this;
    }

    /**
     * Provides methods used for obtaining the bounds of a Game Object.
     * Should be applied as a mixin and not used directly.
     */
    interface GetBounds {
      /**
       * Gets the center coordinate of this Game Object, regardless of origin.
       * The returned point is calculated in local space and does not factor in any parent containers
       * @param output An object to store the values in. If not provided a new Vector2 will be created.
       */
      getCenter<O extends Phaser.Math.Vector2>(output?: O): O;
      /**
       * Gets the top-left corner coordinate of this Game Object, regardless of origin.
       * The returned point is calculated in local space and does not factor in any parent containers
       * @param output An object to store the values in. If not provided a new Vector2 will be created.
       * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
       */
      getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
      /**
       * Gets the top-center coordinate of this Game Object, regardless of origin.
       * The returned point is calculated in local space and does not factor in any parent containers
       * @param output An object to store the values in. If not provided a new Vector2 will be created.
       * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
       */
      getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
      /**
       * Gets the top-right corner coordinate of this Game Object, regardless of origin.
       * The returned point is calculated in local space and does not factor in any parent containers
       * @param output An object to store the values in. If not provided a new Vector2 will be created.
       * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
       */
      getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
      /**
       * Gets the left-center coordinate of this Game Object, regardless of origin.
       * The returned point is calculated in local space and does not factor in any parent containers
       * @param output An object to store the values in. If not provided a new Vector2 will be created.
       * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
       */
      getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
      /**
       * Gets the right-center coordinate of this Game Object, regardless of origin.
       * The returned point is calculated in local space and does not factor in any parent containers
       * @param output An object to store the values in. If not provided a new Vector2 will be created.
       * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
       */
      getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
      /**
       * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
       * The returned point is calculated in local space and does not factor in any parent containers
       * @param output An object to store the values in. If not provided a new Vector2 will be created.
       * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
       */
      getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
      /**
       * Gets the bottom-center coordinate of this Game Object, regardless of origin.
       * The returned point is calculated in local space and does not factor in any parent containers
       * @param output An object to store the values in. If not provided a new Vector2 will be created.
       * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
       */
      getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
      /**
       * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
       * The returned point is calculated in local space and does not factor in any parent containers
       * @param output An object to store the values in. If not provided a new Vector2 will be created.
       * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
       */
      getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
      /**
       * Gets the bounds of this Game Object, regardless of origin.
       * The values are stored and returned in a Rectangle, or Rectangle-like, object.
       * @param output An object to store the values in. If not provided a new Rectangle will be created.
       */
      getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;
    }

    /**
     * Provides methods used for getting and setting the mask of a Game Object.
     */
    interface Mask {
      /**
       * The Mask this Game Object is using during render.
       */
      mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;
      /**
       * Sets the mask that this Game Object will use to render with.
       *
       * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
       * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
       *
       * If a mask is already set on this Game Object it will be immediately replaced.
       *
       * Masks are positioned in global space and are not relative to the Game Object to which they
       * are applied. The reason for this is that multiple Game Objects can all share the same mask.
       *
       * Masks have no impact on physics or input detection. They are purely a rendering component
       * that allows you to limit what is visible during the render pass.
       * @param mask The mask this Game Object will use when rendering.
       */
      setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;
      /**
       * Clears the mask that this Game Object was using.
       * @param destroyMask Destroy the mask before clearing it? Default false.
       */
      clearMask(destroyMask?: boolean): this;
      /**
       * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
       * including this one.
       *
       * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
       *
       * To create the mask you need to pass in a reference to a renderable Game Object.
       * A renderable Game Object is one that uses a texture to render with, such as an
       * Image, Sprite, Render Texture or BitmapText.
       *
       * If you do not provide a renderable object, and this Game Object has a texture,
       * it will use itself as the object. This means you can call this method to create
       * a Bitmap Mask from any renderable Game Object.
       * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
       */
      createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;
      /**
       * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
       * including this one.
       *
       * To create the mask you need to pass in a reference to a Graphics Game Object.
       *
       * If you do not provide a graphics object, and this Game Object is an instance
       * of a Graphics object, then it will use itself to create the mask.
       *
       * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
       * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
       */
      createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;
    }

    /**
     * Provides methods used for getting and setting the origin of a Game Object.
     * Values are normalized, given in the range 0 to 1.
     * Display values contain the calculated pixel values.
     * Should be applied as a mixin and not used directly.
     */
    interface Origin {
      /**
       * The horizontal origin of this Game Object.
       * The origin maps the relationship between the size and position of the Game Object.
       * The default value is 0.5, meaning all Game Objects are positioned based on their center.
       * Setting the value to 0 means the position now relates to the left of the Game Object.
       */
      originX: number;
      /**
       * The vertical origin of this Game Object.
       * The origin maps the relationship between the size and position of the Game Object.
       * The default value is 0.5, meaning all Game Objects are positioned based on their center.
       * Setting the value to 0 means the position now relates to the top of the Game Object.
       */
      originY: number;
      /**
       * The horizontal display origin of this Game Object.
       * The origin is a normalized value between 0 and 1.
       * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
       */
      displayOriginX: number;
      /**
       * The vertical display origin of this Game Object.
       * The origin is a normalized value between 0 and 1.
       * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
       */
      displayOriginY: number;
      /**
       * Sets the origin of this Game Object.
       *
       * The values are given in the range 0 to 1.
       * @param x The horizontal origin value. Default 0.5.
       * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
       */
      setOrigin(x?: number, y?: number): this;
      /**
       * Sets the origin of this Game Object based on the Pivot values in its Frame.
       */
      setOriginFromFrame(): this;
      /**
       * Sets the display origin of this Game Object.
       * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
       * @param x The horizontal display origin value. Default 0.
       * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
       */
      setDisplayOrigin(x?: number, y?: number): this;
      /**
       * Updates the Display Origin cached values internally stored on this Game Object.
       * You don't usually call this directly, but it is exposed for edge-cases where you may.
       */
      updateDisplayOrigin(): this;
    }

    /**
     * Provides methods used for managing a Game Object following a Path.
     * Should be applied as a mixin and not used directly.
     */
    interface PathFollower {
      /**
       * The Path this PathFollower is following. It can only follow one Path at a time.
       */
      path: Phaser.Curves.Path;
      /**
       * Should the PathFollower automatically rotate to point in the direction of the Path?
       */
      rotateToPath: boolean;
      /**
       * Set the Path that this PathFollower should follow.
       *
       * Optionally accepts {@link Phaser.Types.GameObjects.PathFollower.PathConfig} settings.
       * @param path The Path this PathFollower is following. It can only follow one Path at a time.
       * @param config Settings for the PathFollower.
       */
      setPath(path: Phaser.Curves.Path, config?: number | Phaser.Types.GameObjects.PathFollower.PathConfig | Phaser.Types.Tweens.NumberTweenBuilderConfig): this;
      /**
       * Set whether the PathFollower should automatically rotate to point in the direction of the Path.
       * @param value Whether the PathFollower should automatically rotate to point in the direction of the Path.
       * @param offset Rotation offset in degrees. Default 0.
       */
      setRotateToPath(value: boolean, offset?: number): this;
      /**
       * Is this PathFollower actively following a Path or not?
       *
       * To be considered as `isFollowing` it must be currently moving on a Path, and not paused.
       */
      isFollowing(): boolean;
      /**
       * Starts this PathFollower following its given Path.
       * @param config The duration of the follow, or a PathFollower config object. Default {}.
       * @param startAt Optional start position of the follow, between 0 and 1. Default 0.
       */
      startFollow(config?: number | Phaser.Types.GameObjects.PathFollower.PathConfig | Phaser.Types.Tweens.NumberTweenBuilderConfig, startAt?: number): this;
      /**
       * Pauses this PathFollower. It will still continue to render, but it will remain motionless at the
       * point on the Path at which you paused it.
       */
      pauseFollow(): this;
      /**
       * Resumes a previously paused PathFollower.
       *
       * If the PathFollower was not paused this has no effect.
       */
      resumeFollow(): this;
      /**
       * Stops this PathFollower from following the path any longer.
       *
       * This will invoke any 'stop' conditions that may exist on the Path, or for the follower.
       */
      stopFollow(): this;
      /**
       * Internal update handler that advances this PathFollower along the path.
       *
       * Called automatically by the Scene step, should not typically be called directly.
       */
      pathUpdate(): void;
    }

    /**
     * Provides methods used for setting the WebGL rendering pipeline of a Game Object.
     */
    interface Pipeline {
      /**
       * The initial WebGL pipeline of this Game Object.
       *
       * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
       */
      defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;
      /**
       * The current WebGL pipeline of this Game Object.
       */
      pipeline: Phaser.Renderer.WebGL.WebGLPipeline;
      /**
       * Does this Game Object have any Post Pipelines set?
       */
      hasPostPipeline: boolean;
      /**
       * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
       *
       * The pipelines are processed in the order in which they appear in this array.
       *
       * If you modify this array directly, be sure to set the
       * `hasPostPipeline` property accordingly.
       */
      postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];
      /**
       * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
       */
      pipelineData: object;
      /**
       * Sets the initial WebGL Pipeline of this Game Object.
       *
       * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
       * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
       */
      initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;
      /**
       * Sets the main WebGL Pipeline of this Game Object.
       *
       * Also sets the `pipelineData` property, if the parameter is given.
       *
       * Both the pipeline and post pipelines share the same pipeline data object.
       * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
       * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
       * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
       */
      setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;
      /**
       * Sets one, or more, Post Pipelines on this Game Object.
       *
       * Post Pipelines are invoked after this Game Object has rendered to its target and
       * are commonly used for post-fx.
       *
       * The post pipelines are appended to the `postPipelines` array belonging to this
       * Game Object. When the renderer processes this Game Object, it iterates through the post
       * pipelines in the order in which they appear in the array. If you are stacking together
       * multiple effects, be aware that the order is important.
       *
       * If you call this method multiple times, the new pipelines will be appended to any existing
       * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
       *
       * You can optionally also sets the `pipelineData` property, if the parameter is given.
       *
       * Both the pipeline and post pipelines share the pipeline data object together.
       * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
       * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
       * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
       */
      setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;
      /**
       * Adds an entry to the `pipelineData` object belonging to this Game Object.
       *
       * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
       *
       * If `value` is undefined, and `key` exists, `key` is removed from the data object.
       *
       * Both the pipeline and post pipelines share the pipeline data object together.
       * @param key The key of the pipeline data to set, update, or delete.
       * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
       */
      setPipelineData(key: string, value?: any): this;
      /**
       * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
       * @param pipeline The string-based name of the pipeline, or a pipeline class.
       */
      getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];
      /**
       * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
       * @param resetPostPipelines Reset all of the post pipelines? Default false.
       * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
       */
      resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;
      /**
       * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
       * the `destroy` method on each post pipeline and then clearing the local array.
       * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
       */
      resetPostPipeline(resetData?: boolean): void;
      /**
       * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
       *
       * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
       * @param pipeline The string-based name of the pipeline, or a pipeline class.
       */
      removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;
      /**
       * Gets the name of the WebGL Pipeline this Game Object is currently using.
       */
      getPipelineName(): string;
    }

    /**
     * Provides methods used for getting and setting the Scroll Factor of a Game Object.
     */
    interface ScrollFactor {
      /**
       * The horizontal scroll factor of this Game Object.
       *
       * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
       *
       * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
       * It does not change the Game Objects actual position values.
       *
       * A value of 1 means it will move exactly in sync with a camera.
       * A value of 0 means it will not move at all, even if the camera moves.
       * Other values control the degree to which the camera movement is mapped to this Game Object.
       *
       * Please be aware that scroll factor values other than 1 are not taken in to consideration when
       * calculating physics collisions. Bodies always collide based on their world position, but changing
       * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
       * them from physics bodies if not accounted for in your code.
       */
      scrollFactorX: number;
      /**
       * The vertical scroll factor of this Game Object.
       *
       * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
       *
       * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
       * It does not change the Game Objects actual position values.
       *
       * A value of 1 means it will move exactly in sync with a camera.
       * A value of 0 means it will not move at all, even if the camera moves.
       * Other values control the degree to which the camera movement is mapped to this Game Object.
       *
       * Please be aware that scroll factor values other than 1 are not taken in to consideration when
       * calculating physics collisions. Bodies always collide based on their world position, but changing
       * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
       * them from physics bodies if not accounted for in your code.
       */
      scrollFactorY: number;
      /**
       * Sets the scroll factor of this Game Object.
       *
       * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
       *
       * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
       * It does not change the Game Objects actual position values.
       *
       * A value of 1 means it will move exactly in sync with a camera.
       * A value of 0 means it will not move at all, even if the camera moves.
       * Other values control the degree to which the camera movement is mapped to this Game Object.
       *
       * Please be aware that scroll factor values other than 1 are not taken in to consideration when
       * calculating physics collisions. Bodies always collide based on their world position, but changing
       * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
       * them from physics bodies if not accounted for in your code.
       * @param x The horizontal scroll factor of this Game Object.
       * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
       */
      setScrollFactor(x: number, y?: number): this;
    }

    /**
     * Provides methods used for getting and setting the size of a Game Object.
     */
    interface Size {
      /**
       * The native (un-scaled) width of this Game Object.
       *
       * Changing this value will not change the size that the Game Object is rendered in-game.
       * For that you need to either set the scale of the Game Object (`setScale`) or use
       * the `displayWidth` property.
       */
      width: number;
      /**
       * The native (un-scaled) height of this Game Object.
       *
       * Changing this value will not change the size that the Game Object is rendered in-game.
       * For that you need to either set the scale of the Game Object (`setScale`) or use
       * the `displayHeight` property.
       */
      height: number;
      /**
       * The displayed width of this Game Object.
       *
       * This value takes into account the scale factor.
       *
       * Setting this value will adjust the Game Object's scale property.
       */
      displayWidth: number;
      /**
       * The displayed height of this Game Object.
       *
       * This value takes into account the scale factor.
       *
       * Setting this value will adjust the Game Object's scale property.
       */
      displayHeight: number;
      /**
       * Sets the size of this Game Object to be that of the given Frame.
       *
       * This will not change the size that the Game Object is rendered in-game.
       * For that you need to either set the scale of the Game Object (`setScale`) or call the
       * `setDisplaySize` method, which is the same thing as changing the scale but allows you
       * to do so by giving pixel values.
       *
       * If you have enabled this Game Object for input, changing the size will _not_ change the
       * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
       * @param frame The frame to base the size of this Game Object on.
       */
      setSizeToFrame(frame: Phaser.Textures.Frame): this;
      /**
       * Sets the internal size of this Game Object, as used for frame or physics body creation.
       *
       * This will not change the size that the Game Object is rendered in-game.
       * For that you need to either set the scale of the Game Object (`setScale`) or call the
       * `setDisplaySize` method, which is the same thing as changing the scale but allows you
       * to do so by giving pixel values.
       *
       * If you have enabled this Game Object for input, changing the size will _not_ change the
       * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
       * @param width The width of this Game Object.
       * @param height The height of this Game Object.
       */
      setSize(width: number, height: number): this;
      /**
       * Sets the display size of this Game Object.
       *
       * Calling this will adjust the scale.
       * @param width The width of this Game Object.
       * @param height The height of this Game Object.
       */
      setDisplaySize(width: number, height: number): this;
    }

    /**
     * Provides methods used for getting and setting the texture of a Game Object.
     */
    interface Texture {
      /**
       * The Texture this Game Object is using to render with.
       */
      texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;
      /**
       * The Texture Frame this Game Object is using to render with.
       */
      frame: Phaser.Textures.Frame;
      /**
       * Sets the texture and frame this Game Object will use to render with.
       *
       * Textures are referenced by their string-based keys, as stored in the Texture Manager.
       * @param key The key of the texture to be used, as stored in the Texture Manager, or a Texture instance.
       * @param frame The name or index of the frame within the Texture.
       */
      setTexture(key: string | Phaser.Textures.Texture, frame?: string | number): this;
      /**
       * Sets the frame this Game Object will use to render with.
       *
       * The Frame has to belong to the current Texture being used.
       *
       * It can be either a string or an index.
       *
       * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
       * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
       * @param frame The name or index of the frame within the Texture.
       * @param updateSize Should this call adjust the size of the Game Object? Default true.
       * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
       */
      setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;
    }

    /**
     * Provides methods used for getting and setting the texture of a Game Object.
     */
    interface TextureCrop {
      /**
       * The Texture this Game Object is using to render with.
       */
      texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;
      /**
       * The Texture Frame this Game Object is using to render with.
       */
      frame: Phaser.Textures.Frame;
      /**
       * A boolean flag indicating if this Game Object is being cropped or not.
       * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
       * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
       */
      isCropped: boolean;
      /**
       * Applies a crop to a texture based Game Object, such as a Sprite or Image.
       *
       * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
       *
       * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
       * changes what is shown when rendered.
       *
       * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
       *
       * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
       * half of it, you could call `setCrop(0, 0, 400, 600)`.
       *
       * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
       * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
       *
       * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
       *
       * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
       *
       * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
       * the renderer to skip several internal calculations.
       * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
       * @param y The y coordinate to start the crop from.
       * @param width The width of the crop rectangle in pixels.
       * @param height The height of the crop rectangle in pixels.
       */
      setCrop(x?: number | Phaser.Geom.Rectangle, y?: number, width?: number, height?: number): this;
      /**
       * Sets the texture and frame this Game Object will use to render with.
       *
       * Textures are referenced by their string-based keys, as stored in the Texture Manager.
       * @param key The key of the texture to be used, as stored in the Texture Manager.
       * @param frame The name or index of the frame within the Texture.
       */
      setTexture(key: string, frame?: string | number): this;
      /**
       * Sets the frame this Game Object will use to render with.
       *
       * The Frame has to belong to the current Texture being used.
       *
       * It can be either a string or an index.
       *
       * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
       * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
       * @param frame The name or index of the frame within the Texture.
       * @param updateSize Should this call adjust the size of the Game Object? Default true.
       * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
       */
      setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;
    }

    /**
     * Provides methods used for setting the tint of a Game Object.
     * Should be applied as a mixin and not used directly.
     */
    interface Tint {
      /**
       * The tint value being applied to the top-left vertice of the Game Object.
       * This value is interpolated from the corner to the center of the Game Object.
       * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
       */
      tintTopLeft: number;
      /**
       * The tint value being applied to the top-right vertice of the Game Object.
       * This value is interpolated from the corner to the center of the Game Object.
       * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
       */
      tintTopRight: number;
      /**
       * The tint value being applied to the bottom-left vertice of the Game Object.
       * This value is interpolated from the corner to the center of the Game Object.
       * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
       */
      tintBottomLeft: number;
      /**
       * The tint value being applied to the bottom-right vertice of the Game Object.
       * This value is interpolated from the corner to the center of the Game Object.
       * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
       */
      tintBottomRight: number;
      /**
       * The tint fill mode.
       *
       * `false` = An additive tint (the default), where vertices colors are blended with the texture.
       * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
       */
      tintFill: boolean;
      /**
       * Clears all tint values associated with this Game Object.
       *
       * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
       * which results in no visible change to the texture.
       */
      clearTint(): this;
      /**
       * Sets an additive tint on this Game Object.
       *
       * The tint works by taking the pixel color values from the Game Objects texture, and then
       * multiplying it by the color value of the tint. You can provide either one color value,
       * in which case the whole Game Object will be tinted in that color. Or you can provide a color
       * per corner. The colors are blended together across the extent of the Game Object.
       *
       * To modify the tint color once set, either call this method again with new values or use the
       * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
       * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
       *
       * To remove a tint call `clearTint`.
       *
       * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
       * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
       * @param topRight The tint being applied to the top-right of the Game Object.
       * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
       * @param bottomRight The tint being applied to the bottom-right of the Game Object.
       */
      setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;
      /**
       * Sets a fill-based tint on this Game Object.
       *
       * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
       * with those in the tint. You can use this for effects such as making a player flash 'white'
       * if hit by something. You can provide either one color value, in which case the whole
       * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
       * are blended together across the extent of the Game Object.
       *
       * To modify the tint color once set, either call this method again with new values or use the
       * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
       * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
       *
       * To remove a tint call `clearTint`.
       *
       * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
       * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
       * @param topRight The tint being applied to the top-right of the Game Object.
       * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
       * @param bottomRight The tint being applied to the bottom-right of the Game Object.
       */
      setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;
      /**
       * The tint value being applied to the whole of the Game Object.
       * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
       */
      tint: number;
      /**
       * Does this Game Object have a tint applied?
       *
       * It checks to see if the 4 tint properties are set to the value 0xffffff
       * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
       */
      readonly isTinted: boolean;
    }

    /**
     * Build a JSON representation of the given Game Object.
     *
     * This is typically extended further by Game Object specific implementations.
     */
    interface ToJSON {
    }

    /**
     * Provides methods used for getting and setting the position, scale and rotation of a Game Object.
     */
    interface Transform {
      /**
       * The x position of this Game Object.
       */
      x: number;
      /**
       * The y position of this Game Object.
       */
      y: number;
      /**
       * The z position of this Game Object.
       *
       * Note: The z position does not control the rendering order of 2D Game Objects. Use
       * {@link Phaser.GameObjects.Components.Depth#depth} instead.
       */
      z: number;
      /**
       * The w position of this Game Object.
       */
      w: number;
      /**
       * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
       * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
       *
       * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
       * isn't the case, use the `scaleX` or `scaleY` properties instead.
       */
      scale: number;
      /**
       * The horizontal scale of this Game Object.
       */
      scaleX: number;
      /**
       * The vertical scale of this Game Object.
       */
      scaleY: number;
      /**
       * The angle of this Game Object as expressed in degrees.
       *
       * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
       * and -90 is up.
       *
       * If you prefer to work in radians, see the `rotation` property instead.
       */
      angle: number;
      /**
       * The angle of this Game Object in radians.
       *
       * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
       * and -PI/2 is up.
       *
       * If you prefer to work in degrees, see the `angle` property instead.
       */
      rotation: number;
      /**
       * Sets the position of this Game Object.
       * @param x The x position of this Game Object. Default 0.
       * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
       * @param z The z position of this Game Object. Default 0.
       * @param w The w position of this Game Object. Default 0.
       */
      setPosition(x?: number, y?: number, z?: number, w?: number): this;
      /**
       * Copies an object's coordinates to this Game Object's position.
       * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
       */
      copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;
      /**
       * Sets the position of this Game Object to be a random position within the confines of
       * the given area.
       *
       * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
       *
       * The position does not factor in the size of this Game Object, meaning that only the origin is
       * guaranteed to be within the area.
       * @param x The x position of the top-left of the random area. Default 0.
       * @param y The y position of the top-left of the random area. Default 0.
       * @param width The width of the random area.
       * @param height The height of the random area.
       */
      setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;
      /**
       * Sets the rotation of this Game Object.
       * @param radians The rotation of this Game Object, in radians. Default 0.
       */
      setRotation(radians?: number): this;
      /**
       * Sets the angle of this Game Object.
       * @param degrees The rotation of this Game Object, in degrees. Default 0.
       */
      setAngle(degrees?: number): this;
      /**
       * Sets the scale of this Game Object.
       * @param x The horizontal scale of this Game Object.
       * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
       */
      setScale(x: number, y?: number): this;
      /**
       * Sets the x position of this Game Object.
       * @param value The x position of this Game Object. Default 0.
       */
      setX(value?: number): this;
      /**
       * Sets the y position of this Game Object.
       * @param value The y position of this Game Object. Default 0.
       */
      setY(value?: number): this;
      /**
       * Sets the z position of this Game Object.
       *
       * Note: The z position does not control the rendering order of 2D Game Objects. Use
       * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
       * @param value The z position of this Game Object. Default 0.
       */
      setZ(value?: number): this;
      /**
       * Sets the w position of this Game Object.
       * @param value The w position of this Game Object. Default 0.
       */
      setW(value?: number): this;
      /**
       * Gets the local transform matrix for this Game Object.
       * @param tempMatrix The matrix to populate with the values from this Game Object.
       */
      getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;
      /**
       * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
       * @param tempMatrix The matrix to populate with the values from this Game Object.
       * @param parentMatrix A temporary matrix to hold parent values during the calculations.
       */
      getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;
      /**
       * Takes the given `x` and `y` coordinates and converts them into local space for this
       * Game Object, taking into account parent and local transforms, and the Display Origin.
       *
       * The returned Vector2 contains the translated point in its properties.
       *
       * A Camera needs to be provided in order to handle modified scroll factors. If no
       * camera is specified, it will use the `main` camera from the Scene to which this
       * Game Object belongs.
       * @param x The x position to translate.
       * @param y The y position to translate.
       * @param point A Vector2, or point-like object, to store the results in.
       * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
       */
      getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;
      /**
       * Gets the sum total rotation of all of this Game Objects parent Containers.
       *
       * The returned value is in radians and will be zero if this Game Object has no parent container.
       */
      getParentRotation(): number;
    }

    /**
     * A Matrix used for display transformations for rendering.
     *
     * It is represented like so:
     *
     * ```
     * | a | c | tx |
     * | b | d | ty |
     * | 0 | 0 | 1  |
     * ```
     */
    class TransformMatrix {
      /**
       *
       * @param a The Scale X value. Default 1.
       * @param b The Skew Y value. Default 0.
       * @param c The Skew X value. Default 0.
       * @param d The Scale Y value. Default 1.
       * @param tx The Translate X value. Default 0.
       * @param ty The Translate Y value. Default 0.
       */
      constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);

      /**
       * The matrix values.
       */
      matrix: Float32Array;

      /**
       * The decomposed matrix.
       */
      decomposedMatrix: object;

      /**
       * The Scale X value.
       */
      a: number;

      /**
       * The Skew Y value.
       */
      b: number;

      /**
       * The Skew X value.
       */
      c: number;

      /**
       * The Scale Y value.
       */
      d: number;

      /**
       * The Translate X value.
       */
      e: number;

      /**
       * The Translate Y value.
       */
      f: number;

      /**
       * The Translate X value.
       */
      tx: number;

      /**
       * The Translate Y value.
       */
      ty: number;

      /**
       * The rotation of the Matrix. Value is in radians.
       */
      readonly rotation: number;

      /**
       * The rotation of the Matrix, normalized to be within the Phaser right-handed
       * clockwise rotation space. Value is in radians.
       */
      readonly rotationNormalized: number;

      /**
       * The decomposed horizontal scale of the Matrix. This value is always positive.
       */
      readonly scaleX: number;

      /**
       * The decomposed vertical scale of the Matrix. This value is always positive.
       */
      readonly scaleY: number;

      /**
       * Reset the Matrix to an identity matrix.
       */
      loadIdentity(): this;

      /**
       * Translate the Matrix.
       * @param x The horizontal translation value.
       * @param y The vertical translation value.
       */
      translate(x: number, y: number): this;

      /**
       * Scale the Matrix.
       * @param x The horizontal scale value.
       * @param y The vertical scale value.
       */
      scale(x: number, y: number): this;

      /**
       * Rotate the Matrix.
       * @param angle The angle of rotation in radians.
       */
      rotate(angle: number): this;

      /**
       * Multiply this Matrix by the given Matrix.
       *
       * If an `out` Matrix is given then the results will be stored in it.
       * If it is not given, this matrix will be updated in place instead.
       * Use an `out` Matrix if you do not wish to mutate this matrix.
       * @param rhs The Matrix to multiply by.
       * @param out An optional Matrix to store the results in.
       */
      multiply(rhs: Phaser.GameObjects.Components.TransformMatrix, out?: Phaser.GameObjects.Components.TransformMatrix): this | Phaser.GameObjects.Components.TransformMatrix;

      /**
       * Multiply this Matrix by the matrix given, including the offset.
       *
       * The offsetX is added to the tx value: `offsetX * a + offsetY * c + tx`.
       * The offsetY is added to the ty value: `offsetY * b + offsetY * d + ty`.
       * @param src The source Matrix to copy from.
       * @param offsetX Horizontal offset to factor in to the multiplication.
       * @param offsetY Vertical offset to factor in to the multiplication.
       */
      multiplyWithOffset(src: Phaser.GameObjects.Components.TransformMatrix, offsetX: number, offsetY: number): this;

      /**
       * Transform the Matrix.
       * @param a The Scale X value.
       * @param b The Shear Y value.
       * @param c The Shear X value.
       * @param d The Scale Y value.
       * @param tx The Translate X value.
       * @param ty The Translate Y value.
       */
      transform(a: number, b: number, c: number, d: number, tx: number, ty: number): this;

      /**
       * Transform a point using this Matrix.
       * @param x The x coordinate of the point to transform.
       * @param y The y coordinate of the point to transform.
       * @param point The Point object to store the transformed coordinates.
       */
      transformPoint(x: number, y: number, point: Phaser.Geom.Point | Phaser.Math.Vector2 | object): Phaser.Geom.Point | Phaser.Math.Vector2 | object;

      /**
       * Invert the Matrix.
       */
      invert(): this;

      /**
       * Set the values of this Matrix to copy those of the matrix given.
       * @param src The source Matrix to copy from.
       */
      copyFrom(src: Phaser.GameObjects.Components.TransformMatrix): this;

      /**
       * Set the values of this Matrix to copy those of the array given.
       * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.
       * @param src The array of values to set into this matrix.
       */
      copyFromArray(src: any[]): this;

      /**
       * Copy the values from this Matrix to the given Canvas Rendering Context.
       * This will use the Context.transform method.
       * @param ctx The Canvas Rendering Context to copy the matrix values to.
       */
      copyToContext(ctx: CanvasRenderingContext2D): CanvasRenderingContext2D;

      /**
       * Copy the values from this Matrix to the given Canvas Rendering Context.
       * This will use the Context.setTransform method.
       * @param ctx The Canvas Rendering Context to copy the matrix values to.
       */
      setToContext(ctx: CanvasRenderingContext2D): CanvasRenderingContext2D;

      /**
       * Copy the values in this Matrix to the array given.
       *
       * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.
       * @param out The array to copy the matrix values in to.
       */
      copyToArray(out?: any[]): any[];

      /**
       * Set the values of this Matrix.
       * @param a The Scale X value.
       * @param b The Shear Y value.
       * @param c The Shear X value.
       * @param d The Scale Y value.
       * @param tx The Translate X value.
       * @param ty The Translate Y value.
       */
      setTransform(a: number, b: number, c: number, d: number, tx: number, ty: number): this;

      /**
       * Decompose this Matrix into its translation, scale and rotation values using QR decomposition.
       *
       * The result must be applied in the following order to reproduce the current matrix:
       *
       * translate -> rotate -> scale
       */
      decomposeMatrix(): object;

      /**
       * Apply the identity, translate, rotate and scale operations on the Matrix.
       * @param x The horizontal translation.
       * @param y The vertical translation.
       * @param rotation The angle of rotation in radians.
       * @param scaleX The horizontal scale.
       * @param scaleY The vertical scale.
       */
      applyITRS(x: number, y: number, rotation: number, scaleX: number, scaleY: number): this;

      /**
       * Takes the `x` and `y` values and returns a new position in the `output` vector that is the inverse of
       * the current matrix with its transformation applied.
       *
       * Can be used to translate points from world to local space.
       * @param x The x position to translate.
       * @param y The y position to translate.
       * @param output A Vector2, or point-like object, to store the results in.
       */
      applyInverse(x: number, y: number, output?: Phaser.Math.Vector2): Phaser.Math.Vector2;

      /**
       * Returns the X component of this matrix multiplied by the given values.
       * This is the same as `x * a + y * c + e`.
       * @param x The x value.
       * @param y The y value.
       */
      getX(x: number, y: number): number;

      /**
       * Returns the Y component of this matrix multiplied by the given values.
       * This is the same as `x * b + y * d + f`.
       * @param x The x value.
       * @param y The y value.
       */
      getY(x: number, y: number): number;

      /**
       * Returns the X component of this matrix multiplied by the given values.
       *
       * This is the same as `x * a + y * c + e`, optionally passing via `Math.round`.
       * @param x The x value.
       * @param y The y value.
       * @param round Math.round the resulting value? Default false.
       */
      getXRound(x: number, y: number, round?: boolean): number;

      /**
       * Returns the Y component of this matrix multiplied by the given values.
       *
       * This is the same as `x * b + y * d + f`, optionally passing via `Math.round`.
       * @param x The x value.
       * @param y The y value.
       * @param round Math.round the resulting value? Default false.
       */
      getYRound(x: number, y: number, round?: boolean): number;

      /**
       * Returns a string that can be used in a CSS Transform call as a `matrix` property.
       */
      getCSSMatrix(): string;

      /**
       * Destroys this Transform Matrix.
       */
      destroy(): void;

    }

    /**
     * Provides methods used for setting the visibility of a Game Object.
     * Should be applied as a mixin and not used directly.
     */
    interface Visible {
      /**
       * The visible state of the Game Object.
       *
       * An invisible Game Object will skip rendering, but will still process update logic.
       */
      visible: boolean;
      /**
       * Sets the visibility of this Game Object.
       *
       * An invisible Game Object will skip rendering, but will still process update logic.
       * @param value The visible state of the Game Object.
       */
      setVisible(value: boolean): this;
    }

  }

  /**
   * A Container Game Object.
   *
   * A Container, as the name implies, can 'contain' other types of Game Object.
   * When a Game Object is added to a Container, the Container becomes responsible for the rendering of it.
   * By default it will be removed from the Display List and instead added to the Containers own internal list.
   *
   * The position of the Game Object automatically becomes relative to the position of the Container.
   *
   * The transform point of a Container is 0x0 (in local space) and that cannot be changed. The children you add to the
   * Container should be positioned with this value in mind. I.e. you should treat 0x0 as being the center of
   * the Container, and position children positively and negative around it as required.
   *
   * When the Container is rendered, all of its children are rendered as well, in the order in which they exist
   * within the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.
   *
   * If you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will
   * automatically influence all children as well.
   *
   * Containers can include other Containers for deeply nested transforms.
   *
   * Containers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.
   * The masks do not 'stack up'. Only a Container on the root of the display list will use its mask.
   *
   * Containers can be enabled for input. Because they do not have a texture you need to provide a shape for them
   * to use as their hit area. Container children can also be enabled for input, independent of the Container.
   *
   * If input enabling a _child_ you should not set both the `origin` and a **negative** scale factor on the child,
   * or the input area will become misaligned.
   *
   * Containers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,
   * if Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,
   * if the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children
   * with physics do not factor in the Container due to the excessive extra calculations needed. Please structure
   * your game to work around this.
   *
   * It's important to understand the impact of using Containers. They add additional processing overhead into
   * every one of their children. The deeper you nest them, the more the cost escalates. This is especially true
   * for input events. You also loose the ability to set the display depth of Container children in the same
   * flexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost
   * every time you create one, try to structure your game around avoiding that where possible.
   */
  class Container extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.AlphaSingle, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param children An optional array of Game Objects to add to this Container.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, children?: Phaser.GameObjects.GameObject[]);

    /**
     * An array holding the children of this Container.
     */
    list: Phaser.GameObjects.GameObject[];

    /**
     * Does this Container exclusively manage its children?
     *
     * The default is `true` which means a child added to this Container cannot
     * belong in another Container, which includes the Scene display list.
     *
     * If you disable this then this Container will no longer exclusively manage its children.
     * This allows you to create all kinds of interesting graphical effects, such as replicating
     * Game Objects without reparenting them all over the Scene.
     * However, doing so will prevent children from receiving any kind of input event or have
     * their physics bodies work by default, as they're no longer a single entity on the
     * display list, but are being replicated where-ever this Container is.
     */
    exclusive: boolean;

    /**
     * Containers can have an optional maximum size. If set to anything above 0 it
     * will constrict the addition of new Game Objects into the Container, capping off
     * the maximum limit the Container can grow in size to.
     */
    maxSize: number;

    /**
     * The cursor position.
     */
    position: number;

    /**
     * Internal Transform Matrix used for local space conversion.
     */
    localTransform: Phaser.GameObjects.Components.TransformMatrix;

    /**
     * The horizontal scroll factor of this Container.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Container.
     *
     * When a camera scrolls it will change the location at which this Container is rendered on-screen.
     * It does not change the Containers actual position values.
     *
     * For a Container, setting this value will only update the Container itself, not its children.
     * If you wish to change the scrollFactor of the children as well, use the `setScrollFactor` method.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Container.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Container.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Container.
     *
     * When a camera scrolls it will change the location at which this Container is rendered on-screen.
     * It does not change the Containers actual position values.
     *
     * For a Container, setting this value will only update the Container itself, not its children.
     * If you wish to change the scrollFactor of the children as well, use the `setScrollFactor` method.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Container.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Internal value to allow Containers to be used for input and physics.
     * Do not change this value. It has no effect other than to break things.
     */
    readonly originX: number;

    /**
     * Internal value to allow Containers to be used for input and physics.
     * Do not change this value. It has no effect other than to break things.
     */
    readonly originY: number;

    /**
     * Internal value to allow Containers to be used for input and physics.
     * Do not change this value. It has no effect other than to break things.
     */
    readonly displayOriginX: number;

    /**
     * Internal value to allow Containers to be used for input and physics.
     * Do not change this value. It has no effect other than to break things.
     */
    readonly displayOriginY: number;

    /**
     * Does this Container exclusively manage its children?
     *
     * The default is `true` which means a child added to this Container cannot
     * belong in another Container, which includes the Scene display list.
     *
     * If you disable this then this Container will no longer exclusively manage its children.
     * This allows you to create all kinds of interesting graphical effects, such as replicating
     * Game Objects without reparenting them all over the Scene.
     * However, doing so will prevent children from receiving any kind of input event or have
     * their physics bodies work by default, as they're no longer a single entity on the
     * display list, but are being replicated where-ever this Container is.
     * @param value The exclusive state of this Container. Default true.
     */
    setExclusive(value?: boolean): this;

    /**
     * Gets the bounds of this Container. It works by iterating all children of the Container,
     * getting their respective bounds, and then working out a min-max rectangle from that.
     * It does not factor in if the children render or not, all are included.
     *
     * Some children are unable to return their bounds, such as Graphics objects, in which case
     * they are skipped.
     *
     * Depending on the quantity of children in this Container it could be a really expensive call,
     * so cache it and only poll it as needed.
     *
     * The values are stored and returned in a Rectangle object.
     * @param output A Geom.Rectangle object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds(output?: Phaser.Geom.Rectangle): Phaser.Geom.Rectangle;

    /**
     * Takes a Point-like object, such as a Vector2, Geom.Point or object with public x and y properties,
     * and transforms it into the space of this Container, then returns it in the output object.
     * @param source The Source Point to be transformed.
     * @param output A destination object to store the transformed point in. If none given a Vector2 will be created and returned.
     */
    pointToContainer(source: object | Phaser.Geom.Point | Phaser.Math.Vector2, output?: object | Phaser.Geom.Point | Phaser.Math.Vector2): object | Phaser.Geom.Point | Phaser.Math.Vector2;

    /**
     * Returns the world transform matrix as used for Bounds checks.
     *
     * The returned matrix is temporal and shouldn't be stored.
     */
    getBoundsTransformMatrix(): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Adds the given Game Object, or array of Game Objects, to this Container.
     *
     * Each Game Object must be unique within the Container.
     * @param child The Game Object, or array of Game Objects, to add to the Container.
     */
    add(child: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[]): this;

    /**
     * Adds the given Game Object, or array of Game Objects, to this Container at the specified position.
     *
     * Existing Game Objects in the Container are shifted up.
     *
     * Each Game Object must be unique within the Container.
     * @param child The Game Object, or array of Game Objects, to add to the Container.
     * @param index The position to insert the Game Object/s at. Default 0.
     */
    addAt(child: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], index?: number): this;

    /**
     * Returns the Game Object at the given position in this Container.
     * @param index The position to get the Game Object from.
     */
    getAt(index: number): Phaser.GameObjects.GameObject;

    /**
     * Returns the index of the given Game Object in this Container.
     * @param child The Game Object to search for in this Container.
     */
    getIndex(child: Phaser.GameObjects.GameObject): number;

    /**
     * Sort the contents of this Container so the items are in order based on the given property.
     * For example: `sort('alpha')` would sort the elements based on the value of their `alpha` property.
     * @param property The property to lexically sort by.
     * @param handler Provide your own custom handler function. Will receive 2 children which it should compare and return a boolean.
     */
    sort(property: string, handler?: Function): this;

    /**
     * Searches for the first instance of a child with its `name` property matching the given argument.
     * Should more than one child have the same name only the first is returned.
     * @param name The name to search for.
     */
    getByName(name: string): Phaser.GameObjects.GameObject;

    /**
     * Returns a random Game Object from this Container.
     * @param startIndex An optional start index. Default 0.
     * @param length An optional length, the total number of elements (from the startIndex) to choose from.
     */
    getRandom(startIndex?: number, length?: number): Phaser.GameObjects.GameObject;

    /**
     * Gets the first Game Object in this Container.
     *
     * You can also specify a property and value to search for, in which case it will return the first
     * Game Object in this Container with a matching property and / or value.
     *
     * For example: `getFirst('visible', true)` would return the first Game Object that had its `visible` property set.
     *
     * You can limit the search to the `startIndex` - `endIndex` range.
     * @param property The property to test on each Game Object in the Container.
     * @param value The value to test the property against. Must pass a strict (`===`) comparison check.
     * @param startIndex An optional start index to search from. Default 0.
     * @param endIndex An optional end index to search up to (but not included) Default Container.length.
     */
    getFirst(property: string, value: any, startIndex?: number, endIndex?: number): Phaser.GameObjects.GameObject;

    /**
     * Returns all Game Objects in this Container.
     *
     * You can optionally specify a matching criteria using the `property` and `value` arguments.
     *
     * For example: `getAll('body')` would return only Game Objects that have a body property.
     *
     * You can also specify a value to compare the property to:
     *
     * `getAll('visible', true)` would return only Game Objects that have their visible property set to `true`.
     *
     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,
     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
     * the first 50 Game Objects.
     * @param property The property to test on each Game Object in the Container.
     * @param value If property is set then the `property` must strictly equal this value to be included in the results.
     * @param startIndex An optional start index to search from. Default 0.
     * @param endIndex An optional end index to search up to (but not included) Default Container.length.
     */
    getAll(property?: string, value?: any, startIndex?: number, endIndex?: number): Phaser.GameObjects.GameObject[];

    /**
     * Returns the total number of Game Objects in this Container that have a property
     * matching the given value.
     *
     * For example: `count('visible', true)` would count all the elements that have their visible property set.
     *
     * You can optionally limit the operation to the `startIndex` - `endIndex` range.
     * @param property The property to check.
     * @param value The value to check.
     * @param startIndex An optional start index to search from. Default 0.
     * @param endIndex An optional end index to search up to (but not included) Default Container.length.
     */
    count(property: string, value: any, startIndex?: number, endIndex?: number): number;

    /**
     * Swaps the position of two Game Objects in this Container.
     * Both Game Objects must belong to this Container.
     * @param child1 The first Game Object to swap.
     * @param child2 The second Game Object to swap.
     */
    swap(child1: Phaser.GameObjects.GameObject, child2: Phaser.GameObjects.GameObject): this;

    /**
     * Moves a Game Object to a new position within this Container.
     *
     * The Game Object must already be a child of this Container.
     *
     * The Game Object is removed from its old position and inserted into the new one.
     * Therefore the Container size does not change. Other children will change position accordingly.
     * @param child The Game Object to move.
     * @param index The new position of the Game Object in this Container.
     */
    moveTo(child: Phaser.GameObjects.GameObject, index: number): this;

    /**
     * Moves a Game Object above another one within this Container.
     *
     * These 2 Game Objects must already be children of this Container.
     * @param child1 The Game Object to move above base Game Object.
     * @param child2 The base Game Object.
     */
    moveAbove(child1: Phaser.GameObjects.GameObject, child2: Phaser.GameObjects.GameObject): this;

    /**
     * Moves a Game Object below another one within this Container.
     *
     * These 2 Game Objects must already be children of this Container.
     * @param child1 The Game Object to move below base Game Object.
     * @param child2 The base Game Object.
     */
    moveBelow(child1: Phaser.GameObjects.GameObject, child2: Phaser.GameObjects.GameObject): this;

    /**
     * Removes the given Game Object, or array of Game Objects, from this Container.
     *
     * The Game Objects must already be children of this Container.
     *
     * You can also optionally call `destroy` on each Game Object that is removed from the Container.
     * @param child The Game Object, or array of Game Objects, to be removed from the Container.
     * @param destroyChild Optionally call `destroy` on each child successfully removed from this Container. Default false.
     */
    remove(child: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], destroyChild?: boolean): this;

    /**
     * Removes the Game Object at the given position in this Container.
     *
     * You can also optionally call `destroy` on the Game Object, if one is found.
     * @param index The index of the Game Object to be removed.
     * @param destroyChild Optionally call `destroy` on the Game Object if successfully removed from this Container. Default false.
     */
    removeAt(index: number, destroyChild?: boolean): this;

    /**
     * Removes the Game Objects between the given positions in this Container.
     *
     * You can also optionally call `destroy` on each Game Object that is removed from the Container.
     * @param startIndex An optional start index to search from. Default 0.
     * @param endIndex An optional end index to search up to (but not included) Default Container.length.
     * @param destroyChild Optionally call `destroy` on each Game Object successfully removed from this Container. Default false.
     */
    removeBetween(startIndex?: number, endIndex?: number, destroyChild?: boolean): this;

    /**
     * Removes all Game Objects from this Container.
     *
     * You can also optionally call `destroy` on each Game Object that is removed from the Container.
     * @param destroyChild Optionally call `destroy` on each Game Object successfully removed from this Container. Default false.
     */
    removeAll(destroyChild?: boolean): this;

    /**
     * Brings the given Game Object to the top of this Container.
     * This will cause it to render on-top of any other objects in the Container.
     * @param child The Game Object to bring to the top of the Container.
     */
    bringToTop(child: Phaser.GameObjects.GameObject): this;

    /**
     * Sends the given Game Object to the bottom of this Container.
     * This will cause it to render below any other objects in the Container.
     * @param child The Game Object to send to the bottom of the Container.
     */
    sendToBack(child: Phaser.GameObjects.GameObject): this;

    /**
     * Moves the given Game Object up one place in this Container, unless it's already at the top.
     * @param child The Game Object to be moved in the Container.
     */
    moveUp(child: Phaser.GameObjects.GameObject): this;

    /**
     * Moves the given Game Object down one place in this Container, unless it's already at the bottom.
     * @param child The Game Object to be moved in the Container.
     */
    moveDown(child: Phaser.GameObjects.GameObject): this;

    /**
     * Reverses the order of all Game Objects in this Container.
     */
    reverse(): this;

    /**
     * Shuffles the all Game Objects in this Container using the Fisher-Yates implementation.
     */
    shuffle(): this;

    /**
     * Replaces a Game Object in this Container with the new Game Object.
     * The new Game Object cannot already be a child of this Container.
     * @param oldChild The Game Object in this Container that will be replaced.
     * @param newChild The Game Object to be added to this Container.
     * @param destroyChild Optionally call `destroy` on the Game Object if successfully removed from this Container. Default false.
     */
    replace(oldChild: Phaser.GameObjects.GameObject, newChild: Phaser.GameObjects.GameObject, destroyChild?: boolean): this;

    /**
     * Returns `true` if the given Game Object is a direct child of this Container.
     *
     * This check does not scan nested Containers.
     * @param child The Game Object to check for within this Container.
     */
    exists(child: Phaser.GameObjects.GameObject): boolean;

    /**
     * Sets the property to the given value on all Game Objects in this Container.
     *
     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,
     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
     * the first 50 Game Objects.
     * @param property The property that must exist on the Game Object.
     * @param value The value to get the property to.
     * @param startIndex An optional start index to search from. Default 0.
     * @param endIndex An optional end index to search up to (but not included) Default Container.length.
     */
    setAll(property: string, value: any, startIndex?: number, endIndex?: number): this;

    /**
     * Passes all Game Objects in this Container to the given callback.
     *
     * A copy of the Container is made before passing each entry to your callback.
     * This protects against the callback itself modifying the Container.
     *
     * If you know for sure that the callback will not change the size of this Container
     * then you can use the more performant `Container.iterate` method instead.
     * @param callback The function to call.
     * @param context Value to use as `this` when executing callback.
     * @param args Additional arguments that will be passed to the callback, after the child.
     */
    each(callback: Function, context?: object, ...args: any[]): this;

    /**
     * Passes all Game Objects in this Container to the given callback.
     *
     * Only use this method when you absolutely know that the Container will not be modified during
     * the iteration, i.e. by removing or adding to its contents.
     * @param callback The function to call.
     * @param context Value to use as `this` when executing callback.
     * @param args Additional arguments that will be passed to the callback, after the child.
     */
    iterate(callback: Function, context?: object, ...args: any[]): this;

    /**
     * Sets the scroll factor of this Container and optionally all of its children.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     * @param updateChildren Apply this scrollFactor to all Container children as well? Default false.
     */
    setScrollFactor(x: number, y?: number, updateChildren?: boolean): this;

    /**
     * The number of Game Objects inside this Container.
     */
    readonly length: number;

    /**
     * Returns the first Game Object within the Container, or `null` if it is empty.
     *
     * You can move the cursor by calling `Container.next` and `Container.previous`.
     */
    readonly first: Phaser.GameObjects.GameObject;

    /**
     * Returns the last Game Object within the Container, or `null` if it is empty.
     *
     * You can move the cursor by calling `Container.next` and `Container.previous`.
     */
    readonly last: Phaser.GameObjects.GameObject;

    /**
     * Returns the next Game Object within the Container, or `null` if it is empty.
     *
     * You can move the cursor by calling `Container.next` and `Container.previous`.
     */
    readonly next: Phaser.GameObjects.GameObject;

    /**
     * Returns the previous Game Object within the Container, or `null` if it is empty.
     *
     * You can move the cursor by calling `Container.next` and `Container.previous`.
     */
    readonly previous: Phaser.GameObjects.GameObject;

    /**
     * Internal destroy handler, called as part of the destroy process.
     */
    protected preDestroy(): void;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Display List plugin.
   *
   * Display Lists belong to a Scene and maintain the list of Game Objects to render every frame.
   *
   * Some of these Game Objects may also be part of the Scene's [Update List]{@link Phaser.GameObjects.UpdateList}, for updating.
   */
  class DisplayList extends Phaser.Structs.List<Phaser.GameObjects.GameObject> {
    /**
     *
     * @param scene The Scene that this Display List belongs to.
     */
    constructor(scene: Phaser.Scene);

    /**
     * The flag the determines whether Game Objects should be sorted when `depthSort()` is called.
     */
    sortChildrenFlag: boolean;

    /**
     * The Scene that this Display List belongs to.
     */
    scene: Phaser.Scene;

    /**
     * The Scene's Systems.
     */
    systems: Phaser.Scenes.Systems;

    /**
     * The Scene's Event Emitter.
     */
    events: Phaser.Events.EventEmitter;

    /**
     * Force a sort of the display list on the next call to depthSort.
     */
    queueDepthSort(): void;

    /**
     * Immediately sorts the display list if the flag is set.
     */
    depthSort(): void;

    /**
     * Compare the depth of two Game Objects.
     * @param childA The first Game Object.
     * @param childB The second Game Object.
     */
    sortByDepth(childA: Phaser.GameObjects.GameObject, childB: Phaser.GameObjects.GameObject): number;

    /**
     * Returns an array which contains all objects currently on the Display List.
     * This is a reference to the main list array, not a copy of it, so be careful not to modify it.
     */
    getChildren(): Phaser.GameObjects.GameObject[];

  }

  /**
   * DOM Element Game Objects are a way to control and manipulate HTML Elements over the top of your game.
   *
   * In order for DOM Elements to display you have to enable them by adding the following to your game
   * configuration object:
   *
   * ```javascript
   * dom {
   *   createContainer: true
   * }
   * ```
   *
   * When this is added, Phaser will automatically create a DOM Container div that is positioned over the top
   * of the game canvas. This div is sized to match the canvas, and if the canvas size changes, as a result of
   * settings within the Scale Manager, the dom container is resized accordingly.
   *
   * If you have not already done so, you have to provide a `parent` in the Game Configuration, or the DOM
   * Container will fail to be created.
   *
   * You can create a DOM Element by either passing in DOMStrings, or by passing in a reference to an existing
   * Element that you wish to be placed under the control of Phaser. For example:
   *
   * ```javascript
   * this.add.dom(x, y, 'div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');
   * ```
   *
   * The above code will insert a div element into the DOM Container at the given x/y coordinate. The DOMString in
   * the 4th argument sets the initial CSS style of the div and the final argument is the inner text. In this case,
   * it will create a lime colored div that is 220px by 100px in size with the text Phaser in it, in an Arial font.
   *
   * You should nearly always, without exception, use explicitly sized HTML Elements, in order to fully control
   * alignment and positioning of the elements next to regular game content.
   *
   * Rather than specify the CSS and HTML directly you can use the `load.html` File Loader to load it into the
   * cache and then use the `createFromCache` method instead. You can also use `createFromHTML` and various other
   * methods available in this class to help construct your elements.
   *
   * Once the element has been created you can then control it like you would any other Game Object. You can set its
   * position, scale, rotation, alpha and other properties. It will move as the main Scene Camera moves and be clipped
   * at the edge of the canvas. It's important to remember some limitations of DOM Elements: The obvious one is that
   * they appear above or below your game canvas. You cannot blend them into the display list, meaning you cannot have
   * a DOM Element, then a Sprite, then another DOM Element behind it.
   *
   * They also cannot be enabled for input. To do that, you have to use the `addListener` method to add native event
   * listeners directly. The final limitation is to do with cameras. The DOM Container is sized to match the game canvas
   * entirely and clipped accordingly. DOM Elements respect camera scrolling and scrollFactor settings, but if you
   * change the size of the camera so it no longer matches the size of the canvas, they won't be clipped accordingly.
   *
   * Also, all DOM Elements are inserted into the same DOM Container, regardless of which Scene they are created in.
   *
   * Note that you should only have DOM Elements in a Scene with a _single_ Camera. If you require multiple cameras,
   * use parallel scenes to achieve this.
   *
   * DOM Elements are a powerful way to align native HTML with your Phaser Game Objects. For example, you can insert
   * a login form for a multiplayer game directly into your title screen. Or a text input box for a highscore table.
   * Or a banner ad from a 3rd party service. Or perhaps you'd like to use them for high resolution text display and
   * UI. The choice is up to you, just remember that you're dealing with standard HTML and CSS floating over the top
   * of your game, and should treat it accordingly.
   */
  class DOMElement extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.AlphaSingle, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this DOM Element in the world. Default 0.
     * @param y The vertical position of this DOM Element in the world. Default 0.
     * @param element An existing DOM element, or a string. If a string starting with a # it will do a `getElementById` look-up on the string (minus the hash). Without a hash, it represents the type of element to create, i.e. 'div'.
     * @param style If a string, will be set directly as the elements `style` property value. If a plain object, will be iterated and the values transferred. In both cases the values replacing whatever CSS styles may have been previously set.
     * @param innerText If given, will be set directly as the elements `innerText` property value, replacing whatever was there before.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, element?: Element | string, style?: string | any, innerText?: string);

    /**
     * A reference to the parent DOM Container that the Game instance created when it started.
     */
    parent: Element;

    /**
     * A reference to the HTML Cache.
     */
    cache: Phaser.Cache.BaseCache;

    /**
     * The actual DOM Element that this Game Object is bound to. For example, if you've created a `<div>`
     * then this property is a direct reference to that element within the dom.
     */
    node: Element;

    /**
     * By default a DOM Element will have its transform, display, opacity, zIndex and blend mode properties
     * updated when its rendered. If, for some reason, you don't want any of these changed other than the
     * CSS transform, then set this flag to `true`. When `true` only the CSS Transform is applied and it's
     * up to you to keep track of and set the other properties as required.
     *
     * This can be handy if, for example, you've a nested DOM Element and you don't want the opacity to be
     * picked-up by any of its children.
     */
    transformOnly: boolean;

    /**
     * The angle, in radians, by which to skew the DOM Element on the horizontal axis.
     *
     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform
     */
    skewX: number;

    /**
     * The angle, in radians, by which to skew the DOM Element on the vertical axis.
     *
     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform
     */
    skewY: number;

    /**
     * A Vector4 that contains the 3D rotation of this DOM Element around a fixed axis in 3D space.
     *
     * All values in the Vector4 are treated as degrees, unless the `rotate3dAngle` property is changed.
     *
     * For more details see the following MDN page:
     *
     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d
     */
    rotate3d: Phaser.Math.Vector4;

    /**
     * The unit that represents the 3D rotation values. By default this is `deg` for degrees, but can
     * be changed to any supported unit. See this page for further details:
     *
     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d
     */
    rotate3dAngle: string;

    /**
     * Sets the CSS `pointerEvents` attribute on the DOM Element during rendering.
     *
     * This is 'auto' by default. Changing it may have unintended side-effects with
     * internal Phaser input handling, such as dragging, so only change this if you
     * understand the implications.
     */
    pointerEvents: string;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * For a DOM Element this property is read-only.
     *
     * The property `displayWidth` holds the computed bounds of this DOM Element, factoring in scaling.
     */
    readonly width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * For a DOM Element this property is read-only.
     *
     * The property `displayHeight` holds the computed bounds of this DOM Element, factoring in scaling.
     */
    readonly height: number;

    /**
     * The computed display width of this Game Object, based on the `getBoundingClientRect` DOM call.
     *
     * The property `width` holds the un-scaled width of this DOM Element.
     */
    readonly displayWidth: number;

    /**
     * The computed display height of this Game Object, based on the `getBoundingClientRect` DOM call.
     *
     * The property `height` holds the un-scaled height of this DOM Element.
     */
    readonly displayHeight: number;

    /**
     * Sets the horizontal and vertical skew values of this DOM Element.
     *
     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/transform
     * @param x The angle, in radians, by which to skew the DOM Element on the horizontal axis. Default 0.
     * @param y The angle, in radians, by which to skew the DOM Element on the vertical axis. Default x.
     */
    setSkew(x?: number, y?: number): this;

    /**
     * Sets the perspective CSS property of the _parent DOM Container_. This determines the distance between the z=0
     * plane and the user in order to give a 3D-positioned element some perspective. Each 3D element with
     * z > 0 becomes larger; each 3D-element with z < 0 becomes smaller. The strength of the effect is determined
     * by the value of this property.
     *
     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/perspective
     *
     * **Changing this value changes it globally for all DOM Elements, as they all share the same parent container.**
     * @param value The perspective value, in pixels, that determines the distance between the z plane and the user.
     */
    setPerspective(value: number): this;

    /**
     * The perspective CSS property value of the _parent DOM Container_. This determines the distance between the z=0
     * plane and the user in order to give a 3D-positioned element some perspective. Each 3D element with
     * z > 0 becomes larger; each 3D-element with z < 0 becomes smaller. The strength of the effect is determined
     * by the value of this property.
     *
     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/perspective
     *
     * **Changing this value changes it globally for all DOM Elements, as they all share the same parent container.**
     */
    perspective: number;

    /**
     * Adds one or more native DOM event listeners onto the underlying Element of this Game Object.
     * The event is then dispatched via this Game Objects standard event emitter.
     *
     * For example:
     *
     * ```javascript
     * var div = this.add.dom(x, y, element);
     *
     * div.addListener('click');
     *
     * div.on('click', handler);
     * ```
     * @param events The DOM event/s to listen for. You can specify multiple events by separating them with spaces.
     */
    addListener(events: string): this;

    /**
     * Removes one or more native DOM event listeners from the underlying Element of this Game Object.
     * @param events The DOM event/s to stop listening for. You can specify multiple events by separating them with spaces.
     */
    removeListener(events: string): this;

    /**
     * Creates a native DOM Element, adds it to the parent DOM Container and then binds it to this Game Object,
     * so you can control it. The `tagName` should be a string and is passed to `document.createElement`:
     *
     * ```javascript
     * this.add.dom().createElement('div');
     * ```
     *
     * For more details on acceptable tag names see: https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
     *
     * You can also pass in a DOMString or style object to set the CSS on the created element, and an optional `innerText`
     * value as well. Here is an example of a DOMString:
     *
     * ```javascript
     * this.add.dom().createElement('div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');
     * ```
     *
     * And using a style object:
     *
     * ```javascript
     * var style = {
     *   'background-color': 'lime';
     *   'width': '200px';
     *   'height': '100px';
     *   'font': '48px Arial';
     * };
     *
     * this.add.dom().createElement('div', style, 'Phaser');
     * ```
     *
     * If this Game Object already has an Element, it is removed from the DOM entirely first.
     * Any event listeners you may have previously created will need to be re-created after this call.
     * @param tagName A string that specifies the type of element to be created. The nodeName of the created element is initialized with the value of tagName. Don't use qualified names (like "html:a") with this method.
     * @param style Either a DOMString that holds the CSS styles to be applied to the created element, or an object the styles will be ready from.
     * @param innerText A DOMString that holds the text that will be set as the innerText of the created element.
     */
    createElement(tagName: string, style?: string | any, innerText?: string): this;

    /**
     * Binds a new DOM Element to this Game Object. If this Game Object already has an Element it is removed from the DOM
     * entirely first. Any event listeners you may have previously created will need to be re-created on the new element.
     *
     * The `element` argument you pass to this method can be either a string tagName:
     *
     * ```javascript
     * <h1 id="heading">Phaser</h1>
     *
     * this.add.dom().setElement('heading');
     * ```
     *
     * Or a reference to an Element instance:
     *
     * ```javascript
     * <h1 id="heading">Phaser</h1>
     *
     * var h1 = document.getElementById('heading');
     *
     * this.add.dom().setElement(h1);
     * ```
     *
     * You can also pass in a DOMString or style object to set the CSS on the created element, and an optional `innerText`
     * value as well. Here is an example of a DOMString:
     *
     * ```javascript
     * this.add.dom().setElement(h1, 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');
     * ```
     *
     * And using a style object:
     *
     * ```javascript
     * var style = {
     *   'background-color': 'lime';
     *   'width': '200px';
     *   'height': '100px';
     *   'font': '48px Arial';
     * };
     *
     * this.add.dom().setElement(h1, style, 'Phaser');
     * ```
     * @param element If a string it is passed to `getElementById()`, or it should be a reference to an existing Element.
     * @param style Either a DOMString that holds the CSS styles to be applied to the created element, or an object the styles will be ready from.
     * @param innerText A DOMString that holds the text that will be set as the innerText of the created element.
     */
    setElement(element: string | Element, style?: string | any, innerText?: string): this;

    /**
     * Takes a block of html from the HTML Cache, that has previously been preloaded into the game, and then
     * creates a DOM Element from it. The loaded HTML is set as the `innerHTML` property of the created
     * element.
     *
     * Assume the following html is stored in a file called `loginform.html`:
     *
     * ```html
     * <input type="text" name="nameField" placeholder="Enter your name" style="font-size: 32px">
     * <input type="button" name="playButton" value="Let's Play" style="font-size: 32px">
     * ```
     *
     * Which is loaded into your game using the cache key 'login':
     *
     * ```javascript
     * this.load.html('login', 'assets/loginform.html');
     * ```
     *
     * You can create a DOM Element from it using the cache key:
     *
     * ```javascript
     * this.add.dom().createFromCache('login');
     * ```
     *
     * The optional `elementType` argument controls the container that is created, into which the loaded html is inserted.
     * The default is a plain `div` object, but any valid tagName can be given.
     *
     * If this Game Object already has an Element, it is removed from the DOM entirely first.
     * Any event listeners you may have previously created will need to be re-created after this call.
     * @param The key of the html cache entry to use for this DOM Element.
     * @param tagName The tag name of the element into which all of the loaded html will be inserted. Defaults to a plain div tag. Default 'div'.
     */
    createFromCache(The: string, tagName?: string): this;

    /**
     * Takes a string of html and then creates a DOM Element from it. The HTML is set as the `innerHTML`
     * property of the created element.
     *
     * ```javascript
     * let form = `
     * <input type="text" name="nameField" placeholder="Enter your name" style="font-size: 32px">
     * <input type="button" name="playButton" value="Let's Play" style="font-size: 32px">
     * `;
     * ```
     *
     * You can create a DOM Element from it using the string:
     *
     * ```javascript
     * this.add.dom().createFromHTML(form);
     * ```
     *
     * The optional `elementType` argument controls the type of container that is created, into which the html is inserted.
     * The default is a plain `div` object, but any valid tagName can be given.
     *
     * If this Game Object already has an Element, it is removed from the DOM entirely first.
     * Any event listeners you may have previously created will need to be re-created after this call.
     * @param html A string of html to be set as the `innerHTML` property of the created element.
     * @param tagName The tag name of the element into which all of the html will be inserted. Defaults to a plain div tag. Default 'div'.
     */
    createFromHTML(html: string, tagName?: string): this;

    /**
     * Removes the current DOM Element bound to this Game Object from the DOM entirely and resets the
     * `node` property of this Game Object to be `null`.
     */
    removeElement(): this;

    /**
     * Internal method that calls `getBoundingClientRect` on the `node` and then sets the bounds width
     * and height into the `displayWidth` and `displayHeight` properties, and the `clientWidth` and `clientHeight`
     * values into the `width` and `height` properties respectively.
     *
     * This is called automatically whenever a new element is created or set.
     */
    updateSize(): this;

    /**
     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through
     * them, looking for the first one that has a property matching the given key and value. It then returns this child
     * if found, or `null` if not.
     * @param property The property to search the children for.
     * @param value The value the property must strictly equal.
     */
    getChildByProperty(property: string, value: string): Element;

    /**
     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through
     * them, looking for the first one that has a matching id. It then returns this child if found, or `null` if not.
     *
     * Be aware that class and id names are case-sensitive.
     * @param id The id to search the children for.
     */
    getChildByID(id: string): Element;

    /**
     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through
     * them, looking for the first one that has a matching name. It then returns this child if found, or `null` if not.
     *
     * Be aware that class and id names are case-sensitive.
     * @param name The name to search the children for.
     */
    getChildByName(name: string): Element;

    /**
     * Sets the `className` property of the DOM Element node and updates the internal sizes.
     * @param className A string representing the class or space-separated classes of the element.
     */
    setClassName(className: string): this;

    /**
     * Sets the `innerText` property of the DOM Element node and updates the internal sizes.
     *
     * Note that only certain types of Elements can have `innerText` set on them.
     * @param text A DOMString representing the rendered text content of the element.
     */
    setText(text: string): this;

    /**
     * Sets the `innerHTML` property of the DOM Element node and updates the internal sizes.
     * @param html A DOMString of html to be set as the `innerHTML` property of the element.
     */
    setHTML(html: string): this;

    /**
     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
     *
     * DOMElements always return `true` as they need to still set values during the render pass, even if not visible.
     */
    willRender(): boolean;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  namespace Events {
    /**
     * The Game Object Added to Scene Event.
     *
     * This event is dispatched when a Game Object is added to a Scene.
     *
     * Listen for it on a Game Object instance using `GameObject.on('addedtoscene', listener)`.
     */
    const ADDED_TO_SCENE: any;

    /**
     * The Game Object Destroy Event.
     *
     * This event is dispatched when a Game Object instance is being destroyed.
     *
     * Listen for it on a Game Object instance using `GameObject.on('destroy', listener)`.
     */
    const DESTROY: any;

    /**
     * The Game Object Removed from Scene Event.
     *
     * This event is dispatched when a Game Object is removed from a Scene.
     *
     * Listen for it on a Game Object instance using `GameObject.on('removedfromscene', listener)`.
     */
    const REMOVED_FROM_SCENE: any;

    /**
     * The Video Game Object Complete Event.
     *
     * This event is dispatched when a Video finishes playback by reaching the end of its duration. It
     * is also dispatched if a video marker sequence is being played and reaches the end.
     *
     * Note that not all videos can fire this event. Live streams, for example, have no fixed duration,
     * so never technically 'complete'.
     *
     * If a video is stopped from playback, via the `Video.stop` method, it will emit the
     * `VIDEO_STOP` event instead of this one.
     *
     * Listen for it from a Video Game Object instance using `Video.on('complete', listener)`.
     */
    const VIDEO_COMPLETE: any;

    /**
     * The Video Game Object Created Event.
     *
     * This event is dispatched when the texture for a Video has been created. This happens
     * when enough of the video source has been loaded that the browser is able to render a
     * frame from it.
     *
     * Listen for it from a Video Game Object instance using `Video.on('created', listener)`.
     */
    const VIDEO_CREATED: any;

    /**
     * The Video Game Object Error Event.
     *
     * This event is dispatched when a Video tries to play a source that does not exist, or is the wrong file type.
     *
     * Listen for it from a Video Game Object instance using `Video.on('error', listener)`.
     */
    const VIDEO_ERROR: any;

    /**
     * The Video Game Object Loop Event.
     *
     * This event is dispatched when a Video that is currently playing has looped. This only
     * happens if the `loop` parameter was specified, or the `setLoop` method was called,
     * and if the video has a fixed duration. Video streams, for example, cannot loop, as
     * they have no duration.
     *
     * Looping is based on the result of the Video `timeupdate` event. This event is not
     * frame-accurate, due to the way browsers work, so please do not rely on this loop
     * event to be time or frame precise.
     *
     * Listen for it from a Video Game Object instance using `Video.on('loop', listener)`.
     */
    const VIDEO_LOOP: any;

    /**
     * The Video Game Object Play Event.
     *
     * This event is dispatched when a Video begins playback. For videos that do not require
     * interaction unlocking, this is usually as soon as the `Video.play` method is called.
     * However, for videos that require unlocking, it is fired once playback begins after
     * they've been unlocked.
     *
     * Listen for it from a Video Game Object instance using `Video.on('play', listener)`.
     */
    const VIDEO_PLAY: any;

    /**
     * The Video Game Object Seeked Event.
     *
     * This event is dispatched when a Video completes seeking to a new point in its timeline.
     *
     * Listen for it from a Video Game Object instance using `Video.on('seeked', listener)`.
     */
    const VIDEO_SEEKED: any;

    /**
     * The Video Game Object Seeking Event.
     *
     * This event is dispatched when a Video _begins_ seeking to a new point in its timeline.
     * When the seek is complete, it will dispatch the `VIDEO_SEEKED` event to conclude.
     *
     * Listen for it from a Video Game Object instance using `Video.on('seeking', listener)`.
     */
    const VIDEO_SEEKING: any;

    /**
     * The Video Game Object Stopped Event.
     *
     * This event is dispatched when a Video is stopped from playback via a call to the `Video.stop` method,
     * either directly via game code, or indirectly as the result of changing a video source or destroying it.
     *
     * Listen for it from a Video Game Object instance using `Video.on('stop', listener)`.
     */
    const VIDEO_STOP: any;

    /**
     * The Video Game Object Timeout Event.
     *
     * This event is dispatched when a Video has exhausted its allocated time while trying to connect to a video
     * source to start playback.
     *
     * Listen for it from a Video Game Object instance using `Video.on('timeout', listener)`.
     */
    const VIDEO_TIMEOUT: any;

    /**
     * The Video Game Object Unlocked Event.
     *
     * This event is dispatched when a Video that was prevented from playback due to the browsers
     * Media Engagement Interaction policy, is unlocked by a user gesture.
     *
     * Listen for it from a Video Game Object instance using `Video.on('unlocked', listener)`.
     */
    const VIDEO_UNLOCKED: any;

  }

  /**
   * An Extern Game Object is a special type of Game Object that allows you to pass
   * rendering off to a 3rd party.
   *
   * When you create an Extern and place it in the display list of a Scene, the renderer will
   * process the list as usual. When it finds an Extern it will flush the current batch,
   * clear down the pipeline and prepare a transform matrix which your render function can
   * take advantage of, if required.
   *
   * The WebGL context is then left in a 'clean' state, ready for you to bind your own shaders,
   * or draw to it, whatever you wish to do. This should all take place in the `render` method.
   * The correct way to deploy an Extern object is to create a class that extends it, then
   * override the `render` (and optionally `preUpdate`) methods and pass off control to your
   * 3rd party libraries or custom WebGL code there.
   *
   * Once you've finished, you should free-up any of your resources.
   * The Extern will then rebind the Phaser pipeline and carry on rendering the display list.
   *
   * Although this object has lots of properties such as Alpha, Blend Mode and Tint, none of
   * them are used during rendering unless you take advantage of them in your own render code.
   */
  class Extern extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     */
    constructor(scene: Phaser.Scene);

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The horizontally flipped state of the Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipX: boolean;

    /**
     * The vertically flipped state of the Game Object.
     *
     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipY: boolean;

    /**
     * Toggles the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    toggleFlipX(): this;

    /**
     * Toggles the vertical flipped state of this Game Object.
     */
    toggleFlipY(): this;

    /**
     * Sets the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipX(value: boolean): this;

    /**
     * Sets the vertical flipped state of this Game Object.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipY(value: boolean): this;

    /**
     * Sets the horizontal and vertical flipped state of this Game Object.
     *
     * A Game Object that is flipped will render inversed on the flipped axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlip(x: boolean, y: boolean): this;

    /**
     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
     */
    resetFlip(): this;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the size of this Game Object to be that of the given Frame.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param frame The frame to base the size of this Game Object on.
     */
    setSizeToFrame(frame: Phaser.Textures.Frame): this;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager, or a Texture instance.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string | Phaser.Textures.Texture, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     * @param frame The name or index of the frame within the Texture.
     * @param updateSize Should this call adjust the size of the Game Object? Default true.
     * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
     */
    setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;

    /**
     * The tint value being applied to the top-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopLeft: number;

    /**
     * The tint value being applied to the top-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopRight: number;

    /**
     * The tint value being applied to the bottom-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomLeft: number;

    /**
     * The tint value being applied to the bottom-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomRight: number;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * Clears all tint values associated with this Game Object.
     *
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     */
    clearTint(): this;

    /**
     * Sets an additive tint on this Game Object.
     *
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a fill-based tint on this Game Object.
     *
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     */
    tint: number;

    /**
     * Does this Game Object have a tint applied?
     *
     * It checks to see if the 4 tint properties are set to the value 0xffffff
     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
     */
    readonly isTinted: boolean;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The base class that all Game Objects extend.
   * You don't create GameObjects directly and they cannot be added to the display list.
   * Instead, use them as the base for your own custom classes.
   */
  class GameObject extends Phaser.Events.EventEmitter {
    /**
     *
     * @param scene The Scene to which this Game Object belongs.
     * @param type A textual representation of the type of Game Object, i.e. `sprite`.
     */
    constructor(scene: Phaser.Scene, type: string);

    /**
     * A reference to the Scene to which this Game Object belongs.
     *
     * Game Objects can only belong to one Scene.
     *
     * You should consider this property as being read-only. You cannot move a
     * Game Object to another Scene by simply changing it.
     */
    scene: Phaser.Scene;

    /**
     * Holds a reference to the Display List that contains this Game Object.
     *
     * This is set automatically when this Game Object is added to a Scene or Layer.
     *
     * You should treat this property as being read-only.
     */
    displayList: Phaser.GameObjects.DisplayList | Phaser.GameObjects.Layer;

    /**
     * A textual representation of this Game Object, i.e. `sprite`.
     * Used internally by Phaser but is available for your own custom classes to populate.
     */
    type: string;

    /**
     * The current state of this Game Object.
     *
     * Phaser itself will never modify this value, although plugins may do so.
     *
     * Use this property to track the state of a Game Object during its lifetime. For example, it could change from
     * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant
     * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.
     * If you need to store complex data about your Game Object, look at using the Data Component instead.
     */
    state: number | string;

    /**
     * The parent Container of this Game Object, if it has one.
     */
    parentContainer: Phaser.GameObjects.Container;

    /**
     * The name of this Game Object.
     * Empty by default and never populated by Phaser, this is left for developers to use.
     */
    name: string;

    /**
     * The active state of this Game Object.
     * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.
     * An active object is one which is having its logic and internal systems updated.
     */
    active: boolean;

    /**
     * The Tab Index of the Game Object.
     * Reserved for future use by plugins and the Input Manager.
     */
    tabIndex: number;

    /**
     * A Data Manager.
     * It allows you to store, query and get key/value paired information specific to this Game Object.
     * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.
     */
    data: Phaser.Data.DataManager;

    /**
     * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.
     * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.
     * If those components are not used by your custom class then you can use this bitmask as you wish.
     */
    renderFlags: number;

    /**
     * A bitmask that controls if this Game Object is drawn by a Camera or not.
     * Not usually set directly, instead call `Camera.ignore`, however you can
     * set this property directly using the Camera.id property:
     */
    cameraFilter: number;

    /**
     * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.
     * Not usually set directly. Instead call `GameObject.setInteractive()`.
     */
    input: Phaser.Types.Input.InteractiveObject;

    /**
     * If this Game Object is enabled for Arcade or Matter Physics then this property will contain a reference to a Physics Body.
     */
    body: Phaser.Physics.Arcade.Body | Phaser.Physics.Arcade.StaticBody | MatterJS.BodyType;

    /**
     * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.
     * This includes calls that may come from a Group, Container or the Scene itself.
     * While it allows you to persist a Game Object across Scenes, please understand you are entirely
     * responsible for managing references to and from this Game Object.
     */
    ignoreDestroy: boolean;

    /**
     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.
     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.
     * @param value True if this Game Object should be set as active, false if not.
     */
    setActive(value: boolean): this;

    /**
     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.
     * The `name` property is not populated by Phaser and is presented for your own use.
     * @param value The name to be given to this Game Object.
     */
    setName(value: string): this;

    /**
     * Sets the current state of this Game Object.
     *
     * Phaser itself will never modify the State of a Game Object, although plugins may do so.
     *
     * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.
     * The state value should typically be an integer (ideally mapped to a constant
     * in your game code), but could also be a string. It is recommended to keep it light and simple.
     * If you need to store complex data about your Game Object, look at using the Data Component instead.
     * @param value The state of the Game Object.
     */
    setState(value: number | string): this;

    /**
     * Adds a Data Manager component to this Game Object.
     */
    setDataEnabled(): this;

    /**
     * Allows you to store a key value pair within this Game Objects Data Manager.
     *
     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled
     * before setting the value.
     *
     * If the key doesn't already exist in the Data Manager then it is created.
     *
     * ```javascript
     * sprite.setData('name', 'Red Gem Stone');
     * ```
     *
     * You can also pass in an object of key value pairs as the first argument:
     *
     * ```javascript
     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });
     * ```
     *
     * To get a value back again you can call `getData`:
     *
     * ```javascript
     * sprite.getData('gold');
     * ```
     *
     * Or you can access the value directly via the `values` property, where it works like any other variable:
     *
     * ```javascript
     * sprite.data.values.gold += 50;
     * ```
     *
     * When the value is first set, a `setdata` event is emitted from this Game Object.
     *
     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.
     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.
     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.
     *
     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.
     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.
     * @param key The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.
     * @param data The value to set for the given key. If an object is provided as the key this argument is ignored.
     */
    setData(key: string | object, data?: any): this;

    /**
     * Increase a value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is increased from 0.
     *
     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled
     * before setting the value.
     *
     * If the key doesn't already exist in the Data Manager then it is created.
     *
     * When the value is first set, a `setdata` event is emitted from this Game Object.
     * @param key The key to increase the value for.
     * @param data The value to increase for the given key.
     */
    incData(key: string | object, data?: any): this;

    /**
     * Toggle a boolean value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is toggled from false.
     *
     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled
     * before setting the value.
     *
     * If the key doesn't already exist in the Data Manager then it is created.
     *
     * When the value is first set, a `setdata` event is emitted from this Game Object.
     * @param key The key to toggle the value for.
     */
    toggleData(key: string | object): this;

    /**
     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.
     *
     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:
     *
     * ```javascript
     * sprite.getData('gold');
     * ```
     *
     * Or access the value directly:
     *
     * ```javascript
     * sprite.data.values.gold;
     * ```
     *
     * You can also pass in an array of keys, in which case an array of values will be returned:
     *
     * ```javascript
     * sprite.getData([ 'gold', 'armor', 'health' ]);
     * ```
     *
     * This approach is useful for destructuring arrays in ES6.
     * @param key The key of the value to retrieve, or an array of keys.
     */
    getData(key: string | string[]): any;

    /**
     * Pass this Game Object to the Input Manager to enable it for Input.
     *
     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area
     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced
     * input detection.
     *
     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If
     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific
     * shape for it to use.
     *
     * You can also provide an Input Configuration Object as the only argument to this method.
     * @param hitArea Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not given it will try to create a Rectangle based on the texture frame.
     * @param callback The callback that determines if the pointer is within the Hit Area shape or not. If you provide a shape you must also provide a callback.
     * @param dropZone Should this Game Object be treated as a drop zone target? Default false.
     */
    setInteractive(hitArea?: Phaser.Types.Input.InputConfiguration | any, callback?: Phaser.Types.Input.HitAreaCallback, dropZone?: boolean): this;

    /**
     * If this Game Object has previously been enabled for input, this will disable it.
     *
     * An object that is disabled for input stops processing or being considered for
     * input events, but can be turned back on again at any time by simply calling
     * `setInteractive()` with no arguments provided.
     *
     * If want to completely remove interaction from this Game Object then use `removeInteractive` instead.
     */
    disableInteractive(): this;

    /**
     * If this Game Object has previously been enabled for input, this will queue it
     * for removal, causing it to no longer be interactive. The removal happens on
     * the next game step, it is not immediate.
     *
     * The Interactive Object that was assigned to this Game Object will be destroyed,
     * removed from the Input Manager and cleared from this Game Object.
     *
     * If you wish to re-enable this Game Object at a later date you will need to
     * re-create its InteractiveObject by calling `setInteractive` again.
     *
     * If you wish to only temporarily stop an object from receiving input then use
     * `disableInteractive` instead, as that toggles the interactive state, where-as
     * this erases it completely.
     *
     * If you wish to resize a hit area, don't remove and then set it as being
     * interactive. Instead, access the hitarea object directly and resize the shape
     * being used. I.e.: `sprite.input.hitArea.setSize(width, height)` (assuming the
     * shape is a Rectangle, which it is by default.)
     */
    removeInteractive(): this;

    /**
     * This callback is invoked when this Game Object is added to a Scene.
     *
     * Can be overriden by custom Game Objects, but be aware of some Game Objects that
     * will use this, such as Sprites, to add themselves into the Update List.
     *
     * You can also listen for the `ADDED_TO_SCENE` event from this Game Object.
     */
    addedToScene(): void;

    /**
     * This callback is invoked when this Game Object is removed from a Scene.
     *
     * Can be overriden by custom Game Objects, but be aware of some Game Objects that
     * will use this, such as Sprites, to removed themselves from the Update List.
     *
     * You can also listen for the `REMOVED_FROM_SCENE` event from this Game Object.
     */
    removedFromScene(): void;

    /**
     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.
     * @param args args
     */
    update(...args: any[]): void;

    /**
     * Returns a JSON representation of the Game Object.
     */
    toJSON(): Phaser.Types.GameObjects.JSONGameObject;

    /**
     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
     * Also checks the Game Object against the given Cameras exclusion list.
     * @param camera The Camera to check against this Game Object.
     */
    willRender(camera: Phaser.Cameras.Scene2D.Camera): boolean;

    /**
     * Returns an array containing the display list index of either this Game Object, or if it has one,
     * its parent Container. It then iterates up through all of the parent containers until it hits the
     * root of the display list (which is index 0 in the returned array).
     *
     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of
     * this Game Object and all of its ancestors.
     */
    getIndexList(): number[];

    /**
     * Adds this Game Object to the given Display List.
     *
     * If no Display List is specified, it will default to the Display List owned by the Scene to which
     * this Game Object belongs.
     *
     * A Game Object can only exist on one Display List at any given time, but may move freely between them.
     *
     * If this Game Object is already on another Display List when this method is called, it will first
     * be removed from it, before being added to the new list.
     *
     * You can query which list it is on by looking at the `Phaser.GameObjects.GameObject#displayList` property.
     *
     * If a Game Object isn't on any display list, it will not be rendered. If you just wish to temporarly
     * disable it from rendering, consider using the `setVisible` method, instead.
     * @param displayList The Display List to add to. Defaults to the Scene Display List.
     */
    addToDisplayList(displayList?: Phaser.GameObjects.DisplayList | Phaser.GameObjects.Layer): this;

    /**
     * Adds this Game Object to the Update List belonging to the Scene.
     *
     * When a Game Object is added to the Update List it will have its `preUpdate` method called
     * every game frame. This method is passed two parameters: `delta` and `time`.
     *
     * If you wish to run your own logic within `preUpdate` then you should always call
     * `preUpdate.super(delta, time)` within it, or it may fail to process required operations,
     * such as Sprite animations.
     */
    addToUpdateList(): this;

    /**
     * Removes this Game Object from the Display List it is currently on.
     *
     * A Game Object can only exist on one Display List at any given time, but may move freely removed
     * and added back at a later stage.
     *
     * You can query which list it is on by looking at the `Phaser.GameObjects.GameObject#displayList` property.
     *
     * If a Game Object isn't on any Display List, it will not be rendered. If you just wish to temporarly
     * disable it from rendering, consider using the `setVisible` method, instead.
     */
    removeFromDisplayList(): this;

    /**
     * Removes this Game Object from the Scene's Update List.
     *
     * When a Game Object is on the Update List, it will have its `preUpdate` method called
     * every game frame. Calling this method will remove it from the list, preventing this.
     *
     * Removing a Game Object from the Update List will stop most internal functions working.
     * For example, removing a Sprite from the Update List will prevent it from being able to
     * run animations.
     */
    removeFromUpdateList(): this;

    /**
     * Destroys this Game Object removing it from the Display List and Update List and
     * severing all ties to parent resources.
     *
     * Also removes itself from the Input Manager and Physics Manager if previously enabled.
     *
     * Use this to remove a Game Object from your game if you don't ever plan to use it again.
     * As long as no reference to it exists within your own code it should become free for
     * garbage collection by the browser.
     *
     * If you just want to temporarily disable an object then look at using the
     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.
     * @param fromScene `True` if this Game Object is being destroyed by the Scene, `false` if not. Default false.
     */
    destroy(fromScene?: boolean): void;

    /**
     * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.
     */
    static readonly RENDER_MASK: number;

  }

  /**
   * The Game Object Creator is a Scene plugin that allows you to quickly create many common
   * types of Game Objects and return them. Unlike the Game Object Factory, they are not automatically
   * added to the Scene.
   *
   * Game Objects directly register themselves with the Creator and inject their own creation
   * methods into the class.
   */
  class GameObjectCreator {
    /**
     *
     * @param scene The Scene to which this Game Object Factory belongs.
     */
    constructor(scene: Phaser.Scene);

    /**
     * Creates a new Dynamic Bitmap Text Game Object and returns it.
     *
     * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    dynamicBitmapText(config: Phaser.Types.GameObjects.BitmapText.BitmapTextConfig, addToScene?: boolean): Phaser.GameObjects.DynamicBitmapText;

    /**
     * Creates a new Bitmap Text Game Object and returns it.
     *
     * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    bitmapText(config: Phaser.Types.GameObjects.BitmapText.BitmapTextConfig, addToScene?: boolean): Phaser.GameObjects.BitmapText;

    /**
     * Creates a new Blitter Game Object and returns it.
     *
     * Note: This method will only be available if the Blitter Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    blitter(config: object, addToScene?: boolean): Phaser.GameObjects.Blitter;

    /**
     * Creates a new Container Game Object and returns it.
     *
     * Note: This method will only be available if the Container Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    container(config: object, addToScene?: boolean): Phaser.GameObjects.Container;

    /**
     * The Scene to which this Game Object Creator belongs.
     */
    protected scene: Phaser.Scene;

    /**
     * A reference to the Scene.Systems.
     */
    protected systems: Phaser.Scenes.Systems;

    /**
     * A reference to the Scene Event Emitter.
     */
    protected events: Phaser.Events.EventEmitter;

    /**
     * A reference to the Scene Display List.
     */
    protected displayList: Phaser.GameObjects.DisplayList;

    /**
     * A reference to the Scene Update List.
     */
    protected updateList: Phaser.GameObjects.UpdateList;

    /**
     * Static method called directly by the Game Object creator functions.
     * With this method you can register a custom GameObject factory in the GameObjectCreator,
     * providing a name (`factoryType`) and the constructor (`factoryFunction`) in order
     * to be called when you invoke Phaser.Scene.make[ factoryType ] method.
     * @param factoryType The key of the factory that you will use to call to Phaser.Scene.make[ factoryType ] method.
     * @param factoryFunction The constructor function to be called when you invoke to the Phaser.Scene.make method.
     */
    static register(factoryType: string, factoryFunction: Function): void;

    /**
     * Static method called directly by the Game Object Creator functions.
     *
     * With this method you can remove a custom Game Object Creator that has been previously
     * registered in the Game Object Creator. Pass in its `factoryType` in order to remove it.
     * @param factoryType The key of the factory that you want to remove from the GameObjectCreator.
     */
    static remove(factoryType: string): void;

    /**
     * Creates a new Graphics Game Object and returns it.
     *
     * Note: This method will only be available if the Graphics Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    graphics(config: object, addToScene?: boolean): Phaser.GameObjects.Graphics;

    /**
     * Creates a new Group Game Object and returns it.
     *
     * Note: This method will only be available if the Group Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     */
    group(config: Phaser.Types.GameObjects.Group.GroupConfig | Phaser.Types.GameObjects.Group.GroupCreateConfig): Phaser.GameObjects.Group;

    /**
     * Creates a new Image Game Object and returns it.
     *
     * Note: This method will only be available if the Image Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    image(config: object, addToScene?: boolean): Phaser.GameObjects.Image;

    /**
     * Creates a new Layer Game Object and returns it.
     *
     * Note: This method will only be available if the Layer Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    layer(config: object, addToScene?: boolean): Phaser.GameObjects.Layer;

    /**
     * Creates a new Mesh Game Object and returns it.
     *
     * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    mesh(config: object, addToScene?: boolean): Phaser.GameObjects.Mesh;

    /**
     * Creates a new Particle Emitter Manager Game Object and returns it.
     *
     * Note: This method will only be available if the Particles Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    particles(config: object, addToScene?: boolean): Phaser.GameObjects.Particles.ParticleEmitterManager;

    /**
     * Creates a new Point Light Game Object and returns it.
     *
     * Note: This method will only be available if the Point Light Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    pointlight(config: object, addToScene?: boolean): Phaser.GameObjects.PointLight;

    /**
     * Creates a new Render Texture Game Object and returns it.
     *
     * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    renderTexture(config: Phaser.Types.GameObjects.RenderTexture.RenderTextureConfig, addToScene?: boolean): Phaser.GameObjects.RenderTexture;

    /**
     * Creates a new Rope Game Object and returns it.
     *
     * Note: This method will only be available if the Rope Game Object and WebGL support have been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    rope(config: object, addToScene?: boolean): Phaser.GameObjects.Rope;

    /**
     * Creates a new Shader Game Object and returns it.
     *
     * Note: This method will only be available if the Shader Game Object and WebGL support have been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    shader(config: object, addToScene?: boolean): Phaser.GameObjects.Shader;

    /**
     * Creates a new Sprite Game Object and returns it.
     *
     * Note: This method will only be available if the Sprite Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    sprite(config: Phaser.Types.GameObjects.Sprite.SpriteConfig, addToScene?: boolean): Phaser.GameObjects.Sprite;

    /**
     * Creates a new Text Game Object and returns it.
     *
     * Note: This method will only be available if the Text Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    text(config: Phaser.Types.GameObjects.Text.TextConfig, addToScene?: boolean): Phaser.GameObjects.Text;

    /**
     * Creates a new TileSprite Game Object and returns it.
     *
     * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    tileSprite(config: Phaser.Types.GameObjects.TileSprite.TileSpriteConfig, addToScene?: boolean): Phaser.GameObjects.TileSprite;

    /**
     * Creates a new Video Game Object and returns it.
     *
     * Note: This method will only be available if the Video Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
     */
    video(config: object, addToScene?: boolean): Phaser.GameObjects.Video;

    /**
     * Creates a new Zone Game Object and returns it.
     *
     * Note: This method will only be available if the Zone Game Object has been built into Phaser.
     * @param config The configuration object this Game Object will use to create itself.
     */
    zone(config: object): Phaser.GameObjects.Zone;

    /**
     * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.
     * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing
     * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map
     * data. For an empty map, you should specify tileWidth, tileHeight, width & height.
     * @param config The config options for the Tilemap.
     */
    tilemap(config?: Phaser.Types.Tilemaps.TilemapConfig): Phaser.Tilemaps.Tilemap;

    /**
     * Creates a new Tween object and returns it.
     *
     * Note: This method will only be available if Tweens have been built into Phaser.
     * @param config The Tween configuration.
     */
    tween(config: Phaser.Types.Tweens.TweenBuilderConfig | object): Phaser.Tweens.Tween;

  }

  /**
   * The Game Object Factory is a Scene plugin that allows you to quickly create many common
   * types of Game Objects and have them automatically registered with the Scene.
   *
   * Game Objects directly register themselves with the Factory and inject their own creation
   * methods into the class.
   */
  class GameObjectFactory {
    /**
     *
     * @param scene The Scene to which this Game Object Factory belongs.
     */
    constructor(scene: Phaser.Scene);

    /**
     * Creates a new Path Object.
     * @param x The horizontal position of this Path.
     * @param y The vertical position of this Path.
     */
    path(x: number, y: number): Phaser.Curves.Path;

    /**
     * Creates a new Dynamic Bitmap Text Game Object and adds it to the Scene.
     *
     * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
     *
     * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to
     * match the font structure.
     *
     * Dynamic Bitmap Text objects are different from Static Bitmap Text in that they invoke a callback for each
     * letter being rendered during the render pass. This callback allows you to manipulate the properties of
     * each letter being rendered, such as its position, scale or tint, allowing you to create interesting effects
     * like jiggling text, which can't be done with Static text. This means that Dynamic Text takes more processing
     * time, so only use them if you require the callback ability they have.
     *
     * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
     * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
     * processing the font texture in an image editor, applying fills and any other effects required.
     *
     * To create multi-line text insert \r, \n or \r\n escape codes into the text string.
     *
     * To create a BitmapText data files you need a 3rd party app such as:
     *
     * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
     * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
     * Littera (Web-based, free): http://kvazars.com/littera/
     *
     * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
     * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson
     *
     * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.
     * @param x The x position of the Game Object.
     * @param y The y position of the Game Object.
     * @param font The key of the font to use from the BitmapFont cache.
     * @param text The string, or array of strings, to be set as the content of this Bitmap Text.
     * @param size The font size to set.
     */
    dynamicBitmapText(x: number, y: number, font: string, text?: string | string[], size?: number): Phaser.GameObjects.DynamicBitmapText;

    /**
     * Creates a new Bitmap Text Game Object and adds it to the Scene.
     *
     * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
     *
     * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to
     * match the font structure.
     *
     * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
     * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
     * processing the font texture in an image editor, applying fills and any other effects required.
     *
     * To create multi-line text insert \r, \n or \r\n escape codes into the text string.
     *
     * To create a BitmapText data files you need a 3rd party app such as:
     *
     * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
     * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
     * Littera (Web-based, free): http://kvazars.com/littera/
     *
     * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
     * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson
     *
     * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.
     * @param x The x position of the Game Object.
     * @param y The y position of the Game Object.
     * @param font The key of the font to use from the BitmapFont cache.
     * @param text The string, or array of strings, to be set as the content of this Bitmap Text.
     * @param size The font size to set.
     * @param align The alignment of the text in a multi-line BitmapText object. Default 0.
     */
    bitmapText(x: number, y: number, font: string, text?: string | string[], size?: number, align?: number): Phaser.GameObjects.BitmapText;

    /**
     * Creates a new Blitter Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Blitter Game Object has been built into Phaser.
     * @param x The x position of the Game Object.
     * @param y The y position of the Game Object.
     * @param key The key of the Texture the Blitter object will use.
     * @param frame The default Frame children of the Blitter will use.
     */
    blitter(x: number, y: number, key: string, frame?: string | number): Phaser.GameObjects.Blitter;

    /**
     * Creates a new Container Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Container Game Object has been built into Phaser.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param children An optional array of Game Objects to add to this Container.
     */
    container(x?: number, y?: number, children?: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[]): Phaser.GameObjects.Container;

    /**
     * DOM Element Game Objects are a way to control and manipulate HTML Elements over the top of your game.
     *
     * In order for DOM Elements to display you have to enable them by adding the following to your game
     * configuration object:
     *
     * ```javascript
     * dom {
     *   createContainer: true
     * }
     * ```
     *
     * When this is added, Phaser will automatically create a DOM Container div that is positioned over the top
     * of the game canvas. This div is sized to match the canvas, and if the canvas size changes, as a result of
     * settings within the Scale Manager, the dom container is resized accordingly.
     *
     * You can create a DOM Element by either passing in DOMStrings, or by passing in a reference to an existing
     * Element that you wish to be placed under the control of Phaser. For example:
     *
     * ```javascript
     * this.add.dom(x, y, 'div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');
     * ```
     *
     * The above code will insert a div element into the DOM Container at the given x/y coordinate. The DOMString in
     * the 4th argument sets the initial CSS style of the div and the final argument is the inner text. In this case,
     * it will create a lime colored div that is 220px by 100px in size with the text Phaser in it, in an Arial font.
     *
     * You should nearly always, without exception, use explicitly sized HTML Elements, in order to fully control
     * alignment and positioning of the elements next to regular game content.
     *
     * Rather than specify the CSS and HTML directly you can use the `load.html` File Loader to load it into the
     * cache and then use the `createFromCache` method instead. You can also use `createFromHTML` and various other
     * methods available in this class to help construct your elements.
     *
     * Once the element has been created you can then control it like you would any other Game Object. You can set its
     * position, scale, rotation, alpha and other properties. It will move as the main Scene Camera moves and be clipped
     * at the edge of the canvas. It's important to remember some limitations of DOM Elements: The obvious one is that
     * they appear above or below your game canvas. You cannot blend them into the display list, meaning you cannot have
     * a DOM Element, then a Sprite, then another DOM Element behind it.
     *
     * They also cannot be enabled for input. To do that, you have to use the `addListener` method to add native event
     * listeners directly. The final limitation is to do with cameras. The DOM Container is sized to match the game canvas
     * entirely and clipped accordingly. DOM Elements respect camera scrolling and scrollFactor settings, but if you
     * change the size of the camera so it no longer matches the size of the canvas, they won't be clipped accordingly.
     *
     * Also, all DOM Elements are inserted into the same DOM Container, regardless of which Scene they are created in.
     *
     * DOM Elements are a powerful way to align native HTML with your Phaser Game Objects. For example, you can insert
     * a login form for a multiplayer game directly into your title screen. Or a text input box for a highscore table.
     * Or a banner ad from a 3rd party service. Or perhaps you'd like to use them for high resolution text display and
     * UI. The choice is up to you, just remember that you're dealing with standard HTML and CSS floating over the top
     * of your game, and should treat it accordingly.
     *
     * Note: This method will only be available if the DOM Element Game Object has been built into Phaser.
     * @param x The horizontal position of this DOM Element in the world.
     * @param y The vertical position of this DOM Element in the world.
     * @param element An existing DOM element, or a string. If a string starting with a # it will do a `getElementById` look-up on the string (minus the hash). Without a hash, it represents the type of element to create, i.e. 'div'.
     * @param style If a string, will be set directly as the elements `style` property value. If a plain object, will be iterated and the values transferred. In both cases the values replacing whatever CSS styles may have been previously set.
     * @param innerText If given, will be set directly as the elements `innerText` property value, replacing whatever was there before.
     */
    dom(x: number, y: number, element?: HTMLElement | string, style?: string | any, innerText?: string): Phaser.GameObjects.DOMElement;

    /**
     * Creates a new Extern Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Extern Game Object has been built into Phaser.
     */
    extern(): Phaser.GameObjects.Extern;

    /**
     * The Scene to which this Game Object Factory belongs.
     */
    protected scene: Phaser.Scene;

    /**
     * A reference to the Scene.Systems.
     */
    protected systems: Phaser.Scenes.Systems;

    /**
     * A reference to the Scene Event Emitter.
     */
    protected events: Phaser.Events.EventEmitter;

    /**
     * A reference to the Scene Display List.
     */
    protected displayList: Phaser.GameObjects.DisplayList;

    /**
     * A reference to the Scene Update List.
     */
    protected updateList: Phaser.GameObjects.UpdateList;

    /**
     * Adds an existing Game Object to this Scene.
     *
     * If the Game Object renders, it will be added to the Display List.
     * If it has a `preUpdate` method, it will be added to the Update List.
     * @param child The child to be added to this Scene.
     */
    existing<G extends (Phaser.GameObjects.GameObject|Phaser.GameObjects.Group|Phaser.GameObjects.Layer)>(child: G): G;

    /**
     * Static method called directly by the Game Object factory functions.
     * With this method you can register a custom GameObject factory in the GameObjectFactory,
     * providing a name (`factoryType`) and the constructor (`factoryFunction`) in order
     * to be called when you call to Phaser.Scene.add[ factoryType ] method.
     * @param factoryType The key of the factory that you will use to call to Phaser.Scene.add[ factoryType ] method.
     * @param factoryFunction The constructor function to be called when you invoke to the Phaser.Scene.add method.
     */
    static register(factoryType: string, factoryFunction: Function): void;

    /**
     * Static method called directly by the Game Object factory functions.
     * With this method you can remove a custom GameObject factory registered in the GameObjectFactory,
     * providing a its `factoryType`.
     * @param factoryType The key of the factory that you want to remove from the GameObjectFactory.
     */
    static remove(factoryType: string): void;

    /**
     * Creates a new Graphics Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Graphics Game Object has been built into Phaser.
     * @param config The Graphics configuration.
     */
    graphics(config?: Phaser.Types.GameObjects.Graphics.Options): Phaser.GameObjects.Graphics;

    /**
     * Creates a new Group Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Group Game Object has been built into Phaser.
     * @param children Game Objects to add to this Group; or the `config` argument.
     * @param config A Group Configuration object.
     */
    group(children?: Phaser.GameObjects.GameObject[] | Phaser.Types.GameObjects.Group.GroupConfig | Phaser.Types.GameObjects.Group.GroupConfig[], config?: Phaser.Types.GameObjects.Group.GroupConfig | Phaser.Types.GameObjects.Group.GroupCreateConfig): Phaser.GameObjects.Group;

    /**
     * Creates a new Image Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Image Game Object has been built into Phaser.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     */
    image(x: number, y: number, texture: string | Phaser.Textures.Texture, frame?: string | number): Phaser.GameObjects.Image;

    /**
     * Creates a new Layer Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Layer Game Object has been built into Phaser.
     * @param children An optional array of Game Objects to add to this Layer.
     */
    layer(children?: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[]): Phaser.GameObjects.Layer;

    /**
     * Creates a new Mesh Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     * @param vertices The vertices array. Either `xy` pairs, or `xyz` if the `containsZ` parameter is `true`.
     * @param uvs The UVs pairs array.
     * @param indicies Optional vertex indicies array. If you don't have one, pass `null` or an empty array.
     * @param containsZ Does the vertices data include a `z` component? Default false.
     * @param normals Optional vertex normals array. If you don't have one, pass `null` or an empty array.
     * @param colors An array of colors, one per vertex, or a single color value applied to all vertices. Default 0xffffff.
     * @param alphas An array of alpha values, one per vertex, or a single alpha value applied to all vertices. Default 1.
     */
    mesh(x?: number, y?: number, texture?: string | Phaser.Textures.Texture, frame?: string | number, vertices?: number[], uvs?: number[], indicies?: number[], containsZ?: boolean, normals?: number[], colors?: number | number[], alphas?: number | number[]): Phaser.GameObjects.Mesh;

    /**
     * Creates a new Particle Emitter Manager Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Particles Game Object has been built into Phaser.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     * @param emitters Configuration settings for one or more emitters to create.
     */
    particles(texture: string | Phaser.Textures.Texture, frame?: string | number | object, emitters?: Phaser.Types.GameObjects.Particles.ParticleEmitterConfig | Phaser.Types.GameObjects.Particles.ParticleEmitterConfig[]): Phaser.GameObjects.Particles.ParticleEmitterManager;

    /**
     * Creates a new PathFollower Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the PathFollower Game Object has been built into Phaser.
     * @param path The Path this PathFollower is connected to.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     */
    follower(path: Phaser.Curves.Path, x: number, y: number, texture: string | Phaser.Textures.Texture, frame?: string | number): Phaser.GameObjects.PathFollower;

    /**
     * Creates a new Point Light Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Point Light Game Object has been built into Phaser.
     *
     * The Point Light Game Object provides a way to add a point light effect into your game,
     * without the expensive shader processing requirements of the traditional Light Game Object.
     *
     * The difference is that the Point Light renders using a custom shader, designed to give the
     * impression of a point light source, of variable radius, intensity and color, in your game.
     * However, unlike the Light Game Object, it does not impact any other Game Objects, or use their
     * normal maps for calcuations. This makes them extremely fast to render compared to Lights
     * and perfect for special effects, such as flickering torches or muzzle flashes.
     *
     * For maximum performance you should batch Point Light Game Objects together. This means
     * ensuring they follow each other consecutively on the display list. Ideally, use a Layer
     * Game Object and then add just Point Lights to it, so that it can batch together the rendering
     * of the lights. You don't _have_ to do this, and if you've only a handful of Point Lights in
     * your game then it's perfectly safe to mix them into the dislay list as normal. However, if
     * you're using a large number of them, please consider how they are mixed into the display list.
     *
     * The renderer will automatically cull Point Lights. Those with a radius that does not intersect
     * with the Camera will be skipped in the rendering list. This happens automatically and the
     * culled state is refreshed every frame, for every camera.
     *
     * The origin of a Point Light is always 0.5 and it cannot be changed.
     *
     * Point Lights are a WebGL only feature and do not have a Canvas counterpart.
     * @param x The horizontal position of this Point Light in the world.
     * @param y The vertical position of this Point Light in the world.
     * @param color The color of the Point Light, given as a hex value. Default 0xffffff.
     * @param radius The radius of the Point Light. Default 128.
     * @param intensity The intensity, or colr blend, of the Point Light. Default 1.
     * @param attenuation The attenuation  of the Point Light. This is the reduction of light from the center point. Default 0.1.
     */
    pointlight(x: number, y: number, color?: number, radius?: number, intensity?: number, attenuation?: number): Phaser.GameObjects.PointLight;

    /**
     * Creates a new Render Texture Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.
     *
     * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and
     * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic
     * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param width The width of the Render Texture. Default 32.
     * @param height The height of the Render Texture. Default 32.
     */
    renderTexture(x: number, y: number, width?: number, height?: number): Phaser.GameObjects.RenderTexture;

    /**
     * Creates a new Rope Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Rope Game Object and WebGL support have been built into Phaser.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     * @param points An array containing the vertices data for this Rope. If none is provided a simple quad is created. See `setPoints` to set this post-creation.
     * @param horizontal Should the vertices of this Rope be aligned horizontally (`true`), or vertically (`false`)? Default true.
     * @param colors An optional array containing the color data for this Rope. You should provide one color value per pair of vertices.
     * @param alphas An optional array containing the alpha data for this Rope. You should provide one alpha value per pair of vertices.
     */
    rope(x: number, y: number, texture: string | Phaser.Textures.Texture, frame?: string | number, points?: Phaser.Types.Math.Vector2Like[], horizontal?: boolean, colors?: number[], alphas?: number[]): Phaser.GameObjects.Rope;

    /**
     * Creates a new Shader Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Shader Game Object and WebGL support have been built into Phaser.
     * @param key The key of the shader to use from the shader cache, or a BaseShader instance.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param width The width of the Game Object. Default 128.
     * @param height The height of the Game Object. Default 128.
     * @param textures Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.
     * @param textureData Optional additional texture data.
     */
    shader(key: string | Phaser.Display.BaseShader, x?: number, y?: number, width?: number, height?: number, textures?: string[], textureData?: object): Phaser.GameObjects.Shader;

    /**
     * Creates a new Arc Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Arc Game Object has been built into Phaser.
     *
     * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports both fill and stroke colors.
     *
     * When it renders it displays an arc shape. You can control the start and end angles of the arc,
     * as well as if the angles are winding clockwise or anti-clockwise. With the default settings
     * it renders as a complete circle. By changing the angles you can create other arc shapes,
     * such as half-circles.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param radius The radius of the arc. Default 128.
     * @param startAngle The start angle of the arc, in degrees. Default 0.
     * @param endAngle The end angle of the arc, in degrees. Default 360.
     * @param anticlockwise The winding order of the start and end angles. Default false.
     * @param fillColor The color the arc will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    arc(x?: number, y?: number, radius?: number, startAngle?: number, endAngle?: number, anticlockwise?: boolean, fillColor?: number, fillAlpha?: number): Phaser.GameObjects.Arc;

    /**
     * Creates a new Circle Shape Game Object and adds it to the Scene.
     *
     * A Circle is an Arc with no defined start and end angle, making it render as a complete circle.
     *
     * Note: This method will only be available if the Arc Game Object has been built into Phaser.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param radius The radius of the circle. Default 128.
     * @param fillColor The color the circle will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the circle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    circle(x?: number, y?: number, radius?: number, fillColor?: number, fillAlpha?: number): Phaser.GameObjects.Arc;

    /**
     * Creates a new Curve Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Curve Game Object has been built into Phaser.
     *
     * The Curve Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports both fill and stroke colors.
     *
     * To render a Curve Shape you must first create a `Phaser.Curves.Curve` object, then pass it to
     * the Curve Shape in the constructor.
     *
     * The Curve shape also has a `smoothness` property and corresponding `setSmoothness` method.
     * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations
     * that take place during construction. Increase and decrease the default value for smoother, or more
     * jagged, shapes.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param curve The Curve object to use to create the Shape.
     * @param fillColor The color the curve will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the curve will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    curve(x?: number, y?: number, curve?: Phaser.Curves.Curve, fillColor?: number, fillAlpha?: number): Phaser.GameObjects.Curve;

    /**
     * Creates a new Ellipse Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Ellipse Game Object has been built into Phaser.
     *
     * The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports both fill and stroke colors.
     *
     * When it renders it displays an ellipse shape. You can control the width and height of the ellipse.
     * If the width and height match it will render as a circle. If the width is less than the height,
     * it will look more like an egg shape.
     *
     * The Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.
     * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations
     * that take place during construction. Increase and decrease the default value for smoother, or more
     * jagged, shapes.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param width The width of the ellipse. An ellipse with equal width and height renders as a circle. Default 128.
     * @param height The height of the ellipse. An ellipse with equal width and height renders as a circle. Default 128.
     * @param fillColor The color the ellipse will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the ellipse will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    ellipse(x?: number, y?: number, width?: number, height?: number, fillColor?: number, fillAlpha?: number): Phaser.GameObjects.Ellipse;

    /**
     * Creates a new Grid Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Grid Game Object has been built into Phaser.
     *
     * The Grid Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports only fill colors and cannot be stroked.
     *
     * A Grid Shape allows you to display a grid in your game, where you can control the size of the
     * grid as well as the width and height of the grid cells. You can set a fill color for each grid
     * cell as well as an alternate fill color. When the alternate fill color is set then the grid
     * cells will alternate the fill colors as they render, creating a chess-board effect. You can
     * also optionally have an outline fill color. If set, this draws lines between the grid cells
     * in the given color. If you specify an outline color with an alpha of zero, then it will draw
     * the cells spaced out, but without the lines between them.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param width The width of the grid. Default 128.
     * @param height The height of the grid. Default 128.
     * @param cellWidth The width of one cell in the grid. Default 32.
     * @param cellHeight The height of one cell in the grid. Default 32.
     * @param fillColor The color the grid cells will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     * @param outlineFillColor The color of the lines between the grid cells.
     * @param outlineFillAlpha The alpha of the lines between the grid cells.
     */
    grid(x?: number, y?: number, width?: number, height?: number, cellWidth?: number, cellHeight?: number, fillColor?: number, fillAlpha?: number, outlineFillColor?: number, outlineFillAlpha?: number): Phaser.GameObjects.Grid;

    /**
     * Creates a new IsoBox Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the IsoBox Game Object has been built into Phaser.
     *
     * The IsoBox Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports only fill colors and cannot be stroked.
     *
     * An IsoBox is an 'isometric' rectangle. Each face of it has a different fill color. You can set
     * the color of the top, left and right faces of the rectangle respectively. You can also choose
     * which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.
     *
     * You cannot view an IsoBox from under-neath, however you can change the 'angle' by setting
     * the `projection` property.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param size The width of the iso box in pixels. The left and right faces will be exactly half this value. Default 48.
     * @param height The height of the iso box. The left and right faces will be this tall. The overall height of the isobox will be this value plus half the `size` value. Default 32.
     * @param fillTop The fill color of the top face of the iso box. Default 0xeeeeee.
     * @param fillLeft The fill color of the left face of the iso box. Default 0x999999.
     * @param fillRight The fill color of the right face of the iso box. Default 0xcccccc.
     */
    isobox(x?: number, y?: number, size?: number, height?: number, fillTop?: number, fillLeft?: number, fillRight?: number): Phaser.GameObjects.IsoBox;

    /**
     * Creates a new IsoTriangle Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the IsoTriangle Game Object has been built into Phaser.
     *
     * The IsoTriangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports only fill colors and cannot be stroked.
     *
     * An IsoTriangle is an 'isometric' triangle. Think of it like a pyramid. Each face has a different
     * fill color. You can set the color of the top, left and right faces of the triangle respectively
     * You can also choose which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.
     *
     * You cannot view an IsoTriangle from under-neath, however you can change the 'angle' by setting
     * the `projection` property. The `reversed` property controls if the IsoTriangle is rendered upside
     * down or not.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param size The width of the iso triangle in pixels. The left and right faces will be exactly half this value. Default 48.
     * @param height The height of the iso triangle. The left and right faces will be this tall. The overall height of the iso triangle will be this value plus half the `size` value. Default 32.
     * @param reversed Is the iso triangle upside down? Default false.
     * @param fillTop The fill color of the top face of the iso triangle. Default 0xeeeeee.
     * @param fillLeft The fill color of the left face of the iso triangle. Default 0x999999.
     * @param fillRight The fill color of the right face of the iso triangle. Default 0xcccccc.
     */
    isotriangle(x?: number, y?: number, size?: number, height?: number, reversed?: boolean, fillTop?: number, fillLeft?: number, fillRight?: number): Phaser.GameObjects.IsoTriangle;

    /**
     * Creates a new Line Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Line Game Object has been built into Phaser.
     *
     * The Line Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports only stroke colors and cannot be filled.
     *
     * A Line Shape allows you to draw a line between two points in your game. You can control the
     * stroke color and thickness of the line. In WebGL only you can also specify a different
     * thickness for the start and end of the line, allowing you to render lines that taper-off.
     *
     * If you need to draw multiple lines in a sequence you may wish to use the Polygon Shape instead.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param x1 The horizontal position of the start of the line. Default 0.
     * @param y1 The vertical position of the start of the line. Default 0.
     * @param x2 The horizontal position of the end of the line. Default 128.
     * @param y2 The vertical position of the end of the line. Default 0.
     * @param strokeColor The color the line will be drawn in, i.e. 0xff0000 for red.
     * @param strokeAlpha The alpha the line will be drawn in. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    line(x?: number, y?: number, x1?: number, y1?: number, x2?: number, y2?: number, strokeColor?: number, strokeAlpha?: number): Phaser.GameObjects.Line;

    /**
     * Creates a new Polygon Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Polygon Game Object has been built into Phaser.
     *
     * The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports both fill and stroke colors.
     *
     * The Polygon Shape is created by providing a list of points, which are then used to create an
     * internal Polygon geometry object. The points can be set from a variety of formats:
     *
     * - An array of Point or Vector2 objects: `[new Phaser.Math.Vector2(x1, y1), ...]`
     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
     *
     * By default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending
     * on the coordinates of the points provided, the final shape may be rendered offset from its origin.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param points The points that make up the polygon.
     * @param fillColor The color the polygon will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the polygon will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    polygon(x?: number, y?: number, points?: any, fillColor?: number, fillAlpha?: number): Phaser.GameObjects.Polygon;

    /**
     * Creates a new Rectangle Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Rectangle Game Object has been built into Phaser.
     *
     * The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports both fill and stroke colors.
     *
     * You can change the size of the rectangle by changing the `width` and `height` properties.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param width The width of the rectangle. Default 128.
     * @param height The height of the rectangle. Default 128.
     * @param fillColor The color the rectangle will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the rectangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    rectangle(x?: number, y?: number, width?: number, height?: number, fillColor?: number, fillAlpha?: number): Phaser.GameObjects.Rectangle;

    /**
     * Creates a new Star Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Star Game Object has been built into Phaser.
     *
     * The Star Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports both fill and stroke colors.
     *
     * As the name implies, the Star shape will display a star in your game. You can control several
     * aspects of it including the number of points that constitute the star. The default is 5. If
     * you change it to 4 it will render as a diamond. If you increase them, you'll get a more spiky
     * star shape.
     *
     * You can also control the inner and outer radius, which is how 'long' each point of the star is.
     * Modify these values to create more interesting shapes.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param points The number of points on the star. Default 5.
     * @param innerRadius The inner radius of the star. Default 32.
     * @param outerRadius The outer radius of the star. Default 64.
     * @param fillColor The color the star will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the star will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    star(x?: number, y?: number, points?: number, innerRadius?: number, outerRadius?: number, fillColor?: number, fillAlpha?: number): Phaser.GameObjects.Star;

    /**
     * Creates a new Triangle Shape Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Triangle Game Object has been built into Phaser.
     *
     * The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
     * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
     * it for input or physics. It provides a quick and easy way for you to render this shape in your
     * game without using a texture, while still taking advantage of being fully batched in WebGL.
     *
     * This shape supports both fill and stroke colors.
     *
     * The Triangle consists of 3 lines, joining up to form a triangular shape. You can control the
     * position of each point of these lines. The triangle is always closed and cannot have an open
     * face. If you require that, consider using a Polygon instead.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param x1 The horizontal position of the first point in the triangle. Default 0.
     * @param y1 The vertical position of the first point in the triangle. Default 128.
     * @param x2 The horizontal position of the second point in the triangle. Default 64.
     * @param y2 The vertical position of the second point in the triangle. Default 0.
     * @param x3 The horizontal position of the third point in the triangle. Default 128.
     * @param y3 The vertical position of the third point in the triangle. Default 128.
     * @param fillColor The color the triangle will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the triangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    triangle(x?: number, y?: number, x1?: number, y1?: number, x2?: number, y2?: number, x3?: number, y3?: number, fillColor?: number, fillAlpha?: number): Phaser.GameObjects.Triangle;

    /**
     * Creates a new Sprite Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Sprite Game Object has been built into Phaser.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     */
    sprite(x: number, y: number, texture: string | Phaser.Textures.Texture, frame?: string | number): Phaser.GameObjects.Sprite;

    /**
     * Creates a new Text Game Object and adds it to the Scene.
     *
     * A Text Game Object.
     *
     * Text objects work by creating their own internal hidden Canvas and then renders text to it using
     * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered
     * to your game during the render pass.
     *
     * Because it uses the Canvas API you can take advantage of all the features this offers, such as
     * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts
     * loaded externally, such as Google or TypeKit Web fonts.
     *
     * You can only display fonts that are currently loaded and available to the browser: therefore fonts must
     * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,
     * or have the fonts ready available in the CSS on the page in which your Phaser game resides.
     *
     * See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts
     * across mobile browsers.
     *
     * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being
     * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the
     * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of
     * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text
     * instead, as it benefits from batching and avoids expensive Canvas API calls.
     *
     * Note: This method will only be available if the Text Game Object has been built into Phaser.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param text The text this Text object will display.
     * @param style The Text style configuration object.
     */
    text(x: number, y: number, text: string | string[], style?: Phaser.Types.GameObjects.Text.TextStyle): Phaser.GameObjects.Text;

    /**
     * Creates a new TileSprite Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param width The width of the Game Object. If zero it will use the size of the texture frame.
     * @param height The height of the Game Object. If zero it will use the size of the texture frame.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     */
    tileSprite(x: number, y: number, width: number, height: number, texture: string | Phaser.Textures.Texture, frame?: string | number): Phaser.GameObjects.TileSprite;

    /**
     * Creates a new Video Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Video Game Object has been built into Phaser.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param key Optional key of the Video this Game Object will play, as stored in the Video Cache.
     */
    video(x: number, y: number, key?: string): Phaser.GameObjects.Video;

    /**
     * Creates a new Zone Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Zone Game Object has been built into Phaser.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param width The width of the Game Object.
     * @param height The height of the Game Object.
     */
    zone(x: number, y: number, width: number, height: number): Phaser.GameObjects.Zone;

    /**
     * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.
     * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing
     * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map
     * data. For an empty map, you should specify tileWidth, tileHeight, width & height.
     * @param key The key in the Phaser cache that corresponds to the loaded tilemap data.
     * @param tileWidth The width of a tile in pixels. Pass in `null` to leave as the
     * default. Default 32.
     * @param tileHeight The height of a tile in pixels. Pass in `null` to leave as the
     * default. Default 32.
     * @param width The width of the map in tiles. Pass in `null` to leave as the
     * default. Default 10.
     * @param height The height of the map in tiles. Pass in `null` to leave as the
     * default. Default 10.
     * @param data Instead of loading from the cache, you can also load directly from
     * a 2D array of tile indexes. Pass in `null` for no data.
     * @param insertNull Controls how empty tiles, tiles with an index of -1, in the
     * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
     * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
     * the tile data doesn't need to change then setting this value to `true` will help with memory
     * consumption. However if your map is small or you need to update the tiles dynamically, then leave
     * the default value set. Default false.
     */
    tilemap(key?: string, tileWidth?: number, tileHeight?: number, width?: number, height?: number, data?: number[][], insertNull?: boolean): Phaser.Tilemaps.Tilemap;

    /**
     * Creates a new Tween object.
     *
     * Note: This method will only be available if Tweens have been built into Phaser.
     * @param config The Tween configuration.
     */
    tween(config: Phaser.Types.Tweens.TweenBuilderConfig | object): Phaser.Tweens.Tween;

  }

  /**
   * Calculates the Transform Matrix of the given Game Object and Camera, factoring in
   * the parent matrix if provided.
   *
   * Note that the object this results contains _references_ to the Transform Matrices,
   * not new instances of them. Therefore, you should use their values immediately, or
   * copy them to your own matrix, as they will be replaced as soon as another Game
   * Object is rendered.
   * @param src The Game Object to calculate the transform matrix for.
   * @param camera The camera being used to render the Game Object.
   * @param parentMatrix The transform matrix of the parent container, if any.
   */
  function GetCalcMatrix(src: Phaser.GameObjects.GameObject, camera: Phaser.Cameras.Scene2D.Camera, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.Types.GameObjects.GetCalcMatrixResults;

  /**
   * A Graphics object is a way to draw primitive shapes to your game. Primitives include forms of geometry, such as
   * Rectangles, Circles, and Polygons. They also include lines, arcs and curves. When you initially create a Graphics
   * object it will be empty.
   *
   * To draw to it you must first specify a line style or fill style (or both), draw shapes using paths, and finally
   * fill or stroke them. For example:
   *
   * ```javascript
   * graphics.lineStyle(5, 0xFF00FF, 1.0);
   * graphics.beginPath();
   * graphics.moveTo(100, 100);
   * graphics.lineTo(200, 200);
   * graphics.closePath();
   * graphics.strokePath();
   * ```
   *
   * There are also many helpful methods that draw and fill/stroke common shapes for you.
   *
   * ```javascript
   * graphics.lineStyle(5, 0xFF00FF, 1.0);
   * graphics.fillStyle(0xFFFFFF, 1.0);
   * graphics.fillRect(50, 50, 400, 200);
   * graphics.strokeRect(50, 50, 400, 200);
   * ```
   *
   * When a Graphics object is rendered it will render differently based on if the game is running under Canvas or WebGL.
   * Under Canvas it will use the HTML Canvas context drawing operations to draw the path.
   * Under WebGL the graphics data is decomposed into polygons. Both of these are expensive processes, especially with
   * complex shapes.
   *
   * If your Graphics object doesn't change much (or at all) once you've drawn your shape to it, then you will help
   * performance by calling {@link Phaser.GameObjects.Graphics#generateTexture}. This will 'bake' the Graphics object into
   * a Texture, and return it. You can then use this Texture for Sprites or other display objects. If your Graphics object
   * updates frequently then you should avoid doing this, as it will constantly generate new textures, which will consume
   * memory.
   *
   * As you can tell, Graphics objects are a bit of a trade-off. While they are extremely useful, you need to be careful
   * in their complexity and quantity of them in your game.
   */
  class Graphics extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.AlphaSingle, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible, Phaser.GameObjects.Components.ScrollFactor {
    /**
     *
     * @param scene The Scene to which this Graphics object belongs.
     * @param options Options that set the position and default style of this Graphics object.
     */
    constructor(scene: Phaser.Scene, options?: Phaser.Types.GameObjects.Graphics.Options);

    /**
     * The horizontal display origin of the Graphics.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of the Graphics.
     */
    displayOriginY: number;

    /**
     * The array of commands used to render the Graphics.
     */
    commandBuffer: any[];

    /**
     * The default fill color for shapes rendered by this Graphics object.
     */
    defaultFillColor: number;

    /**
     * The default fill alpha for shapes rendered by this Graphics object.
     */
    defaultFillAlpha: number;

    /**
     * The default stroke width for shapes rendered by this Graphics object.
     */
    defaultStrokeWidth: number;

    /**
     * The default stroke color for shapes rendered by this Graphics object.
     */
    defaultStrokeColor: number;

    /**
     * The default stroke alpha for shapes rendered by this Graphics object.
     */
    defaultStrokeAlpha: number;

    /**
     * Set the default style settings for this Graphics object.
     * @param options The styles to set as defaults.
     */
    setDefaultStyles(options: Phaser.Types.GameObjects.Graphics.Styles): this;

    /**
     * Set the current line style.
     * @param lineWidth The stroke width.
     * @param color The stroke color.
     * @param alpha The stroke alpha. Default 1.
     */
    lineStyle(lineWidth: number, color: number, alpha?: number): this;

    /**
     * Set the current fill style.
     * @param color The fill color.
     * @param alpha The fill alpha. Default 1.
     */
    fillStyle(color: number, alpha?: number): this;

    /**
     * Sets a gradient fill style. This is a WebGL only feature.
     *
     * The gradient color values represent the 4 corners of an untransformed rectangle.
     * The gradient is used to color all filled shapes and paths drawn after calling this method.
     * If you wish to turn a gradient off, call `fillStyle` and provide a new single fill color.
     *
     * When filling a triangle only the first 3 color values provided are used for the 3 points of a triangle.
     *
     * This feature is best used only on rectangles and triangles. All other shapes will give strange results.
     *
     * Note that for objects such as arcs or ellipses, or anything which is made out of triangles, each triangle used
     * will be filled with a gradient on its own. There is no ability to gradient fill a shape or path as a single
     * entity at this time.
     * @param topLeft The top left fill color.
     * @param topRight The top right fill color.
     * @param bottomLeft The bottom left fill color.
     * @param bottomRight The bottom right fill color. Not used when filling triangles.
     * @param alphaTopLeft The top left alpha value. If you give only this value, it's used for all corners. Default 1.
     * @param alphaTopRight The top right alpha value. Default 1.
     * @param alphaBottomLeft The bottom left alpha value. Default 1.
     * @param alphaBottomRight The bottom right alpha value. Default 1.
     */
    fillGradientStyle(topLeft: number, topRight: number, bottomLeft: number, bottomRight: number, alphaTopLeft?: number, alphaTopRight?: number, alphaBottomLeft?: number, alphaBottomRight?: number): this;

    /**
     * Sets a gradient line style. This is a WebGL only feature.
     *
     * The gradient color values represent the 4 corners of an untransformed rectangle.
     * The gradient is used to color all stroked shapes and paths drawn after calling this method.
     * If you wish to turn a gradient off, call `lineStyle` and provide a new single line color.
     *
     * This feature is best used only on single lines. All other shapes will give strange results.
     *
     * Note that for objects such as arcs or ellipses, or anything which is made out of triangles, each triangle used
     * will be filled with a gradient on its own. There is no ability to gradient stroke a shape or path as a single
     * entity at this time.
     * @param lineWidth The stroke width.
     * @param topLeft The tint being applied to the top-left of the Game Object.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     * @param alpha The fill alpha. Default 1.
     */
    lineGradientStyle(lineWidth: number, topLeft: number, topRight: number, bottomLeft: number, bottomRight: number, alpha?: number): this;

    /**
     * Start a new shape path.
     */
    beginPath(): this;

    /**
     * Close the current path.
     */
    closePath(): this;

    /**
     * Fill the current path.
     */
    fillPath(): this;

    /**
     * Fill the current path.
     *
     * This is an alias for `Graphics.fillPath` and does the same thing.
     * It was added to match the CanvasRenderingContext 2D API.
     */
    fill(): this;

    /**
     * Stroke the current path.
     */
    strokePath(): this;

    /**
     * Stroke the current path.
     *
     * This is an alias for `Graphics.strokePath` and does the same thing.
     * It was added to match the CanvasRenderingContext 2D API.
     */
    stroke(): this;

    /**
     * Fill the given circle.
     * @param circle The circle to fill.
     */
    fillCircleShape(circle: Phaser.Geom.Circle): this;

    /**
     * Stroke the given circle.
     * @param circle The circle to stroke.
     */
    strokeCircleShape(circle: Phaser.Geom.Circle): this;

    /**
     * Fill a circle with the given position and radius.
     * @param x The x coordinate of the center of the circle.
     * @param y The y coordinate of the center of the circle.
     * @param radius The radius of the circle.
     */
    fillCircle(x: number, y: number, radius: number): this;

    /**
     * Stroke a circle with the given position and radius.
     * @param x The x coordinate of the center of the circle.
     * @param y The y coordinate of the center of the circle.
     * @param radius The radius of the circle.
     */
    strokeCircle(x: number, y: number, radius: number): this;

    /**
     * Fill the given rectangle.
     * @param rect The rectangle to fill.
     */
    fillRectShape(rect: Phaser.Geom.Rectangle): this;

    /**
     * Stroke the given rectangle.
     * @param rect The rectangle to stroke.
     */
    strokeRectShape(rect: Phaser.Geom.Rectangle): this;

    /**
     * Fill a rectangle with the given position and size.
     * @param x The x coordinate of the top-left of the rectangle.
     * @param y The y coordinate of the top-left of the rectangle.
     * @param width The width of the rectangle.
     * @param height The height of the rectangle.
     */
    fillRect(x: number, y: number, width: number, height: number): this;

    /**
     * Stroke a rectangle with the given position and size.
     * @param x The x coordinate of the top-left of the rectangle.
     * @param y The y coordinate of the top-left of the rectangle.
     * @param width The width of the rectangle.
     * @param height The height of the rectangle.
     */
    strokeRect(x: number, y: number, width: number, height: number): this;

    /**
     * Fill a rounded rectangle with the given position, size and radius.
     * @param x The x coordinate of the top-left of the rectangle.
     * @param y The y coordinate of the top-left of the rectangle.
     * @param width The width of the rectangle.
     * @param height The height of the rectangle.
     * @param radius The corner radius; It can also be an object to specify different radii for corners. Default 20.
     */
    fillRoundedRect(x: number, y: number, width: number, height: number, radius?: Phaser.Types.GameObjects.Graphics.RoundedRectRadius | number): this;

    /**
     * Stroke a rounded rectangle with the given position, size and radius.
     * @param x The x coordinate of the top-left of the rectangle.
     * @param y The y coordinate of the top-left of the rectangle.
     * @param width The width of the rectangle.
     * @param height The height of the rectangle.
     * @param radius The corner radius; It can also be an object to specify different radii for corners. Default 20.
     */
    strokeRoundedRect(x: number, y: number, width: number, height: number, radius?: Phaser.Types.GameObjects.Graphics.RoundedRectRadius | number): this;

    /**
     * Fill the given point.
     *
     * Draws a square at the given position, 1 pixel in size by default.
     * @param point The point to fill.
     * @param size The size of the square to draw. Default 1.
     */
    fillPointShape(point: Phaser.Geom.Point | Phaser.Math.Vector2 | object, size?: number): this;

    /**
     * Fill a point at the given position.
     *
     * Draws a square at the given position, 1 pixel in size by default.
     * @param x The x coordinate of the point.
     * @param y The y coordinate of the point.
     * @param size The size of the square to draw. Default 1.
     */
    fillPoint(x: number, y: number, size?: number): this;

    /**
     * Fill the given triangle.
     * @param triangle The triangle to fill.
     */
    fillTriangleShape(triangle: Phaser.Geom.Triangle): this;

    /**
     * Stroke the given triangle.
     * @param triangle The triangle to stroke.
     */
    strokeTriangleShape(triangle: Phaser.Geom.Triangle): this;

    /**
     * Fill a triangle with the given points.
     * @param x0 The x coordinate of the first point.
     * @param y0 The y coordinate of the first point.
     * @param x1 The x coordinate of the second point.
     * @param y1 The y coordinate of the second point.
     * @param x2 The x coordinate of the third point.
     * @param y2 The y coordinate of the third point.
     */
    fillTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): this;

    /**
     * Stroke a triangle with the given points.
     * @param x0 The x coordinate of the first point.
     * @param y0 The y coordinate of the first point.
     * @param x1 The x coordinate of the second point.
     * @param y1 The y coordinate of the second point.
     * @param x2 The x coordinate of the third point.
     * @param y2 The y coordinate of the third point.
     */
    strokeTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): this;

    /**
     * Draw the given line.
     * @param line The line to stroke.
     */
    strokeLineShape(line: Phaser.Geom.Line): this;

    /**
     * Draw a line between the given points.
     * @param x1 The x coordinate of the start point of the line.
     * @param y1 The y coordinate of the start point of the line.
     * @param x2 The x coordinate of the end point of the line.
     * @param y2 The y coordinate of the end point of the line.
     */
    lineBetween(x1: number, y1: number, x2: number, y2: number): this;

    /**
     * Draw a line from the current drawing position to the given position.
     *
     * Moves the current drawing position to the given position.
     * @param x The x coordinate to draw the line to.
     * @param y The y coordinate to draw the line to.
     */
    lineTo(x: number, y: number): this;

    /**
     * Move the current drawing position to the given position.
     * @param x The x coordinate to move to.
     * @param y The y coordinate to move to.
     */
    moveTo(x: number, y: number): this;

    /**
     * Stroke the shape represented by the given array of points.
     *
     * Pass `closeShape` to automatically close the shape by joining the last to the first point.
     *
     * Pass `closePath` to automatically close the path before it is stroked.
     * @param points The points to stroke.
     * @param closeShape When `true`, the shape is closed by joining the last point to the first point. Default false.
     * @param closePath When `true`, the path is closed before being stroked. Default false.
     * @param endIndex The index of `points` to stop drawing at. Defaults to `points.length`.
     */
    strokePoints(points: any[] | Phaser.Geom.Point[], closeShape?: boolean, closePath?: boolean, endIndex?: number): this;

    /**
     * Fill the shape represented by the given array of points.
     *
     * Pass `closeShape` to automatically close the shape by joining the last to the first point.
     *
     * Pass `closePath` to automatically close the path before it is filled.
     * @param points The points to fill.
     * @param closeShape When `true`, the shape is closed by joining the last point to the first point. Default false.
     * @param closePath When `true`, the path is closed before being stroked. Default false.
     * @param endIndex The index of `points` to stop at. Defaults to `points.length`.
     */
    fillPoints(points: any[] | Phaser.Geom.Point[], closeShape?: boolean, closePath?: boolean, endIndex?: number): this;

    /**
     * Stroke the given ellipse.
     * @param ellipse The ellipse to stroke.
     * @param smoothness The number of points to draw the ellipse with. Default 32.
     */
    strokeEllipseShape(ellipse: Phaser.Geom.Ellipse, smoothness?: number): this;

    /**
     * Stroke an ellipse with the given position and size.
     * @param x The x coordinate of the center of the ellipse.
     * @param y The y coordinate of the center of the ellipse.
     * @param width The width of the ellipse.
     * @param height The height of the ellipse.
     * @param smoothness The number of points to draw the ellipse with. Default 32.
     */
    strokeEllipse(x: number, y: number, width: number, height: number, smoothness?: number): this;

    /**
     * Fill the given ellipse.
     * @param ellipse The ellipse to fill.
     * @param smoothness The number of points to draw the ellipse with. Default 32.
     */
    fillEllipseShape(ellipse: Phaser.Geom.Ellipse, smoothness?: number): this;

    /**
     * Fill an ellipse with the given position and size.
     * @param x The x coordinate of the center of the ellipse.
     * @param y The y coordinate of the center of the ellipse.
     * @param width The width of the ellipse.
     * @param height The height of the ellipse.
     * @param smoothness The number of points to draw the ellipse with. Default 32.
     */
    fillEllipse(x: number, y: number, width: number, height: number, smoothness?: number): this;

    /**
     * Draw an arc.
     *
     * This method can be used to create circles, or parts of circles.
     *
     * Make sure you call `beginPath` before starting the arc unless you wish for the arc to automatically
     * close when filled or stroked.
     *
     * Use the optional `overshoot` argument increase the number of iterations that take place when
     * the arc is rendered in WebGL. This is useful if you're drawing an arc with an especially thick line,
     * as it will allow the arc to fully join-up. Try small values at first, i.e. 0.01.
     *
     * Call {@link Phaser.GameObjects.Graphics#fillPath} or {@link Phaser.GameObjects.Graphics#strokePath} after calling
     * this method to draw the arc.
     * @param x The x coordinate of the center of the circle.
     * @param y The y coordinate of the center of the circle.
     * @param radius The radius of the circle.
     * @param startAngle The starting angle, in radians.
     * @param endAngle The ending angle, in radians.
     * @param anticlockwise Whether the drawing should be anticlockwise or clockwise. Default false.
     * @param overshoot This value allows you to increase the segment iterations in WebGL rendering. Useful if the arc has a thick stroke and needs to overshoot to join-up cleanly. Use small numbers such as 0.01 to start with and increase as needed. Default 0.
     */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean, overshoot?: number): this;

    /**
     * Creates a pie-chart slice shape centered at `x`, `y` with the given radius.
     * You must define the start and end angle of the slice.
     *
     * Setting the `anticlockwise` argument to `true` creates a shape similar to Pacman.
     * Setting it to `false` creates a shape like a slice of pie.
     *
     * This method will begin a new path and close the path at the end of it.
     * To display the actual slice you need to call either `strokePath` or `fillPath` after it.
     * @param x The horizontal center of the slice.
     * @param y The vertical center of the slice.
     * @param radius The radius of the slice.
     * @param startAngle The start angle of the slice, given in radians.
     * @param endAngle The end angle of the slice, given in radians.
     * @param anticlockwise Whether the drawing should be anticlockwise or clockwise. Default false.
     * @param overshoot This value allows you to overshoot the endAngle by this amount. Useful if the arc has a thick stroke and needs to overshoot to join-up cleanly. Default 0.
     */
    slice(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean, overshoot?: number): this;

    /**
     * Saves the state of the Graphics by pushing the current state onto a stack.
     *
     * The most recently saved state can then be restored with {@link Phaser.GameObjects.Graphics#restore}.
     */
    save(): this;

    /**
     * Restores the most recently saved state of the Graphics by popping from the state stack.
     *
     * Use {@link Phaser.GameObjects.Graphics#save} to save the current state, and call this afterwards to restore that state.
     *
     * If there is no saved state, this command does nothing.
     */
    restore(): this;

    /**
     * Inserts a translation command into this Graphics objects command buffer.
     *
     * All objects drawn _after_ calling this method will be translated
     * by the given amount.
     *
     * This does not change the position of the Graphics object itself,
     * only of the objects drawn by it after calling this method.
     * @param x The horizontal translation to apply.
     * @param y The vertical translation to apply.
     */
    translateCanvas(x: number, y: number): this;

    /**
     * Inserts a scale command into this Graphics objects command buffer.
     *
     * All objects drawn _after_ calling this method will be scaled
     * by the given amount.
     *
     * This does not change the scale of the Graphics object itself,
     * only of the objects drawn by it after calling this method.
     * @param x The horizontal scale to apply.
     * @param y The vertical scale to apply.
     */
    scaleCanvas(x: number, y: number): this;

    /**
     * Inserts a rotation command into this Graphics objects command buffer.
     *
     * All objects drawn _after_ calling this method will be rotated
     * by the given amount.
     *
     * This does not change the rotation of the Graphics object itself,
     * only of the objects drawn by it after calling this method.
     * @param radians The rotation angle, in radians.
     */
    rotateCanvas(radians: number): this;

    /**
     * Clear the command buffer and reset the fill style and line style to their defaults.
     */
    clear(): this;

    /**
     * Generate a texture from this Graphics object.
     *
     * If `key` is a string it'll generate a new texture using it and add it into the
     * Texture Manager (assuming no key conflict happens).
     *
     * If `key` is a Canvas it will draw the texture to that canvas context. Note that it will NOT
     * automatically upload it to the GPU in WebGL mode.
     *
     * Please understand that the texture is created via the Canvas API of the browser, therefore some
     * Graphics features, such as `fillGradientStyle`, will not appear on the resulting texture,
     * as they're unsupported by the Canvas API.
     * @param key The key to store the texture with in the Texture Manager, or a Canvas to draw to.
     * @param width The width of the graphics to generate.
     * @param height The height of the graphics to generate.
     */
    generateTexture(key: string | HTMLCanvasElement, width?: number, height?: number): this;

    /**
     * Internal destroy handler, called as part of the destroy process.
     */
    protected preDestroy(): void;

    /**
     * A Camera used specifically by the Graphics system for rendering to textures.
     */
    static TargetCamera: Phaser.Cameras.Scene2D.Camera;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

  }

  /**
   * A Group is a way for you to create, manipulate, or recycle similar Game Objects.
   *
   * Group membership is non-exclusive. A Game Object can belong to several groups, one group, or none.
   *
   * Groups themselves aren't displayable, and can't be positioned, rotated, scaled, or hidden.
   */
  class Group extends Phaser.Events.EventEmitter {
    /**
     *
     * @param scene The scene this group belongs to.
     * @param children Game Objects to add to this group; or the `config` argument.
     * @param config Settings for this group. If `key` is set, Phaser.GameObjects.Group#createMultiple is also called with these settings.
     */
    constructor(scene: Phaser.Scene, children?: Phaser.GameObjects.GameObject[] | Phaser.Types.GameObjects.Group.GroupConfig | Phaser.Types.GameObjects.Group.GroupCreateConfig, config?: Phaser.Types.GameObjects.Group.GroupConfig | Phaser.Types.GameObjects.Group.GroupCreateConfig);

    /**
     * This scene this group belongs to.
     */
    scene: Phaser.Scene;

    /**
     * Members of this group.
     */
    children: Phaser.Structs.Set<Phaser.GameObjects.GameObject>;

    /**
     * A flag identifying this object as a group.
     */
    isParent: boolean;

    /**
     * A textual representation of this Game Object.
     * Used internally by Phaser but is available for your own custom classes to populate.
     */
    type: string;

    /**
     * The class to create new group members from.
     */
    classType: Function;

    /**
     * The name of this group.
     * Empty by default and never populated by Phaser, this is left for developers to use.
     */
    name: string;

    /**
     * Whether this group runs its {@link Phaser.GameObjects.Group#preUpdate} method (which may update any members).
     */
    active: boolean;

    /**
     * The maximum size of this group, if used as a pool. -1 is no limit.
     */
    maxSize: number;

    /**
     * A default texture key to use when creating new group members.
     *
     * This is used in {@link Phaser.GameObjects.Group#create}
     * but not in {@link Phaser.GameObjects.Group#createMultiple}.
     */
    defaultKey: string;

    /**
     * A default texture frame to use when creating new group members.
     */
    defaultFrame: string | number;

    /**
     * Whether to call the update method of any members.
     */
    runChildUpdate: boolean;

    /**
     * A function to be called when adding or creating group members.
     */
    createCallback: Phaser.Types.GameObjects.Group.GroupCallback;

    /**
     * A function to be called when removing group members.
     */
    removeCallback: Phaser.Types.GameObjects.Group.GroupCallback;

    /**
     * A function to be called when creating several group members at once.
     */
    createMultipleCallback: Phaser.Types.GameObjects.Group.GroupMultipleCreateCallback;

    /**
     * Creates a new Game Object and adds it to this group, unless the group {@link Phaser.GameObjects.Group#isFull is full}.
     *
     * Calls {@link Phaser.GameObjects.Group#createCallback}.
     * @param x The horizontal position of the new Game Object in the world. Default 0.
     * @param y The vertical position of the new Game Object in the world. Default 0.
     * @param key The texture key of the new Game Object. Default defaultKey.
     * @param frame The texture frame of the new Game Object. Default defaultFrame.
     * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of the new Game Object. Default true.
     * @param active The {@link Phaser.GameObjects.GameObject#active} state of the new Game Object. Default true.
     */
    create(x?: number, y?: number, key?: string, frame?: string | number, visible?: boolean, active?: boolean): any;

    /**
     * Creates several Game Objects and adds them to this group.
     *
     * If the group becomes {@link Phaser.GameObjects.Group#isFull}, no further Game Objects are created.
     *
     * Calls {@link Phaser.GameObjects.Group#createMultipleCallback} and {@link Phaser.GameObjects.Group#createCallback}.
     * @param config Creation settings. This can be a single configuration object or an array of such objects, which will be applied in turn.
     */
    createMultiple(config: Phaser.Types.GameObjects.Group.GroupCreateConfig | Phaser.Types.GameObjects.Group.GroupCreateConfig[]): any[];

    /**
     * A helper for {@link Phaser.GameObjects.Group#createMultiple}.
     * @param options Creation settings.
     */
    createFromConfig(options: Phaser.Types.GameObjects.Group.GroupCreateConfig): any[];

    /**
     * Updates any group members, if {@link Phaser.GameObjects.Group#runChildUpdate} is enabled.
     * @param time The current timestamp.
     * @param delta The delta time elapsed since the last frame.
     */
    preUpdate(time: number, delta: number): void;

    /**
     * Adds a Game Object to this group.
     *
     * Calls {@link Phaser.GameObjects.Group#createCallback}.
     * @param child The Game Object to add.
     * @param addToScene Also add the Game Object to the scene. Default false.
     */
    add(child: Phaser.GameObjects.GameObject, addToScene?: boolean): this;

    /**
     * Adds several Game Objects to this group.
     *
     * Calls {@link Phaser.GameObjects.Group#createCallback}.
     * @param children The Game Objects to add.
     * @param addToScene Also add the Game Objects to the scene. Default false.
     */
    addMultiple(children: Phaser.GameObjects.GameObject[], addToScene?: boolean): this;

    /**
     * Removes a member of this Group and optionally removes it from the Scene and / or destroys it.
     *
     * Calls {@link Phaser.GameObjects.Group#removeCallback}.
     * @param child The Game Object to remove.
     * @param removeFromScene Optionally remove the Group member from the Scene it belongs to. Default false.
     * @param destroyChild Optionally call destroy on the removed Group member. Default false.
     */
    remove(child: Phaser.GameObjects.GameObject, removeFromScene?: boolean, destroyChild?: boolean): this;

    /**
     * Removes all members of this Group and optionally removes them from the Scene and / or destroys them.
     *
     * Does not call {@link Phaser.GameObjects.Group#removeCallback}.
     * @param removeFromScene Optionally remove each Group member from the Scene. Default false.
     * @param destroyChild Optionally call destroy on the removed Group members. Default false.
     */
    clear(removeFromScene?: boolean, destroyChild?: boolean): this;

    /**
     * Tests if a Game Object is a member of this group.
     * @param child A Game Object.
     */
    contains(child: Phaser.GameObjects.GameObject): boolean;

    /**
     * All members of the group.
     */
    getChildren(): Phaser.GameObjects.GameObject[];

    /**
     * The number of members of the group.
     */
    getLength(): number;

    /**
     * Returns all children in this Group that match the given criteria based on the `property` and `value` arguments.
     *
     * For example: `getMatching('visible', true)` would return only children that have their `visible` property set.
     *
     * Optionally, you can specify a start and end index. For example if the Group has 100 elements,
     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
     * the first 50.
     * @param property The property to test on each array element.
     * @param value The value to test the property against. Must pass a strict (`===`) comparison check.
     * @param startIndex An optional start index to search from.
     * @param endIndex An optional end index to search to.
     */
    getMatching(property?: string, value?: any, startIndex?: number, endIndex?: number): any[];

    /**
     * Scans the Group, from top to bottom, for the first member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
     * assigns `x` and `y`, and returns the member.
     *
     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
     * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
     * @param x The horizontal position of the Game Object in the world.
     * @param y The vertical position of the Game Object in the world.
     * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
     * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
     * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
     */
    getFirst(state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | number, visible?: boolean): any;

    /**
     * Scans the Group, from top to bottom, for the nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
     * assigns `x` and `y`, and returns the member.
     *
     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     * @param nth The nth matching Group member to search for.
     * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
     * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
     * @param x The horizontal position of the Game Object in the world.
     * @param y The vertical position of the Game Object in the world.
     * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
     * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
     * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
     */
    getFirstNth(nth: number, state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | number, visible?: boolean): any;

    /**
     * Scans the Group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
     * assigns `x` and `y`, and returns the member.
     *
     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
     * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
     * @param x The horizontal position of the Game Object in the world.
     * @param y The vertical position of the Game Object in the world.
     * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
     * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
     * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
     */
    getLast(state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | number, visible?: boolean): any;

    /**
     * Scans the Group for the last nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
     * assigns `x` and `y`, and returns the member.
     *
     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     * @param nth The nth matching Group member to search for.
     * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
     * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
     * @param x The horizontal position of the Game Object in the world.
     * @param y The vertical position of the Game Object in the world.
     * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
     * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
     * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
     */
    getLastNth(nth: number, state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | number, visible?: boolean): any;

    /**
     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,
     * assigns `x` and `y`, and returns the member.
     *
     * If no inactive member is found and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * The new Game Object will have its active state set to `true`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     * @param x The horizontal position of the Game Object in the world.
     * @param y The vertical position of the Game Object in the world.
     * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
     * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
     * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
     */
    get(x?: number, y?: number, key?: string, frame?: string | number, visible?: boolean): any;

    /**
     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `true`,
     * assigns `x` and `y`, and returns the member.
     *
     * If no active member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
     * @param x The horizontal position of the Game Object in the world.
     * @param y The vertical position of the Game Object in the world.
     * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
     * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
     * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
     */
    getFirstAlive(createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | number, visible?: boolean): any;

    /**
     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,
     * assigns `x` and `y`, and returns the member.
     *
     * If no inactive member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.
     * The new Game Object will have an active state set to `true`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
     * @param x The horizontal position of the Game Object in the world.
     * @param y The vertical position of the Game Object in the world.
     * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
     * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
     * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
     */
    getFirstDead(createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | number, visible?: boolean): any;

    /**
     * {@link Phaser.GameObjects.Components.Animation#play Plays} an animation for all members of this group.
     * @param key The string-based key of the animation to play.
     * @param startFrame Optionally start the animation playing from this frame index. Default 0.
     */
    playAnimation(key: string, startFrame?: string): this;

    /**
     * Whether this group's size at its {@link Phaser.GameObjects.Group#maxSize maximum}.
     */
    isFull(): boolean;

    /**
     * Counts the number of active (or inactive) group members.
     * @param value Count active (true) or inactive (false) group members. Default true.
     */
    countActive(value?: boolean): number;

    /**
     * Counts the number of in-use (active) group members.
     */
    getTotalUsed(): number;

    /**
     * The difference of {@link Phaser.GameObjects.Group#maxSize} and the number of active group members.
     *
     * This represents the number of group members that could be created or reactivated before reaching the size limit.
     */
    getTotalFree(): number;

    /**
     * Sets the `active` property of this Group.
     * When active, this Group runs its `preUpdate` method.
     * @param value True if this Group should be set as active, false if not.
     */
    setActive(value: boolean): this;

    /**
     * Sets the `name` property of this Group.
     * The `name` property is not populated by Phaser and is presented for your own use.
     * @param value The name to be given to this Group.
     */
    setName(value: string): this;

    /**
     * Sets the property as defined in `key` of each group member to the given value.
     * @param key The property to be updated.
     * @param value The amount to set the property to.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     * @param index An optional offset to start searching from within the items array. Default 0.
     * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
     */
    propertyValueSet(key: string, value: number, step?: number, index?: number, direction?: number): this;

    /**
     * Adds the given value to the property as defined in `key` of each group member.
     * @param key The property to be updated.
     * @param value The amount to set the property to.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     * @param index An optional offset to start searching from within the items array. Default 0.
     * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
     */
    propertyValueInc(key: string, value: number, step?: number, index?: number, direction?: number): this;

    /**
     * Sets the x of each group member.
     * @param value The amount to set the property to.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     */
    setX(value: number, step?: number): this;

    /**
     * Sets the y of each group member.
     * @param value The amount to set the property to.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     */
    setY(value: number, step?: number): this;

    /**
     * Sets the x, y of each group member.
     * @param x The amount to set the `x` property to.
     * @param y The amount to set the `y` property to. If `undefined` or `null` it uses the `x` value. Default x.
     * @param stepX This is added to the `x` amount, multiplied by the iteration counter. Default 0.
     * @param stepY This is added to the `y` amount, multiplied by the iteration counter. Default 0.
     */
    setXY(x: number, y?: number, stepX?: number, stepY?: number): this;

    /**
     * Adds the given value to the x of each group member.
     * @param value The amount to be added to the `x` property.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     */
    incX(value: number, step?: number): this;

    /**
     * Adds the given value to the y of each group member.
     * @param value The amount to be added to the `y` property.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     */
    incY(value: number, step?: number): this;

    /**
     * Adds the given value to the x, y of each group member.
     * @param x The amount to be added to the `x` property.
     * @param y The amount to be added to the `y` property. If `undefined` or `null` it uses the `x` value. Default x.
     * @param stepX This is added to the `x` amount, multiplied by the iteration counter. Default 0.
     * @param stepY This is added to the `y` amount, multiplied by the iteration counter. Default 0.
     */
    incXY(x: number, y?: number, stepX?: number, stepY?: number): this;

    /**
     * Iterate through the group members changing the position of each element to be that of the element that came before
     * it in the array (or after it if direction = 1)
     *
     * The first group member position is set to x/y.
     * @param x The x coordinate to place the first item in the array at.
     * @param y The y coordinate to place the first item in the array at.
     * @param direction The iteration direction. 0 = first to last and 1 = last to first. Default 0.
     */
    shiftPosition(x: number, y: number, direction?: number): this;

    /**
     * Sets the angle of each group member.
     * @param value The amount to set the angle to, in degrees.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     */
    angle(value: number, step?: number): this;

    /**
     * Sets the rotation of each group member.
     * @param value The amount to set the rotation to, in radians.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     */
    rotate(value: number, step?: number): this;

    /**
     * Rotates each group member around the given point by the given angle.
     * @param point Any object with public `x` and `y` properties.
     * @param angle The angle to rotate by, in radians.
     */
    rotateAround(point: Phaser.Types.Math.Vector2Like, angle: number): this;

    /**
     * Rotates each group member around the given point by the given angle and distance.
     * @param point Any object with public `x` and `y` properties.
     * @param angle The angle to rotate by, in radians.
     * @param distance The distance from the point of rotation in pixels.
     */
    rotateAroundDistance(point: Phaser.Types.Math.Vector2Like, angle: number, distance: number): this;

    /**
     * Sets the alpha of each group member.
     * @param value The amount to set the alpha to.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     */
    setAlpha(value: number, step?: number): this;

    /**
     * Sets the tint of each group member.
     * @param topLeft The tint being applied to top-left corner of item. If other parameters are given no value, this tint will be applied to whole item.
     * @param topRight The tint to be applied to top-right corner of item.
     * @param bottomLeft The tint to be applied to the bottom-left corner of item.
     * @param bottomRight The tint to be applied to the bottom-right corner of item.
     */
    setTint(topLeft: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets the originX, originY of each group member.
     * @param originX The amount to set the `originX` property to.
     * @param originY The amount to set the `originY` property to. If `undefined` or `null` it uses the `originX` value.
     * @param stepX This is added to the `originX` amount, multiplied by the iteration counter. Default 0.
     * @param stepY This is added to the `originY` amount, multiplied by the iteration counter. Default 0.
     */
    setOrigin(originX: number, originY?: number, stepX?: number, stepY?: number): this;

    /**
     * Sets the scaleX of each group member.
     * @param value The amount to set the property to.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     */
    scaleX(value: number, step?: number): this;

    /**
     * Sets the scaleY of each group member.
     * @param value The amount to set the property to.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     */
    scaleY(value: number, step?: number): this;

    /**
     * Sets the scaleX, scaleY of each group member.
     * @param scaleX The amount to be added to the `scaleX` property.
     * @param scaleY The amount to be added to the `scaleY` property. If `undefined` or `null` it uses the `scaleX` value.
     * @param stepX This is added to the `scaleX` amount, multiplied by the iteration counter. Default 0.
     * @param stepY This is added to the `scaleY` amount, multiplied by the iteration counter. Default 0.
     */
    scaleXY(scaleX: number, scaleY?: number, stepX?: number, stepY?: number): this;

    /**
     * Sets the depth of each group member.
     * @param value The amount to set the property to.
     * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
     */
    setDepth(value: number, step?: number): this;

    /**
     * Sets the blendMode of each group member.
     * @param value The amount to set the property to.
     */
    setBlendMode(value: number): this;

    /**
     * Passes all group members to the Input Manager to enable them for input with identical areas and callbacks.
     * @param hitArea Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
     * @param hitAreaCallback A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.
     */
    setHitArea(hitArea: any, hitAreaCallback: Phaser.Types.Input.HitAreaCallback): this;

    /**
     * Shuffles the group members in place.
     */
    shuffle(): this;

    /**
     * Deactivates a member of this group.
     * @param gameObject A member of this group.
     */
    kill(gameObject: Phaser.GameObjects.GameObject): void;

    /**
     * Deactivates and hides a member of this group.
     * @param gameObject A member of this group.
     */
    killAndHide(gameObject: Phaser.GameObjects.GameObject): void;

    /**
     * Sets the visible of each group member.
     * @param value The value to set the property to.
     * @param index An optional offset to start searching from within the items array. Default 0.
     * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
     */
    setVisible(value: boolean, index?: number, direction?: number): this;

    /**
     * Toggles (flips) the visible state of each member of this group.
     */
    toggleVisible(): this;

    /**
     * Empties this Group of all children and removes it from the Scene.
     *
     * Does not call {@link Phaser.GameObjects.Group#removeCallback}.
     *
     * Children of this Group will _not_ be removed from the Scene by calling this method
     * unless you specify the `removeFromScene` parameter.
     *
     * Children of this Group will also _not_ be destroyed by calling this method
     * unless you specify the `destroyChildren` parameter.
     * @param destroyChildren Also {@link Phaser.GameObjects.GameObject#destroy} each Group member. Default false.
     * @param removeFromScene Optionally remove each Group member from the Scene. Default false.
     */
    destroy(destroyChildren?: boolean, removeFromScene?: boolean): void;

  }

  /**
   * An Image Game Object.
   *
   * An Image is a light-weight Game Object useful for the display of static images in your game,
   * such as logos, backgrounds, scenery or other non-animated elements. Images can have input
   * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an
   * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.
   */
  class Image extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.TextureCrop, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     */
    constructor(scene: Phaser.Scene, x: number, y: number, texture: string | Phaser.Textures.Texture, frame?: string | number);

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The horizontally flipped state of the Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipX: boolean;

    /**
     * The vertically flipped state of the Game Object.
     *
     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipY: boolean;

    /**
     * Toggles the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    toggleFlipX(): this;

    /**
     * Toggles the vertical flipped state of this Game Object.
     */
    toggleFlipY(): this;

    /**
     * Sets the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipX(value: boolean): this;

    /**
     * Sets the vertical flipped state of this Game Object.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipY(value: boolean): this;

    /**
     * Sets the horizontal and vertical flipped state of this Game Object.
     *
     * A Game Object that is flipped will render inversed on the flipped axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlip(x: boolean, y: boolean): this;

    /**
     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
     */
    resetFlip(): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the size of this Game Object to be that of the given Frame.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param frame The frame to base the size of this Game Object on.
     */
    setSizeToFrame(frame: Phaser.Textures.Frame): this;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * A boolean flag indicating if this Game Object is being cropped or not.
     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
     */
    isCropped: boolean;

    /**
     * Applies a crop to a texture based Game Object, such as a Sprite or Image.
     *
     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
     *
     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
     * changes what is shown when rendered.
     *
     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
     *
     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
     * half of it, you could call `setCrop(0, 0, 400, 600)`.
     *
     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
     *
     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
     *
     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
     *
     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
     * the renderer to skip several internal calculations.
     * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
     * @param y The y coordinate to start the crop from.
     * @param width The width of the crop rectangle in pixels.
     * @param height The height of the crop rectangle in pixels.
     */
    setCrop(x?: number | Phaser.Geom.Rectangle, y?: number, width?: number, height?: number): this;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     * @param frame The name or index of the frame within the Texture.
     * @param updateSize Should this call adjust the size of the Game Object? Default true.
     * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
     */
    setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;

    /**
     * The tint value being applied to the top-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopLeft: number;

    /**
     * The tint value being applied to the top-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopRight: number;

    /**
     * The tint value being applied to the bottom-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomLeft: number;

    /**
     * The tint value being applied to the bottom-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomRight: number;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * Clears all tint values associated with this Game Object.
     *
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     */
    clearTint(): this;

    /**
     * Sets an additive tint on this Game Object.
     *
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a fill-based tint on this Game Object.
     *
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     */
    tint: number;

    /**
     * Does this Game Object have a tint applied?
     *
     * It checks to see if the 4 tint properties are set to the value 0xffffff
     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
     */
    readonly isTinted: boolean;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * A Layer Game Object.
   *
   * A Layer is a special type of Game Object that acts as a Display List. You can add any type of Game Object
   * to a Layer, just as you would to a Scene. Layers can be used to visually group together 'layers' of Game
   * Objects:
   *
   * ```javascript
   * const spaceman = this.add.sprite(150, 300, 'spaceman');
   * const bunny = this.add.sprite(400, 300, 'bunny');
   * const elephant = this.add.sprite(650, 300, 'elephant');
   *
   * const layer = this.add.layer();
   *
   * layer.add([ spaceman, bunny, elephant ]);
   * ```
   *
   * The 3 sprites in the example above will now be managed by the Layer they were added to. Therefore,
   * if you then set `layer.setVisible(false)` they would all vanish from the display.
   *
   * You can also control the depth of the Game Objects within the Layer. For example, calling the
   * `setDepth` method of a child of a Layer will allow you to adjust the depth of that child _within the
   * Layer itself_, rather than the whole Scene. The Layer, too, can have its depth set as well.
   *
   * The Layer class also offers many different methods for manipulating the list, such as the
   * methods `moveUp`, `moveDown`, `sendToBack`, `bringToTop` and so on. These allow you to change the
   * display list position of the Layers children, causing it to adjust the order in which they are
   * rendered. Using `setDepth` on a child allows you to override this.
   *
   * Layers can have Post FX Pipelines set, which allows you to easily enable a post pipeline across
   * a whole range of children, which, depending on the effect, can often be far more efficient that doing so
   * on a per-child basis.
   *
   * Layers have no position or size within the Scene. This means you cannot enable a Layer for
   * physics or input, or change the position, rotation or scale of a Layer. They also have no scroll
   * factor, texture, tint, origin, crop or bounds.
   *
   * If you need those kind of features then you should use a Container instead. Containers can be added
   * to Layers, but Layers cannot be added to Containers.
   *
   * However, you can set the Alpha, Blend Mode, Depth, Mask and Visible state of a Layer. These settings
   * will impact all children being rendered by the Layer.
   */
  class Layer extends Phaser.Structs.List<Phaser.GameObjects.GameObject> implements Phaser.GameObjects.Components.AlphaSingle, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param children An optional array of Game Objects to add to this Layer.
     */
    constructor(scene: Phaser.Scene, children?: Phaser.GameObjects.GameObject[]);

    /**
     * A reference to the Scene to which this Game Object belongs.
     *
     * Game Objects can only belong to one Scene.
     *
     * You should consider this property as being read-only. You cannot move a
     * Game Object to another Scene by simply changing it.
     */
    scene: Phaser.Scene;

    /**
     * Holds a reference to the Display List that contains this Game Object.
     *
     * This is set automatically when this Game Object is added to a Scene or Layer.
     *
     * You should treat this property as being read-only.
     */
    displayList: Phaser.GameObjects.DisplayList | Phaser.GameObjects.Layer;

    /**
     * A textual representation of this Game Object, i.e. `sprite`.
     * Used internally by Phaser but is available for your own custom classes to populate.
     */
    type: string;

    /**
     * The current state of this Game Object.
     *
     * Phaser itself will never modify this value, although plugins may do so.
     *
     * Use this property to track the state of a Game Object during its lifetime. For example, it could change from
     * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant
     * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.
     * If you need to store complex data about your Game Object, look at using the Data Component instead.
     */
    state: number | string;

    /**
     * A Layer cannot be placed inside a Container.
     *
     * This property is kept purely so a Layer has the same
     * shape as a Game Object.
     */
    parentContainer: Phaser.GameObjects.Container;

    /**
     * The name of this Game Object.
     * Empty by default and never populated by Phaser, this is left for developers to use.
     */
    name: string;

    /**
     * The active state of this Game Object.
     * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.
     * An active object is one which is having its logic and internal systems updated.
     */
    active: boolean;

    /**
     * The Tab Index of the Game Object.
     * Reserved for future use by plugins and the Input Manager.
     */
    tabIndex: number;

    /**
     * A Data Manager.
     * It allows you to store, query and get key/value paired information specific to this Game Object.
     * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.
     */
    data: Phaser.Data.DataManager;

    /**
     * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.
     * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.
     * If those components are not used by your custom class then you can use this bitmask as you wish.
     */
    renderFlags: number;

    /**
     * A bitmask that controls if this Game Object is drawn by a Camera or not.
     * Not usually set directly, instead call `Camera.ignore`, however you can
     * set this property directly using the Camera.id property:
     */
    cameraFilter: number;

    /**
     * This property is kept purely so a Layer has the same
     * shape as a Game Object. You cannot input enable a Layer.
     */
    input: Phaser.Types.Input.InteractiveObject;

    /**
     * This property is kept purely so a Layer has the same
     * shape as a Game Object. You cannot give a Layer a physics body.
     */
    body: Phaser.Physics.Arcade.Body | Phaser.Physics.Arcade.StaticBody | MatterJS.BodyType;

    /**
     * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.
     * This includes calls that may come from a Group, Container or the Scene itself.
     * While it allows you to persist a Game Object across Scenes, please understand you are entirely
     * responsible for managing references to and from this Game Object.
     */
    ignoreDestroy: boolean;

    /**
     * A reference to the Scene Systems.
     */
    systems: Phaser.Scenes.Systems;

    /**
     * A reference to the Scene Event Emitter.
     */
    events: Phaser.Events.EventEmitter;

    /**
     * The flag the determines whether Game Objects should be sorted when `depthSort()` is called.
     */
    sortChildrenFlag: boolean;

    /**
     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.
     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.
     * @param value True if this Game Object should be set as active, false if not.
     */
    setActive(value: boolean): this;

    /**
     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.
     * The `name` property is not populated by Phaser and is presented for your own use.
     * @param value The name to be given to this Game Object.
     */
    setName(value: string): this;

    /**
     * Sets the current state of this Game Object.
     *
     * Phaser itself will never modify the State of a Game Object, although plugins may do so.
     *
     * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.
     * The state value should typically be an integer (ideally mapped to a constant
     * in your game code), but could also be a string. It is recommended to keep it light and simple.
     * If you need to store complex data about your Game Object, look at using the Data Component instead.
     * @param value The state of the Game Object.
     */
    setState(value: number | string): this;

    /**
     * Adds a Data Manager component to this Game Object.
     */
    setDataEnabled(): this;

    /**
     * Allows you to store a key value pair within this Game Objects Data Manager.
     *
     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled
     * before setting the value.
     *
     * If the key doesn't already exist in the Data Manager then it is created.
     *
     * ```javascript
     * sprite.setData('name', 'Red Gem Stone');
     * ```
     *
     * You can also pass in an object of key value pairs as the first argument:
     *
     * ```javascript
     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });
     * ```
     *
     * To get a value back again you can call `getData`:
     *
     * ```javascript
     * sprite.getData('gold');
     * ```
     *
     * Or you can access the value directly via the `values` property, where it works like any other variable:
     *
     * ```javascript
     * sprite.data.values.gold += 50;
     * ```
     *
     * When the value is first set, a `setdata` event is emitted from this Game Object.
     *
     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.
     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.
     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.
     *
     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.
     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.
     * @param key The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.
     * @param data The value to set for the given key. If an object is provided as the key this argument is ignored.
     */
    setData(key: string | object, data?: any): this;

    /**
     * Increase a value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is increased from 0.
     *
     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled
     * before setting the value.
     *
     * If the key doesn't already exist in the Data Manager then it is created.
     *
     * When the value is first set, a `setdata` event is emitted from this Game Object.
     * @param key The key to increase the value for.
     * @param data The value to increase for the given key.
     */
    incData(key: string | object, data?: any): this;

    /**
     * Toggle a boolean value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is toggled from false.
     *
     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled
     * before setting the value.
     *
     * If the key doesn't already exist in the Data Manager then it is created.
     *
     * When the value is first set, a `setdata` event is emitted from this Game Object.
     * @param key The key to toggle the value for.
     */
    toggleData(key: string | object): this;

    /**
     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.
     *
     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:
     *
     * ```javascript
     * sprite.getData('gold');
     * ```
     *
     * Or access the value directly:
     *
     * ```javascript
     * sprite.data.values.gold;
     * ```
     *
     * You can also pass in an array of keys, in which case an array of values will be returned:
     *
     * ```javascript
     * sprite.getData([ 'gold', 'armor', 'health' ]);
     * ```
     *
     * This approach is useful for destructuring arrays in ES6.
     * @param key The key of the value to retrieve, or an array of keys.
     */
    getData(key: string | string[]): any;

    /**
     * A Layer cannot be enabled for input.
     *
     * This method does nothing and is kept to ensure
     * the Layer has the same shape as a Game Object.
     */
    setInteractive(): this;

    /**
     * A Layer cannot be enabled for input.
     *
     * This method does nothing and is kept to ensure
     * the Layer has the same shape as a Game Object.
     */
    disableInteractive(): this;

    /**
     * A Layer cannot be enabled for input.
     *
     * This method does nothing and is kept to ensure
     * the Layer has the same shape as a Game Object.
     */
    removeInteractive(): this;

    /**
     * This callback is invoked when this Game Object is added to a Scene.
     *
     * Can be overriden by custom Game Objects, but be aware of some Game Objects that
     * will use this, such as Sprites, to add themselves into the Update List.
     *
     * You can also listen for the `ADDED_TO_SCENE` event from this Game Object.
     */
    addedToScene(): void;

    /**
     * This callback is invoked when this Game Object is removed from a Scene.
     *
     * Can be overriden by custom Game Objects, but be aware of some Game Objects that
     * will use this, such as Sprites, to removed themselves from the Update List.
     *
     * You can also listen for the `REMOVED_FROM_SCENE` event from this Game Object.
     */
    removedFromScene(): void;

    /**
     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.
     * @param args args
     */
    update(...args: any[]): void;

    /**
     * Returns a JSON representation of the Game Object.
     */
    toJSON(): Phaser.Types.GameObjects.JSONGameObject;

    /**
     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
     * Also checks the Game Object against the given Cameras exclusion list.
     * @param camera The Camera to check against this Game Object.
     */
    willRender(camera: Phaser.Cameras.Scene2D.Camera): boolean;

    /**
     * Returns an array containing the display list index of either this Game Object, or if it has one,
     * its parent Container. It then iterates up through all of the parent containers until it hits the
     * root of the display list (which is index 0 in the returned array).
     *
     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of
     * this Game Object and all of its ancestors.
     */
    getIndexList(): number[];

    /**
     * Force a sort of the display list on the next call to depthSort.
     */
    queueDepthSort(): void;

    /**
     * Immediately sorts the display list if the flag is set.
     */
    depthSort(): void;

    /**
     * Compare the depth of two Game Objects.
     * @param childA The first Game Object.
     * @param childB The second Game Object.
     */
    sortByDepth(childA: Phaser.GameObjects.GameObject, childB: Phaser.GameObjects.GameObject): number;

    /**
     * Returns an array which contains all Game Objects within this Layer.
     *
     * This is a reference to the main list array, not a copy of it, so be careful not to modify it.
     */
    getChildren(): Phaser.GameObjects.GameObject[];

    /**
     * Destroys this Layer removing it from the Display List and Update List and
     * severing all ties to parent resources.
     *
     * Also destroys all children of this Layer. If you do not wish for the
     * children to be destroyed, you should move them from this Layer first.
     *
     * Use this to remove this Layer from your game if you don't ever plan to use it again.
     * As long as no reference to it exists within your own code it should become free for
     * garbage collection by the browser.
     *
     * If you just want to temporarily disable an object then look at using the
     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.
     */
    destroy(): void;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * A 2D point light.
   *
   * These are typically created by a {@link Phaser.GameObjects.LightsManager}, available from within a scene via `this.lights`.
   *
   * Any Game Objects using the Light2D pipeline will then be affected by these Lights as long as they have a normal map.
   *
   * They can also simply be used to represent a point light for your own purposes.
   */
  class Light extends Phaser.Geom.Circle implements Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param x The horizontal position of the light.
     * @param y The vertical position of the light.
     * @param radius The radius of the light.
     * @param r The red color of the light. A value between 0 and 1.
     * @param g The green color of the light. A value between 0 and 1.
     * @param b The blue color of the light. A value between 0 and 1.
     * @param intensity The intensity of the light.
     */
    constructor(x: number, y: number, radius: number, r: number, g: number, b: number, intensity: number);

    /**
     * The color of the light.
     */
    color: Phaser.Display.RGB;

    /**
     * The intensity of the light.
     */
    intensity: number;

    /**
     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
     * Also checks the Game Object against the given Cameras exclusion list.
     * @param camera The Camera to check against this Game Object.
     */
    willRender(camera: Phaser.Cameras.Scene2D.Camera): boolean;

    /**
     * Set the color of the light from a single integer RGB value.
     * @param rgb The integer RGB color of the light.
     */
    setColor(rgb: number): this;

    /**
     * Set the intensity of the light.
     * @param intensity The intensity of the light.
     */
    setIntensity(intensity: number): this;

    /**
     * Set the radius of the light.
     * @param radius The radius of the light.
     */
    setRadius(radius: number): this;

    /**
     * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.
     */
    static readonly RENDER_MASK: number;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * Manages Lights for a Scene.
   *
   * Affects the rendering of Game Objects using the `Light2D` pipeline.
   */
  class LightsManager {
    /**
     * The Lights in the Scene.
     */
    lights: Phaser.GameObjects.Light[];

    /**
     * The ambient color.
     */
    ambientColor: Phaser.Display.RGB;

    /**
     * Whether the Lights Manager is enabled.
     */
    active: boolean;

    /**
     * The maximum number of lights that a single Camera and the lights shader can process.
     * Change this via the `maxLights` property in your game config, as it cannot be changed at runtime.
     */
    readonly maxLights: number;

    /**
     * The number of lights that the LightPipeline processed in the _previous_ frame.
     */
    readonly visibleLights: number;

    /**
     * Creates a new Point Light Game Object and adds it to the Scene.
     *
     * Note: This method will only be available if the Point Light Game Object has been built into Phaser.
     *
     * The Point Light Game Object provides a way to add a point light effect into your game,
     * without the expensive shader processing requirements of the traditional Light Game Object.
     *
     * The difference is that the Point Light renders using a custom shader, designed to give the
     * impression of a point light source, of variable radius, intensity and color, in your game.
     * However, unlike the Light Game Object, it does not impact any other Game Objects, or use their
     * normal maps for calcuations. This makes them extremely fast to render compared to Lights
     * and perfect for special effects, such as flickering torches or muzzle flashes.
     *
     * For maximum performance you should batch Point Light Game Objects together. This means
     * ensuring they follow each other consecutively on the display list. Ideally, use a Layer
     * Game Object and then add just Point Lights to it, so that it can batch together the rendering
     * of the lights. You don't _have_ to do this, and if you've only a handful of Point Lights in
     * your game then it's perfectly safe to mix them into the dislay list as normal. However, if
     * you're using a large number of them, please consider how they are mixed into the display list.
     *
     * The renderer will automatically cull Point Lights. Those with a radius that does not intersect
     * with the Camera will be skipped in the rendering list. This happens automatically and the
     * culled state is refreshed every frame, for every camera.
     *
     * The origin of a Point Light is always 0.5 and it cannot be changed.
     *
     * Point Lights are a WebGL only feature and do not have a Canvas counterpart.
     * @param x The horizontal position of this Point Light in the world.
     * @param y The vertical position of this Point Light in the world.
     * @param color The color of the Point Light, given as a hex value. Default 0xffffff.
     * @param radius The radius of the Point Light. Default 128.
     * @param intensity The intensity, or colr blend, of the Point Light. Default 1.
     * @param attenuation The attenuation  of the Point Light. This is the reduction of light from the center point. Default 0.1.
     */
    addPointLight(x: number, y: number, color?: number, radius?: number, intensity?: number, attenuation?: number): Phaser.GameObjects.PointLight;

    /**
     * Enable the Lights Manager.
     */
    enable(): this;

    /**
     * Disable the Lights Manager.
     */
    disable(): this;

    /**
     * Get all lights that can be seen by the given Camera.
     *
     * It will automatically cull lights that are outside the world view of the Camera.
     *
     * If more lights are returned than supported by the pipeline, the lights are then culled
     * based on the distance from the center of the camera. Only those closest are rendered.
     * @param camera The Camera to cull Lights for.
     */
    getLights(camera: Phaser.Cameras.Scene2D.Camera): Phaser.GameObjects.Light[];

    /**
     * Set the ambient light color.
     * @param rgb The integer RGB color of the ambient light.
     */
    setAmbientColor(rgb: number): this;

    /**
     * Returns the maximum number of Lights allowed to appear at once.
     */
    getMaxVisibleLights(): number;

    /**
     * Get the number of Lights managed by this Lights Manager.
     */
    getLightCount(): number;

    /**
     * Add a Light.
     * @param x The horizontal position of the Light. Default 0.
     * @param y The vertical position of the Light. Default 0.
     * @param radius The radius of the Light. Default 128.
     * @param rgb The integer RGB color of the light. Default 0xffffff.
     * @param intensity The intensity of the Light. Default 1.
     */
    addLight(x?: number, y?: number, radius?: number, rgb?: number, intensity?: number): Phaser.GameObjects.Light;

    /**
     * Remove a Light.
     * @param light The Light to remove.
     */
    removeLight(light: Phaser.GameObjects.Light): this;

    /**
     * Shut down the Lights Manager.
     *
     * Recycles all active Lights into the Light pool, resets ambient light color and clears the lists of Lights and
     * culled Lights.
     */
    shutdown(): void;

    /**
     * Destroy the Lights Manager.
     *
     * Cleans up all references by calling {@link Phaser.GameObjects.LightsManager#shutdown}.
     */
    destroy(): void;

  }

  /**
   * A Scene plugin that provides a {@link Phaser.GameObjects.LightsManager} for the Light2D pipeline.
   *
   * Available from within a Scene via `this.lights`.
   *
   * Add Lights using the {@link Phaser.GameObjects.LightsManager#addLight} method:
   *
   * ```javascript
   * // Enable the Lights Manager because it is disabled by default
   * this.lights.enable();
   *
   * // Create a Light at [400, 300] with a radius of 200
   * this.lights.addLight(400, 300, 200);
   * ```
   *
   * For Game Objects to be affected by the Lights when rendered, you will need to set them to use the `Light2D` pipeline like so:
   *
   * ```javascript
   * sprite.setPipeline('Light2D');
   * ```
   *
   * Note that you cannot use this pipeline on Graphics Game Objects or Shape Game Objects.
   */
  class LightsPlugin extends Phaser.GameObjects.LightsManager {
    /**
     *
     * @param scene The Scene that this Lights Plugin belongs to.
     */
    constructor(scene: Phaser.Scene);

    /**
     * A reference to the Scene that this Lights Plugin belongs to.
     */
    scene: Phaser.Scene;

    /**
     * A reference to the Scene's systems.
     */
    systems: Phaser.Scenes.Systems;

    /**
     * Boot the Lights Plugin.
     */
    boot(): void;

    /**
     * Destroy the Lights Plugin.
     *
     * Cleans up all references.
     */
    destroy(): void;

  }

  /**
   * A Mesh Game Object.
   *
   * The Mesh Game Object allows you to render a group of textured vertices and manipulate
   * the view of those vertices, such as rotation, translation or scaling.
   *
   * Support for generating mesh data from grids, model data or Wavefront OBJ Files is included.
   *
   * Although you can use this to render 3D objects, its primary use is for displaying more complex
   * Sprites, or Sprites where you need fine-grained control over the vertex positions in order to
   * achieve special effects in your games. Note that rendering still takes place using Phaser's
   * orthographic camera (after being transformed via `projectionMesh`, see `setPerspective`,
   * `setOrtho`, and `panZ` methods). As a result, all depth and face tests are done in an eventually
   * orthographic space.
   *
   * The rendering process will iterate through the faces of this Mesh and render out each face
   * that is considered as being in view of the camera. No depth buffer is used, and because of this,
   * you should be careful not to use model data with too many vertices, or overlapping geometry,
   * or you'll probably encounter z-depth fighting. The Mesh was designed to allow for more advanced
   * 2D layouts, rather than displaying 3D objects, even though it can do this to a degree.
   *
   * In short, if you want to remake Crysis, use a 3D engine, not a Mesh. However, if you want
   * to easily add some small fun 3D elements into your game, or create some special effects involving
   * vertex warping, this is the right object for you. Mesh data becomes part of the WebGL batch,
   * just like standard Sprites, so doesn't introduce any additional shader overhead. Because
   * the Mesh just generates vertices into the WebGL batch, like any other Sprite, you can use all of
   * the common Game Object components on a Mesh too, such as a custom pipeline, mask, blend mode
   * or texture.
   *
   * Note that the Mesh object is WebGL only and does not have a Canvas counterpart.
   *
   * The Mesh origin is always 0.5 x 0.5 and cannot be changed.
   */
  class Mesh extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.AlphaSingle, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible, Phaser.GameObjects.Components.ScrollFactor {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     * @param vertices The vertices array. Either `xy` pairs, or `xyz` if the `containsZ` parameter is `true` (but see note).
     * @param uvs The UVs pairs array.
     * @param indicies Optional vertex indicies array. If you don't have one, pass `null` or an empty array.
     * @param containsZ Does the vertices data include a `z` component? Note: If not, it will be assumed `z=0`, see method `panZ` or `setOrtho`. Default false.
     * @param normals Optional vertex normals array. If you don't have one, pass `null` or an empty array.
     * @param colors An array of colors, one per vertex, or a single color value applied to all vertices. Default 0xffffff.
     * @param alphas An array of alpha values, one per vertex, or a single alpha value applied to all vertices. Default 1.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, texture?: string | Phaser.Textures.Texture, frame?: string | number, vertices?: number[], uvs?: number[], indicies?: number[], containsZ?: boolean, normals?: number[], colors?: number | number[], alphas?: number | number[]);

    /**
     * An array containing the Face instances belonging to this Mesh.
     *
     * A Face consists of 3 Vertex objects.
     *
     * This array is populated during calls such as `addVertices` or `addOBJ`.
     */
    faces: Phaser.Geom.Mesh.Face[];

    /**
     * An array containing Vertex instances. One instance per vertex in this Mesh.
     *
     * This array is populated during calls such as `addVertex` or `addOBJ`.
     */
    vertices: Phaser.Geom.Mesh.Vertex[];

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertex colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * You can optionally choose to render the vertices of this Mesh to a Graphics instance.
     *
     * Achieve this by setting the `debugCallback` and the `debugGraphic` properties.
     *
     * You can do this in a single call via the `Mesh.setDebug` method, which will use the
     * built-in debug function. You can also set it to your own callback. The callback
     * will be invoked _once per render_ and sent the following parameters:
     *
     * `debugCallback(src, meshLength, verts)`
     *
     * `src` is the Mesh instance being debugged.
     * `meshLength` is the number of mesh vertices in total.
     * `verts` is an array of the translated vertex coordinates.
     *
     * To disable rendering, set this property back to `null`.
     *
     * Please note that high vertex count Meshes will struggle to debug properly.
     */
    debugCallback: Function;

    /**
     * The Graphics instance that the debug vertices will be drawn to, if `setDebug` has
     * been called.
     */
    debugGraphic: Phaser.GameObjects.Graphics;

    /**
     * When rendering, skip any Face that isn't counter clockwise?
     *
     * Enable this to hide backward-facing Faces during rendering.
     *
     * Disable it to render all Faces.
     */
    hideCCW: boolean;

    /**
     * A Vector3 containing the 3D position of the vertices in this Mesh.
     *
     * Modifying the components of this property will allow you to reposition where
     * the vertices are rendered within the Mesh. This happens in the `preUpdate` phase,
     * where each vertex is transformed using the view and projection matrices.
     *
     * Changing this property will impact all vertices being rendered by this Mesh.
     *
     * You can also adjust the 'view' by using the `pan` methods.
     */
    modelPosition: Phaser.Math.Vector3;

    /**
     * A Vector3 containing the 3D scale of the vertices in this Mesh.
     *
     * Modifying the components of this property will allow you to scale
     * the vertices within the Mesh. This happens in the `preUpdate` phase,
     * where each vertex is transformed using the view and projection matrices.
     *
     * Changing this property will impact all vertices being rendered by this Mesh.
     */
    modelScale: Phaser.Math.Vector3;

    /**
     * A Vector3 containing the 3D rotation of the vertices in this Mesh.
     *
     * The values should be given in radians, i.e. to rotate the vertices by 90
     * degrees you can use `modelRotation.x = Phaser.Math.DegToRad(90)`.
     *
     * Modifying the components of this property will allow you to rotate
     * the vertices within the Mesh. This happens in the `preUpdate` phase,
     * where each vertex is transformed using the view and projection matrices.
     *
     * Changing this property will impact all vertices being rendered by this Mesh.
     */
    modelRotation: Phaser.Math.Vector3;

    /**
     * The transformation matrix for this Mesh.
     */
    transformMatrix: Phaser.Math.Matrix4;

    /**
     * The view position for this Mesh.
     *
     * Use the methods`panX`, `panY` and `panZ` to adjust the view.
     */
    viewPosition: Phaser.Math.Vector3;

    /**
     * The view matrix for this Mesh.
     */
    viewMatrix: Phaser.Math.Matrix4;

    /**
     * The projection matrix for this Mesh.
     *
     * Update it with the `setPerspective` or `setOrtho` methods.
     */
    projectionMatrix: Phaser.Math.Matrix4;

    /**
     * How many faces were rendered by this Mesh Game Object in the last
     * draw? This is reset in the `preUpdate` method and then incremented
     * each time a face is drawn. Note that in multi-camera Scenes this
     * value may exceed that found in `Mesh.getFaceCount` due to
     * cameras drawing the same faces more than once.
     */
    readonly totalRendered: number;

    /**
     * By default, the Mesh will check to see if its model or view transform has
     * changed each frame and only recalculate the vertex positions if they have.
     *
     * This avoids lots of additional math in the `preUpdate` step when not required.
     *
     * However, if you are performing per-Face or per-Vertex manipulation on this Mesh,
     * such as tweening a Face, or moving it without moving the rest of the Mesh,
     * then you may need to disable the dirty cache in order for the Mesh to re-render
     * correctly. You can toggle this property to do that. Please note that leaving
     * this set to `true` will cause the Mesh to recalculate the position of every single
     * vertex in it, every single frame. So only really do this if you know you
     * need it.
     */
    ignoreDirtyCache: boolean;

    /**
     * Translates the view position of this Mesh on the x axis by the given amount.
     * @param v The amount to pan by.
     */
    panX(v: number): void;

    /**
     * Translates the view position of this Mesh on the y axis by the given amount.
     * @param v The amount to pan by.
     */
    panY(v: number): void;

    /**
     * Translates the view position of this Mesh on the z axis by the given amount.
     *
     * As the default `panZ` value is 0, vertices with `z=0` (the default) need special care or else they will not display as they are behind the camera.
     * Consider using `mesh.panZ(mesh.height / (2 * Math.tan(Math.PI / 16)))`, which will interpret vertex geometry 1:1 with pixel geometry (or see `setOrtho`).
     * @param v The amount to pan by.
     */
    panZ(v: number): void;

    /**
     * Builds a new perspective projection matrix from the given values.
     *
     * These are also the initial projection matrix & parameters for `Mesh` (and see `panZ` for more discussion).
     *
     * See also `setOrtho`.
     * @param width The width of the projection matrix. Typically the same as the Mesh and/or Renderer.
     * @param height The height of the projection matrix. Typically the same as the Mesh and/or Renderer.
     * @param fov The field of view, in degrees. Default 45.
     * @param near The near value of the view. Default 0.01.
     * @param far The far value of the view. Default 1000.
     */
    setPerspective(width: number, height: number, fov?: number, near?: number, far?: number): void;

    /**
     * Builds a new orthographic projection matrix from the given values.
     *
     * If using this mode you will often need to set `Mesh.hideCCW` to `false` as well.
     *
     * By default, calling this method with no parameters will set the scaleX value to
     * match the renderer's aspect ratio. If you would like to render vertex positions 1:1
     * to pixel positions, consider calling as `mesh.setOrtho(mesh.width, mesh.height)`.
     *
     * See also `setPerspective`.
     * @param scaleX The default horizontal scale in relation to the Mesh / Renderer dimensions. Default 1.
     * @param scaleY The default vertical scale in relation to the Mesh / Renderer dimensions. Default 1.
     * @param near The near value of the view. Default -1000.
     * @param far The far value of the view. Default 1000.
     */
    setOrtho(scaleX?: number, scaleY?: number, near?: number, far?: number): void;

    /**
     * Iterates and destroys all current Faces in this Mesh, then resets the
     * `faces` and `vertices` arrays.
     */
    clear(): this;

    /**
     * This method will add the data from a triangulated Wavefront OBJ model file to this Mesh.
     *
     * The data should have been loaded via the OBJFile:
     *
     * ```javascript
     * this.load.obj(key, url);
     * ```
     *
     * Then use the same `key` as the first parameter to this method.
     *
     * Multiple Mesh Game Objects can use the same model data without impacting on each other.
     *
     * Make sure your 3D package has triangulated the model data prior to exporting it.
     *
     * You can add multiple models to a single Mesh, although they will act as one when
     * moved or rotated. You can scale the model data, should it be too small, or too large, to see.
     * You can also offset the vertices of the model via the `x`, `y` and `z` parameters.
     * @param key The key of the model data in the OBJ Cache to add to this Mesh.
     * @param scale An amount to scale the model data by. Use this if the model has exported too small, or large, to see. Default 1.
     * @param x Translate the model x position by this amount. Default 0.
     * @param y Translate the model y position by this amount. Default 0.
     * @param z Translate the model z position by this amount. Default 0.
     * @param rotateX Rotate the model on the x axis by this amount, in radians. Default 0.
     * @param rotateY Rotate the model on the y axis by this amount, in radians. Default 0.
     * @param rotateZ Rotate the model on the z axis by this amount, in radians. Default 0.
     * @param zIsUp Is the z axis up (true), or is y axis up (false)? Default true.
     */
    addVerticesFromObj(key: string, scale?: number, x?: number, y?: number, z?: number, rotateX?: number, rotateY?: number, rotateZ?: number, zIsUp?: boolean): this;

    /**
     * Compare the depth of two Faces.
     * @param faceA The first Face.
     * @param faceB The second Face.
     */
    sortByDepth(faceA: Phaser.Geom.Mesh.Face, faceB: Phaser.Geom.Mesh.Face): number;

    /**
     * Runs a depth sort across all Faces in this Mesh, comparing their averaged depth.
     *
     * This is called automatically if you use any of the `rotate` methods, but you can
     * also invoke it to sort the Faces should you manually position them.
     */
    depthSort(): this;

    /**
     * Adds a new Vertex into the vertices array of this Mesh.
     *
     * Just adding a vertex isn't enough to render it. You need to also
     * make it part of a Face, with 3 Vertex instances per Face.
     * @param x The x position of the vertex.
     * @param y The y position of the vertex.
     * @param z The z position of the vertex.
     * @param u The UV u coordinate of the vertex.
     * @param v The UV v coordinate of the vertex.
     * @param color The color value of the vertex. Default 0xffffff.
     * @param alpha The alpha value of the vertex. Default 1.
     */
    addVertex(x: number, y: number, z: number, u: number, v: number, color?: number, alpha?: number): this;

    /**
     * Adds a new Face into the faces array of this Mesh.
     *
     * A Face consists of references to 3 Vertex instances, which must be provided.
     * @param vertex1 The first vertex of the Face.
     * @param vertex2 The second vertex of the Face.
     * @param vertex3 The third vertex of the Face.
     */
    addFace(vertex1: Phaser.Geom.Mesh.Vertex, vertex2: Phaser.Geom.Mesh.Vertex, vertex3: Phaser.Geom.Mesh.Vertex): this;

    /**
     * Adds new vertices to this Mesh by parsing the given data.
     *
     * This method will take vertex data in one of two formats, based on the `containsZ` parameter.
     *
     * If your vertex data are `x`, `y` pairs, then `containsZ` should be `false` (this is the default, and will result in `z=0` for each vertex).
     *
     * If your vertex data is groups of `x`, `y` and `z` values, then the `containsZ` parameter must be true.
     *
     * The `uvs` parameter is a numeric array consisting of `u` and `v` pairs.
     *
     * The `normals` parameter is a numeric array consisting of `x`, `y` vertex normal values and, if `containsZ` is true, `z` values as well.
     *
     * The `indicies` parameter is an optional array that, if given, is an indexed list of vertices to be added.
     *
     * The `colors` parameter is an optional array, or single value, that if given sets the color of each vertex created.
     *
     * The `alphas` parameter is an optional array, or single value, that if given sets the alpha of each vertex created.
     *
     * When providing indexed data it is assumed that _all_ of the arrays are indexed, not just the vertices.
     *
     * The following example will create a 256 x 256 sized quad using an index array:
     *
     * ```javascript
     * let mesh = new Mesh(this);  // Assuming `this` is a scene!
     * const vertices = [
     *   -128, 128,
     *   128, 128,
     *   -128, -128,
     *   128, -128
     * ];
     *
     * const uvs = [
     *   0, 1,
     *   1, 1,
     *   0, 0,
     *   1, 0
     * ];
     *
     * const indices = [ 0, 2, 1, 2, 3, 1 ];
     *
     * mesh.addVertices(vertices, uvs, indicies);
     * // Note: Otherwise the added points will be "behind" the camera! This value will project vertex `x` & `y` values 1:1 to pixel values.
     * mesh.hideCCW = false;
     * mesh.setOrtho(mesh.width, mesh.height);
     * ```
     *
     * If the data is not indexed, it's assumed that the arrays all contain sequential data.
     * @param vertices The vertices array. Either `xy` pairs, or `xyz` if the `containsZ` parameter is `true`.
     * @param uvs The UVs pairs array.
     * @param indicies Optional vertex indicies array. If you don't have one, pass `null` or an empty array.
     * @param containsZ Does the vertices data include a `z` component? If not, it will be assumed `z=0`, see methods `panZ` or `setOrtho`. Default false.
     * @param normals Optional vertex normals array. If you don't have one, pass `null` or an empty array.
     * @param colors An array of colors, one per vertex, or a single color value applied to all vertices. Default 0xffffff.
     * @param alphas An array of alpha values, one per vertex, or a single alpha value applied to all vertices. Default 1.
     */
    addVertices(vertices: number[], uvs: number[], indicies?: number[], containsZ?: boolean, normals?: number[], colors?: number | number[], alphas?: number | number[]): this;

    /**
     * Returns the total number of Faces in this Mesh Game Object.
     */
    getFaceCount(): number;

    /**
     * Returns the total number of Vertices in this Mesh Game Object.
     */
    getVertexCount(): number;

    /**
     * Returns the Face at the given index in this Mesh Game Object.
     * @param index The index of the Face to get.
     */
    getFace(index: number): Phaser.Geom.Mesh.Face;

    /**
     * Return an array of Face objects from this Mesh that intersect with the given coordinates.
     *
     * The given position is translated through the matrix of this Mesh and the given Camera,
     * before being compared against the vertices.
     *
     * If more than one Face intersects, they will all be returned in the array, but the array will
     * be depth sorted first, so the first element will always be that closest to the camera.
     * @param x The x position to check against.
     * @param y The y position to check against.
     * @param camera The camera to pass the coordinates through. If not give, the default Scene Camera is used.
     */
    getFaceAt(x: number, y: number, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Geom.Mesh.Face[];

    /**
     * This method enables rendering of the Mesh vertices to the given Graphics instance.
     *
     * If you enable this feature, you **must** call `Graphics.clear()` in your Scene `update`,
     * otherwise the Graphics instance you provide to debug will fill-up with draw calls,
     * eventually crashing the browser. This is not done automatically to allow you to debug
     * draw multiple Mesh objects to a single Graphics instance.
     *
     * The Mesh class has a built-in debug rendering callback `Mesh.renderDebug`, however
     * you can also provide your own callback to be used instead. Do this by setting the `callback` parameter.
     *
     * The callback is invoked _once per render_ and sent the following parameters:
     *
     * `callback(src, faces)`
     *
     * `src` is the Mesh instance being debugged.
     * `faces` is an array of the Faces that were rendered.
     *
     * You can get the final drawn vertex position from a Face object like this:
     *
     * ```javascript
     * let face = faces[i];
     *
     * let x0 = face.vertex1.tx;
     * let y0 = face.vertex1.ty;
     * let x1 = face.vertex2.tx;
     * let y1 = face.vertex2.ty;
     * let x2 = face.vertex3.tx;
     * let y2 = face.vertex3.ty;
     *
     * graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);
     * ```
     *
     * If using your own callback you do not have to provide a Graphics instance to this method.
     *
     * To disable debug rendering, to either your own callback or the built-in one, call this method
     * with no arguments.
     * @param graphic The Graphic instance to render to if using the built-in callback.
     * @param callback The callback to invoke during debug render. Leave as undefined to use the built-in callback.
     */
    setDebug(graphic?: Phaser.GameObjects.Graphics, callback?: Function): this;

    /**
     * Checks if the transformation data in this mesh is dirty.
     *
     * This is used internally by the `preUpdate` step to determine if the vertices should
     * be recalculated or not.
     */
    isDirty(): boolean;

    /**
     * The Mesh update loop. The following takes place in this method:
     *
     * First, the `totalRendered` and `totalFrame` properties are set.
     *
     * If the view matrix of this Mesh isn't dirty, and the model position, rotate or scale properties are
     * all clean, then the method returns at this point.
     *
     * Otherwise, if the viewPosition is dirty (i.e. from calling a method like `panZ`), then it will
     * refresh the viewMatrix.
     *
     * After this, a new transformMatrix is built and it then iterates through all Faces in this
     * Mesh, calling `transformCoordinatesLocal` on all of them. Internally, this updates every
     * vertex, calculating its new transformed position, based on the new transform matrix.
     *
     * Finally, the faces are depth sorted.
     * @param time The current timestamp.
     * @param delta The delta time, in ms, elapsed since the last frame.
     */
    protected preUpdate(time: number, delta: number): void;

    /**
     * The built-in Mesh debug rendering method.
     *
     * See `Mesh.setDebug` for more details.
     * @param src The Mesh object being rendered.
     * @param faces An array of Faces.
     */
    renderDebug(src: Phaser.GameObjects.Mesh, faces: Phaser.Geom.Mesh.Face[]): void;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the size of this Game Object to be that of the given Frame.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param frame The frame to base the size of this Game Object on.
     */
    setSizeToFrame(frame: Phaser.Textures.Frame): this;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager, or a Texture instance.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string | Phaser.Textures.Texture, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     * @param frame The name or index of the frame within the Texture.
     * @param updateSize Should this call adjust the size of the Game Object? Default true.
     * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
     */
    setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

  }

  namespace Particles {
    /**
     * A Particle Emitter property.
     *
     * Facilitates changing Particle properties as they are emitted and throughout their lifetime.
     */
    class EmitterOp {
      /**
       *
       * @param config Settings for the Particle Emitter that owns this property.
       * @param key The name of the property.
       * @param defaultValue The default value of the property.
       * @param emitOnly Whether the property can only be modified when a Particle is emitted. Default false.
       */
      constructor(config: Phaser.Types.GameObjects.Particles.ParticleEmitterConfig, key: string, defaultValue: number, emitOnly?: boolean);

      /**
       * The name of this property.
       */
      propertyKey: string;

      /**
       * The value of this property.
       */
      propertyValue: number;

      /**
       * The default value of this property.
       */
      defaultValue: number;

      /**
       * The number of steps for stepped easing between {@link Phaser.GameObjects.Particles.EmitterOp#start} and
       * {@link Phaser.GameObjects.Particles.EmitterOp#end} values, per emit.
       */
      steps: number;

      /**
       * The step counter for stepped easing, per emit.
       */
      counter: number;

      /**
       * The start value for this property to ease between.
       */
      start: number;

      /**
       * The end value for this property to ease between.
       */
      end: number;

      /**
       * The easing function to use for updating this property.
       */
      ease: Function;

      /**
       * Whether this property can only be modified when a Particle is emitted.
       *
       * Set to `true` to allow only {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} callbacks to be set and
       * affect this property.
       *
       * Set to `false` to allow both {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and
       * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks to be set and affect this property.
       */
      emitOnly: boolean;

      /**
       * The callback to run for Particles when they are emitted from the Particle Emitter.
       */
      onEmit: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitCallback;

      /**
       * The callback to run for Particles when they are updated.
       */
      onUpdate: Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateCallback;

      /**
       * Load the property from a Particle Emitter configuration object.
       *
       * Optionally accepts a new property key to use, replacing the current one.
       * @param config Settings for the Particle Emitter that owns this property.
       * @param newKey The new key to use for this property, if any.
       */
      loadConfig(config?: Phaser.Types.GameObjects.Particles.ParticleEmitterConfig, newKey?: string): void;

      /**
       * Build a JSON representation of this Particle Emitter property.
       */
      toJSON(): object;

      /**
       * Change the current value of the property and update its callback methods.
       * @param value The value of the property.
       */
      onChange(value: number): this;

      /**
       * Update the {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and
       * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks based on the type of the current
       * {@link Phaser.GameObjects.Particles.EmitterOp#propertyValue}.
       */
      setMethods(): this;

      /**
       * Check whether an object has the given property.
       * @param object The object to check.
       * @param key The key of the property to look for in the object.
       */
      has(object: object, key: string): boolean;

      /**
       * Check whether an object has both of the given properties.
       * @param object The object to check.
       * @param key1 The key of the first property to check the object for.
       * @param key2 The key of the second property to check the object for.
       */
      hasBoth(object: object, key1: string, key2: string): boolean;

      /**
       * Check whether an object has at least one of the given properties.
       * @param object The object to check.
       * @param key1 The key of the first property to check the object for.
       * @param key2 The key of the second property to check the object for.
       */
      hasEither(object: object, key1: string, key2: string): boolean;

      /**
       * The returned value sets what the property will be at the START of the particles life, on emit.
       * @param particle The particle.
       * @param key The name of the property.
       * @param value The current value of the property.
       */
      defaultEmit(particle: Phaser.GameObjects.Particles.Particle, key: string, value?: number): number;

      /**
       * The returned value updates the property for the duration of the particles life.
       * @param particle The particle.
       * @param key The name of the property.
       * @param t The T value (between 0 and 1)
       * @param value The current value of the property.
       */
      defaultUpdate(particle: Phaser.GameObjects.Particles.Particle, key: string, t: number, value: number): number;

      /**
       * An `onEmit` callback that returns the current value of the property.
       */
      staticValueEmit(): number;

      /**
       * An `onUpdate` callback that returns the current value of the property.
       */
      staticValueUpdate(): number;

      /**
       * An `onEmit` callback that returns a random value from the current value array.
       */
      randomStaticValueEmit(): number;

      /**
       * An `onEmit` callback that returns a value between the {@link Phaser.GameObjects.Particles.EmitterOp#start} and
       * {@link Phaser.GameObjects.Particles.EmitterOp#end} range.
       * @param particle The particle.
       * @param key The key of the property.
       */
      randomRangedValueEmit(particle: Phaser.GameObjects.Particles.Particle, key: string): number;

      /**
       * An `onEmit` callback that returns a stepped value between the
       * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}
       * range.
       */
      steppedEmit(): number;

      /**
       * An `onEmit` callback for an eased property.
       *
       * It prepares the particle for easing by {@link Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate}.
       * @param particle The particle.
       * @param key The name of the property.
       */
      easedValueEmit(particle: Phaser.GameObjects.Particles.Particle, key: string): number;

      /**
       * An `onUpdate` callback that returns an eased value between the
       * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}
       * range.
       * @param particle The particle.
       * @param key The name of the property.
       * @param t The T value (between 0 and 1)
       */
      easeValueUpdate(particle: Phaser.GameObjects.Particles.Particle, key: string, t: number): number;

    }

    /**
     * The GravityWell action applies a force on the particle to draw it towards, or repel it from, a single point.
     *
     * The force applied is inversely proportional to the square of the distance from the particle to the point, in accordance with Newton's law of gravity.
     *
     * This simulates the effect of gravity over large distances (as between planets, for example).
     */
    class GravityWell {
      /**
       *
       * @param x The x coordinate of the Gravity Well, in world space. Default 0.
       * @param y The y coordinate of the Gravity Well, in world space. Default 0.
       * @param power The strength of the gravity force - larger numbers produce a stronger force. Default 0.
       * @param epsilon The minimum distance for which the gravity force is calculated. Default 100.
       * @param gravity The gravitational force of this Gravity Well. Default 50.
       */
      constructor(x?: number | Phaser.Types.GameObjects.Particles.GravityWellConfig, y?: number, power?: number, epsilon?: number, gravity?: number);

      /**
       * The x coordinate of the Gravity Well, in world space.
       */
      x: number;

      /**
       * The y coordinate of the Gravity Well, in world space.
       */
      y: number;

      /**
       * The active state of the Gravity Well. An inactive Gravity Well will not influence any particles.
       */
      active: boolean;

      /**
       * The strength of the gravity force - larger numbers produce a stronger force.
       */
      power: number;

      /**
       * The minimum distance for which the gravity force is calculated.
       */
      epsilon: number;

      /**
       * Takes a Particle and updates it based on the properties of this Gravity Well.
       * @param particle The Particle to update.
       * @param delta The delta time in ms.
       * @param step The delta value divided by 1000.
       */
      update(particle: Phaser.GameObjects.Particles.Particle, delta: number, step: number): void;

    }

    /**
     * A Particle is a simple Game Object controlled by a Particle Emitter and Manager, and rendered by the Manager.
     * It uses its own lightweight physics system, and can interact only with its Emitter's bounds and zones.
     */
    class Particle {
      /**
       *
       * @param emitter The Emitter to which this Particle belongs.
       */
      constructor(emitter: Phaser.GameObjects.Particles.ParticleEmitter);

      /**
       * The Emitter to which this Particle belongs.
       *
       * A Particle can only belong to a single Emitter and is created, updated and destroyed via it.
       */
      emitter: Phaser.GameObjects.Particles.ParticleEmitter;

      /**
       * The texture frame used to render this Particle.
       */
      frame: Phaser.Textures.Frame;

      /**
       * The x coordinate of this Particle.
       */
      x: number;

      /**
       * The y coordinate of this Particle.
       */
      y: number;

      /**
       * The x velocity of this Particle.
       */
      velocityX: number;

      /**
       * The y velocity of this Particle.
       */
      velocityY: number;

      /**
       * The x acceleration of this Particle.
       */
      accelerationX: number;

      /**
       * The y acceleration of this Particle.
       */
      accelerationY: number;

      /**
       * The maximum horizontal velocity this Particle can travel at.
       */
      maxVelocityX: number;

      /**
       * The maximum vertical velocity this Particle can travel at.
       */
      maxVelocityY: number;

      /**
       * The bounciness, or restitution, of this Particle.
       */
      bounce: number;

      /**
       * The horizontal scale of this Particle.
       */
      scaleX: number;

      /**
       * The vertical scale of this Particle.
       */
      scaleY: number;

      /**
       * The alpha value of this Particle.
       */
      alpha: number;

      /**
       * The angle of this Particle in degrees.
       */
      angle: number;

      /**
       * The angle of this Particle in radians.
       */
      rotation: number;

      /**
       * The tint applied to this Particle.
       */
      tint: number;

      /**
       * The lifespan of this Particle in ms.
       */
      life: number;

      /**
       * The current life of this Particle in ms.
       */
      lifeCurrent: number;

      /**
       * The delay applied to this Particle upon emission, in ms.
       */
      delayCurrent: number;

      /**
       * The normalized lifespan T value, where 0 is the start and 1 is the end.
       */
      lifeT: number;

      /**
       * The data used by the ease equation.
       */
      data: object;

      /**
       * Checks to see if this Particle is alive and updating.
       */
      isAlive(): boolean;

      /**
       * Resets the position of this particle back to zero.
       */
      resetPosition(): void;

      /**
       * Starts this Particle from the given coordinates.
       * @param x The x coordinate to launch this Particle from.
       * @param y The y coordinate to launch this Particle from.
       */
      fire(x: number, y: number): void;

      /**
       * An internal method that calculates the velocity of the Particle.
       * @param emitter The Emitter that is updating this Particle.
       * @param delta The delta time in ms.
       * @param step The delta value divided by 1000.
       * @param processors Particle processors (gravity wells).
       */
      computeVelocity(emitter: Phaser.GameObjects.Particles.ParticleEmitter, delta: number, step: number, processors: any[]): void;

      /**
       * Checks if this Particle is still within the bounds defined by the given Emitter.
       *
       * If not, and depending on the Emitter collision flags, the Particle may either stop or rebound.
       * @param emitter The Emitter to check the bounds against.
       */
      checkBounds(emitter: Phaser.GameObjects.Particles.ParticleEmitter): void;

      /**
       * The main update method for this Particle.
       *
       * Updates its life values, computes the velocity and repositions the Particle.
       * @param delta The delta time in ms.
       * @param step The delta value divided by 1000.
       * @param processors An optional array of update processors.
       */
      update(delta: number, step: number, processors: any[]): boolean;

    }

    /**
     * A particle emitter represents a single particle stream.
     * It controls a pool of {@link Phaser.GameObjects.Particles.Particle Particles} and is controlled by a {@link Phaser.GameObjects.Particles.ParticleEmitterManager Particle Emitter Manager}.
     */
    class ParticleEmitter implements Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Visible {
      /**
       *
       * @param manager The Emitter Manager this Emitter belongs to.
       * @param config Settings for this emitter.
       */
      constructor(manager: Phaser.GameObjects.Particles.ParticleEmitterManager, config: Phaser.Types.GameObjects.Particles.ParticleEmitterConfig);

      /**
       * The Emitter Manager this Emitter belongs to.
       */
      manager: Phaser.GameObjects.Particles.ParticleEmitterManager;

      /**
       * The texture assigned to particles.
       */
      texture: Phaser.Textures.Texture;

      /**
       * The texture frames assigned to particles.
       */
      frames: Phaser.Textures.Frame[];

      /**
       * The default texture frame assigned to particles.
       */
      defaultFrame: Phaser.Textures.Frame;

      /**
       * Names of simple configuration properties.
       */
      configFastMap: object;

      /**
       * Names of complex configuration properties.
       */
      configOpMap: object;

      /**
       * The name of this Particle Emitter.
       *
       * Empty by default and never populated by Phaser, this is left for developers to use.
       */
      name: string;

      /**
       * The Particle Class which will be emitted by this Emitter.
       */
      particleClass: Phaser.GameObjects.Particles.Particle;

      /**
       * The x-coordinate of the particle origin (where particles will be emitted).
       */
      x: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The y-coordinate of the particle origin (where particles will be emitted).
       */
      y: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * A radial emitter will emit particles in all directions between angle min and max,
       * using {@link Phaser.GameObjects.Particles.ParticleEmitter#speed} as the value. If set to false then this acts as a point Emitter.
       * A point emitter will emit particles only in the direction derived from the speedX and speedY values.
       */
      radial: boolean;

      /**
       * Horizontal acceleration applied to emitted particles, in pixels per second squared.
       */
      gravityX: number;

      /**
       * Vertical acceleration applied to emitted particles, in pixels per second squared.
       */
      gravityY: number;

      /**
       * Whether accelerationX and accelerationY are non-zero. Set automatically during configuration.
       */
      acceleration: boolean;

      /**
       * Horizontal acceleration applied to emitted particles, in pixels per second squared.
       */
      accelerationX: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * Vertical acceleration applied to emitted particles, in pixels per second squared.
       */
      accelerationY: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The maximum horizontal velocity of emitted particles, in pixels per second squared.
       */
      maxVelocityX: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The maximum vertical velocity of emitted particles, in pixels per second squared.
       */
      maxVelocityY: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The initial horizontal speed of emitted particles, in pixels per second.
       */
      speedX: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The initial vertical speed of emitted particles, in pixels per second.
       */
      speedY: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * Whether moveToX and moveToY are nonzero. Set automatically during configuration.
       */
      moveTo: boolean;

      /**
       * The x-coordinate emitted particles move toward, when {@link Phaser.GameObjects.Particles.ParticleEmitter#moveTo} is true.
       */
      moveToX: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The y-coordinate emitted particles move toward, when {@link Phaser.GameObjects.Particles.ParticleEmitter#moveTo} is true.
       */
      moveToY: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * Whether particles will rebound when they meet the emitter bounds.
       */
      bounce: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The horizontal scale of emitted particles.
       */
      scaleX: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The vertical scale of emitted particles.
       */
      scaleY: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * Color tint applied to emitted particles. Value must not include the alpha channel.
       */
      tint: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The alpha (transparency) of emitted particles.
       */
      alpha: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The lifespan of emitted particles, in ms.
       */
      lifespan: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The angle of the initial velocity of emitted particles, in degrees.
       */
      angle: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * The rotation of emitted particles, in degrees.
       */
      rotate: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * A function to call when a particle is emitted.
       */
      emitCallback: Phaser.Types.GameObjects.Particles.ParticleEmitterCallback;

      /**
       * The calling context for {@link Phaser.GameObjects.Particles.ParticleEmitter#emitCallback}.
       */
      emitCallbackScope: any;

      /**
       * A function to call when a particle dies.
       */
      deathCallback: Phaser.Types.GameObjects.Particles.ParticleDeathCallback;

      /**
       * The calling context for {@link Phaser.GameObjects.Particles.ParticleEmitter#deathCallback}.
       */
      deathCallbackScope: any;

      /**
       * Set to hard limit the amount of particle objects this emitter is allowed to create.
       * 0 means unlimited.
       */
      maxParticles: number;

      /**
       * How many particles are emitted each time particles are emitted (one explosion or one flow cycle).
       */
      quantity: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * How many ms to wait after emission before the particles start updating.
       */
      delay: Phaser.GameObjects.Particles.EmitterOp;

      /**
       * For a flow emitter, the time interval (>= 0) between particle flow cycles in ms.
       * A value of 0 means there is one particle flow cycle for each logic update (the maximum flow frequency). This is the default setting.
       * For an exploding emitter, this value will be -1.
       * Calling {@link Phaser.GameObjects.Particles.ParticleEmitter#flow} also puts the emitter in flow mode (frequency >= 0).
       * Calling {@link Phaser.GameObjects.Particles.ParticleEmitter#explode} also puts the emitter in explode mode (frequency = -1).
       */
      frequency: number;

      /**
       * Controls if the emitter is currently emitting a particle flow (when frequency >= 0).
       * Already alive particles will continue to update until they expire.
       * Controlled by {@link Phaser.GameObjects.Particles.ParticleEmitter#start} and {@link Phaser.GameObjects.Particles.ParticleEmitter#stop}.
       */
      on: boolean;

      /**
       * Newly emitted particles are added to the top of the particle list, i.e. rendered above those already alive.
       * Set to false to send them to the back.
       */
      particleBringToTop: boolean;

      /**
       * The time rate applied to active particles, affecting lifespan, movement, and tweens. Values larger than 1 are faster than normal.
       */
      timeScale: number;

      /**
       * An object describing a shape to emit particles from.
       */
      emitZone: Phaser.GameObjects.Particles.Zones.EdgeZone | Phaser.GameObjects.Particles.Zones.RandomZone;

      /**
       * An object describing a shape that deactivates particles when they interact with it.
       */
      deathZone: Phaser.GameObjects.Particles.Zones.DeathZone;

      /**
       * A rectangular boundary constraining particle movement.
       */
      bounds: Phaser.Geom.Rectangle;

      /**
       * Whether particles interact with the left edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
       */
      collideLeft: boolean;

      /**
       * Whether particles interact with the right edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
       */
      collideRight: boolean;

      /**
       * Whether particles interact with the top edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
       */
      collideTop: boolean;

      /**
       * Whether particles interact with the bottom edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
       */
      collideBottom: boolean;

      /**
       * Whether this emitter updates itself and its particles.
       *
       * Controlled by {@link Phaser.GameObjects.Particles.ParticleEmitter#pause}
       * and {@link Phaser.GameObjects.Particles.ParticleEmitter#resume}.
       */
      active: boolean;

      /**
       * Set this to false to hide any active particles.
       */
      visible: boolean;

      /**
       * The blend mode of this emitter's particles.
       */
      blendMode: number;

      /**
       * A Game Object whose position is used as the particle origin.
       */
      follow: Phaser.GameObjects.GameObject;

      /**
       * The offset of the particle origin from the {@link Phaser.GameObjects.Particles.ParticleEmitter#follow} target.
       */
      followOffset: Phaser.Math.Vector2;

      /**
       * Whether the emitter's {@link Phaser.GameObjects.Particles.ParticleEmitter#visible} state will track
       * the {@link Phaser.GameObjects.Particles.ParticleEmitter#follow} target's visibility state.
       */
      trackVisible: boolean;

      /**
       * The current texture frame, as an index of {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.
       */
      currentFrame: number;

      /**
       * Whether texture {@link Phaser.GameObjects.Particles.ParticleEmitter#frames} are selected at random.
       */
      randomFrame: boolean;

      /**
       * The number of consecutive particles that receive a single texture frame (per frame cycle).
       */
      frameQuantity: number;

      /**
       * Merges configuration settings into the emitter's current settings.
       * @param config Settings for this emitter.
       */
      fromJSON(config: Phaser.Types.GameObjects.Particles.ParticleEmitterConfig): this;

      /**
       * Creates a description of this emitter suitable for JSON serialization.
       * @param output An object to copy output into.
       */
      toJSON(output?: object): object;

      /**
       * Continuously moves the particle origin to follow a Game Object's position.
       * @param target The Game Object to follow.
       * @param offsetX Horizontal offset of the particle origin from the Game Object. Default 0.
       * @param offsetY Vertical offset of the particle origin from the Game Object. Default 0.
       * @param trackVisible Whether the emitter's visible state will track the target's visible state. Default false.
       */
      startFollow(target: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number, trackVisible?: boolean): this;

      /**
       * Stops following a Game Object.
       */
      stopFollow(): this;

      /**
       * Chooses a texture frame from {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.
       */
      getFrame(): Phaser.Textures.Frame;

      /**
       * Sets a pattern for assigning texture frames to emitted particles.
       * @param frames One or more texture frames, or a configuration object.
       * @param pickRandom Whether frames should be assigned at random from `frames`. Default true.
       * @param quantity The number of consecutive particles that will receive each frame. Default 1.
       */
      setFrame(frames: any[] | string | number | Phaser.Types.GameObjects.Particles.ParticleEmitterFrameConfig, pickRandom?: boolean, quantity?: number): this;

      /**
       * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle movement on or off.
       * @param value Radial mode (true) or point mode (true). Default true.
       */
      setRadial(value?: boolean): this;

      /**
       * Sets the position of the emitter's particle origin.
       * New particles will be emitted here.
       * @param x The x-coordinate of the particle origin.
       * @param y The y-coordinate of the particle origin.
       */
      setPosition(x: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType, y: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType): this;

      /**
       * Sets or modifies a rectangular boundary constraining the particles.
       *
       * To remove the boundary, set {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds} to null.
       * @param x The x-coordinate of the left edge of the boundary, or an object representing a rectangle.
       * @param y The y-coordinate of the top edge of the boundary.
       * @param width The width of the boundary.
       * @param height The height of the boundary.
       */
      setBounds(x: number | Phaser.Types.GameObjects.Particles.ParticleEmitterBounds | Phaser.Types.GameObjects.Particles.ParticleEmitterBoundsAlt, y: number, width: number, height: number): this;

      /**
       * Sets the initial horizontal speed of emitted particles.
       * Changes the emitter to point mode.
       * @param value The speed, in pixels per second.
       */
      setSpeedX(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType): this;

      /**
       * Sets the initial vertical speed of emitted particles.
       * Changes the emitter to point mode.
       * @param value The speed, in pixels per second.
       */
      setSpeedY(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType): this;

      /**
       * Sets the initial radial speed of emitted particles.
       * Changes the emitter to radial mode.
       * @param value The speed, in pixels per second.
       */
      setSpeed(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType): this;

      /**
       * Sets the horizontal scale of emitted particles.
       * @param value The scale, relative to 1.
       */
      setScaleX(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType | Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType): this;

      /**
       * Sets the vertical scale of emitted particles.
       * @param value The scale, relative to 1.
       */
      setScaleY(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType | Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType): this;

      /**
       * Sets the scale of emitted particles.
       * @param value The scale, relative to 1.
       */
      setScale(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType | Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType): this;

      /**
       * Sets the horizontal gravity applied to emitted particles.
       * @param value Acceleration due to gravity, in pixels per second squared.
       */
      setGravityX(value: number): this;

      /**
       * Sets the vertical gravity applied to emitted particles.
       * @param value Acceleration due to gravity, in pixels per second squared.
       */
      setGravityY(value: number): this;

      /**
       * Sets the gravity applied to emitted particles.
       * @param x Horizontal acceleration due to gravity, in pixels per second squared.
       * @param y Vertical acceleration due to gravity, in pixels per second squared.
       */
      setGravity(x: number, y: number): this;

      /**
       * Sets the opacity of emitted particles.
       * @param value A value between 0 (transparent) and 1 (opaque).
       */
      setAlpha(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType | Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType): this;

      /**
       * Sets the color tint of emitted particles.
       * @param value A value between 0 and 0xffffff.
       */
      setTint(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType | Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType): this;

      /**
       * Sets the angle of a {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle stream.
       * @param value The angle of the initial velocity of emitted particles.
       */
      setEmitterAngle(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType): this;

      /**
       * Sets the angle of a {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle stream.
       * @param value The angle of the initial velocity of emitted particles.
       */
      setAngle(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType): this;

      /**
       * Sets the lifespan of newly emitted particles.
       * @param value The particle lifespan, in ms.
       */
      setLifespan(value: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType): this;

      /**
       * Sets the number of particles released at each flow cycle or explosion.
       * @param quantity The number of particles to release at each flow cycle or explosion.
       */
      setQuantity(quantity: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType): this;

      /**
       * Sets the emitter's {@link Phaser.GameObjects.Particles.ParticleEmitter#frequency}
       * and {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.
       * @param frequency The time interval (>= 0) of each flow cycle, in ms; or -1 to put the emitter in explosion mode.
       * @param quantity The number of particles to release at each flow cycle or explosion.
       */
      setFrequency(frequency: number, quantity?: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType): this;

      /**
       * Sets or removes the {@link Phaser.GameObjects.Particles.ParticleEmitter#emitZone}.
       *
       * An {@link Phaser.Types.GameObjects.Particles.ParticleEmitterEdgeZoneConfig EdgeZone} places particles on its edges. Its {@link Phaser.Types.GameObjects.Particles.EdgeZoneSource source} can be a Curve, Path, Circle, Ellipse, Line, Polygon, Rectangle, or Triangle; or any object with a suitable {@link Phaser.Types.GameObjects.Particles.EdgeZoneSourceCallback getPoints} method.
       *
       * A {@link Phaser.Types.GameObjects.Particles.ParticleEmitterRandomZoneConfig RandomZone} places randomly within its interior. Its {@link RandomZoneSource source} can be a Circle, Ellipse, Line, Polygon, Rectangle, or Triangle; or any object with a suitable {@link Phaser.Types.GameObjects.Particles.RandomZoneSourceCallback getRandomPoint} method.
       * @param zoneConfig An object describing the zone, or `undefined` to remove any current emit zone.
       */
      setEmitZone(zoneConfig?: Phaser.Types.GameObjects.Particles.ParticleEmitterEdgeZoneConfig | Phaser.Types.GameObjects.Particles.ParticleEmitterRandomZoneConfig): this;

      /**
       * Sets or removes the {@link Phaser.GameObjects.Particles.ParticleEmitter#deathZone}.
       * @param zoneConfig An object describing the zone, or `undefined` to remove any current death zone.
       */
      setDeathZone(zoneConfig?: Phaser.Types.GameObjects.Particles.ParticleEmitterDeathZoneConfig): this;

      /**
       * Creates inactive particles and adds them to this emitter's pool.
       * @param particleCount The number of particles to create.
       */
      reserve(particleCount: number): this;

      /**
       * Gets the number of active (in-use) particles in this emitter.
       */
      getAliveParticleCount(): number;

      /**
       * Gets the number of inactive (available) particles in this emitter.
       */
      getDeadParticleCount(): number;

      /**
       * Gets the total number of particles in this emitter.
       */
      getParticleCount(): number;

      /**
       * Whether this emitter is at its limit (if set).
       */
      atLimit(): boolean;

      /**
       * Sets a function to call for each newly emitted particle.
       * @param callback The function.
       * @param context The calling context.
       */
      onParticleEmit(callback: Phaser.Types.GameObjects.Particles.ParticleEmitterCallback, context?: any): this;

      /**
       * Sets a function to call for each particle death.
       * @param callback The function.
       * @param context The function's calling context.
       */
      onParticleDeath(callback: Phaser.Types.GameObjects.Particles.ParticleDeathCallback, context?: any): this;

      /**
       * Deactivates every particle in this emitter.
       */
      killAll(): this;

      /**
       * Calls a function for each active particle in this emitter.
       * @param callback The function.
       * @param context The function's calling context.
       */
      forEachAlive(callback: Phaser.Types.GameObjects.Particles.ParticleEmitterCallback, context: any): this;

      /**
       * Calls a function for each inactive particle in this emitter.
       * @param callback The function.
       * @param context The function's calling context.
       */
      forEachDead(callback: Phaser.Types.GameObjects.Particles.ParticleEmitterCallback, context: any): this;

      /**
       * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#on} the emitter and resets the flow counter.
       *
       * If this emitter is in flow mode (frequency >= 0; the default), the particle flow will start (or restart).
       *
       * If this emitter is in explode mode (frequency = -1), nothing will happen.
       * Use {@link Phaser.GameObjects.Particles.ParticleEmitter#explode} or {@link Phaser.GameObjects.Particles.ParticleEmitter#flow} instead.
       */
      start(): this;

      /**
       * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#on off} the emitter.
       */
      stop(): this;

      /**
       * {@link Phaser.GameObjects.Particles.ParticleEmitter#active Deactivates} the emitter.
       */
      pause(): this;

      /**
       * {@link Phaser.GameObjects.Particles.ParticleEmitter#active Activates} the emitter.
       */
      resume(): this;

      /**
       * Removes the emitter from its manager and the scene.
       */
      remove(): this;

      /**
       * Sorts active particles with {@link Phaser.GameObjects.Particles.ParticleEmitter#depthSortCallback}.
       */
      depthSort(): this;

      /**
       * Puts the emitter in flow mode (frequency >= 0) and starts (or restarts) a particle flow.
       *
       * To resume a flow at the current frequency and quantity, use {@link Phaser.GameObjects.Particles.ParticleEmitter#start} instead.
       * @param frequency The time interval (>= 0) of each flow cycle, in ms.
       * @param count The number of particles to emit at each flow cycle. Default 1.
       */
      flow(frequency: number, count?: Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType): this;

      /**
       * Puts the emitter in explode mode (frequency = -1), stopping any current particle flow, and emits several particles all at once.
       * @param count The amount of Particles to emit.
       * @param x The x coordinate to emit the Particles from.
       * @param y The y coordinate to emit the Particles from.
       */
      explode(count: number, x: number, y: number): Phaser.GameObjects.Particles.Particle;

      /**
       * Emits particles at a given position (or the emitter's current position).
       * @param x The x coordinate to emit the Particles from. Default this.x.
       * @param y The y coordinate to emit the Particles from. Default this.x.
       * @param count The number of Particles to emit. Default this.quantity.
       */
      emitParticleAt(x?: number, y?: number, count?: number): Phaser.GameObjects.Particles.Particle;

      /**
       * Emits particles at a given position (or the emitter's current position).
       * @param count The number of Particles to emit. Default this.quantity.
       * @param x The x coordinate to emit the Particles from. Default this.x.
       * @param y The y coordinate to emit the Particles from. Default this.x.
       */
      emitParticle(count?: number, x?: number, y?: number): Phaser.GameObjects.Particles.Particle;

      /**
       * Updates this emitter and its particles.
       * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
       * @param delta The delta time, in ms, elapsed since the last frame.
       */
      preUpdate(time: number, delta: number): void;

      /**
       * Calculates the difference of two particles, for sorting them by depth.
       * @param a The first particle.
       * @param b The second particle.
       */
      depthSortCallback(a: object, b: object): number;

      /**
       * Sets the Blend Mode being used by this Game Object.
       *
       * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
       *
       * Under WebGL only the following Blend Modes are available:
       *
       * * ADD
       * * MULTIPLY
       * * SCREEN
       * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
       *
       * Canvas has more available depending on browser support.
       *
       * You can also create your own custom Blend Modes in WebGL.
       *
       * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
       * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
       * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
       * are used.
       * @param value The BlendMode value. Either a string or a CONST.
       */
      setBlendMode(value: string | Phaser.BlendModes): this;

      /**
       * The Mask this Game Object is using during render.
       */
      mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

      /**
       * Sets the mask that this Game Object will use to render with.
       *
       * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
       * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
       *
       * If a mask is already set on this Game Object it will be immediately replaced.
       *
       * Masks are positioned in global space and are not relative to the Game Object to which they
       * are applied. The reason for this is that multiple Game Objects can all share the same mask.
       *
       * Masks have no impact on physics or input detection. They are purely a rendering component
       * that allows you to limit what is visible during the render pass.
       * @param mask The mask this Game Object will use when rendering.
       */
      setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

      /**
       * Clears the mask that this Game Object was using.
       * @param destroyMask Destroy the mask before clearing it? Default false.
       */
      clearMask(destroyMask?: boolean): this;

      /**
       * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
       * including this one.
       *
       * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
       *
       * To create the mask you need to pass in a reference to a renderable Game Object.
       * A renderable Game Object is one that uses a texture to render with, such as an
       * Image, Sprite, Render Texture or BitmapText.
       *
       * If you do not provide a renderable object, and this Game Object has a texture,
       * it will use itself as the object. This means you can call this method to create
       * a Bitmap Mask from any renderable Game Object.
       * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
       */
      createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

      /**
       * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
       * including this one.
       *
       * To create the mask you need to pass in a reference to a Graphics Game Object.
       *
       * If you do not provide a graphics object, and this Game Object is an instance
       * of a Graphics object, then it will use itself to create the mask.
       *
       * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
       * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
       */
      createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

      /**
       * The horizontal scroll factor of this Game Object.
       *
       * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
       *
       * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
       * It does not change the Game Objects actual position values.
       *
       * A value of 1 means it will move exactly in sync with a camera.
       * A value of 0 means it will not move at all, even if the camera moves.
       * Other values control the degree to which the camera movement is mapped to this Game Object.
       *
       * Please be aware that scroll factor values other than 1 are not taken in to consideration when
       * calculating physics collisions. Bodies always collide based on their world position, but changing
       * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
       * them from physics bodies if not accounted for in your code.
       */
      scrollFactorX: number;

      /**
       * The vertical scroll factor of this Game Object.
       *
       * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
       *
       * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
       * It does not change the Game Objects actual position values.
       *
       * A value of 1 means it will move exactly in sync with a camera.
       * A value of 0 means it will not move at all, even if the camera moves.
       * Other values control the degree to which the camera movement is mapped to this Game Object.
       *
       * Please be aware that scroll factor values other than 1 are not taken in to consideration when
       * calculating physics collisions. Bodies always collide based on their world position, but changing
       * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
       * them from physics bodies if not accounted for in your code.
       */
      scrollFactorY: number;

      /**
       * Sets the scroll factor of this Game Object.
       *
       * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
       *
       * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
       * It does not change the Game Objects actual position values.
       *
       * A value of 1 means it will move exactly in sync with a camera.
       * A value of 0 means it will not move at all, even if the camera moves.
       * Other values control the degree to which the camera movement is mapped to this Game Object.
       *
       * Please be aware that scroll factor values other than 1 are not taken in to consideration when
       * calculating physics collisions. Bodies always collide based on their world position, but changing
       * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
       * them from physics bodies if not accounted for in your code.
       * @param x The horizontal scroll factor of this Game Object.
       * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
       */
      setScrollFactor(x: number, y?: number): this;

      /**
       * Sets the visibility of this Game Object.
       *
       * An invisible Game Object will skip rendering, but will still process update logic.
       * @param value The visible state of the Game Object.
       */
      setVisible(value: boolean): this;

    }

    /**
     * A Particle Emitter Manager creates and controls {@link Phaser.GameObjects.Particles.ParticleEmitter Particle Emitters} and {@link Phaser.GameObjects.Particles.GravityWell Gravity Wells}.
     */
    class ParticleEmitterManager extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
      /**
       *
       * @param scene The Scene to which this Emitter Manager belongs.
       * @param texture The key of the Texture this Emitter Manager will use to render particles, as stored in the Texture Manager.
       * @param frame An optional frame from the Texture this Emitter Manager will use to render particles.
       * @param emitters Configuration settings for one or more emitters to create.
       */
      constructor(scene: Phaser.Scene, texture: string, frame?: string | number, emitters?: Phaser.Types.GameObjects.Particles.ParticleEmitterConfig | Phaser.Types.GameObjects.Particles.ParticleEmitterConfig[]);

      /**
       * The time scale applied to all emitters and particles, affecting flow rate, lifespan, and movement.
       * Values larger than 1 are faster than normal.
       * This is multiplied with any timeScale set on each individual emitter.
       */
      timeScale: number;

      /**
       * The texture used to render this Emitter Manager's particles.
       */
      texture: Phaser.Textures.Texture;

      /**
       * The texture frame used to render this Emitter Manager's particles.
       */
      frame: Phaser.Textures.Frame;

      /**
       * Names of this Emitter Manager's texture frames.
       */
      frameNames: string[];

      /**
       * A list of Emitters being managed by this Emitter Manager.
       */
      emitters: Phaser.Structs.List<Phaser.GameObjects.Particles.ParticleEmitter>;

      /**
       * A list of Gravity Wells being managed by this Emitter Manager.
       */
      wells: Phaser.Structs.List<Phaser.GameObjects.Particles.GravityWell>;

      /**
       * Sets the texture and frame this Emitter Manager will use to render with.
       *
       * Textures are referenced by their string-based keys, as stored in the Texture Manager.
       * @param key The key of the texture to be used, as stored in the Texture Manager.
       * @param frame The name or index of the frame within the Texture.
       */
      setTexture(key: string, frame?: string | number): this;

      /**
       * Sets the frame this Emitter Manager will use to render with.
       *
       * The Frame has to belong to the current Texture being used.
       *
       * It can be either a string or an index.
       * @param frame The name or index of the frame within the Texture.
       */
      setFrame(frame?: string | number): this;

      /**
       * Assigns texture frames to an emitter.
       * @param frames The texture frames.
       * @param emitter The particle emitter to modify.
       */
      setEmitterFrames(frames: Phaser.Textures.Frame | Phaser.Textures.Frame[], emitter: Phaser.GameObjects.Particles.ParticleEmitter): this;

      /**
       * Adds an existing Particle Emitter to this Emitter Manager.
       * @param emitter The Particle Emitter to add to this Emitter Manager.
       */
      addEmitter(emitter: Phaser.GameObjects.Particles.ParticleEmitter): Phaser.GameObjects.Particles.ParticleEmitter;

      /**
       * Creates a new Particle Emitter object, adds it to this Emitter Manager and returns a reference to it.
       * @param config Configuration settings for the Particle Emitter to create.
       */
      createEmitter(config: Phaser.Types.GameObjects.Particles.ParticleEmitterConfig): Phaser.GameObjects.Particles.ParticleEmitter;

      /**
       * Removes a Particle Emitter from this Emitter Manager, if the Emitter belongs to this Manager.
       */
      removeEmitter(emitter: Phaser.GameObjects.Particles.ParticleEmitter): Phaser.GameObjects.Particles.ParticleEmitter;

      /**
       * Adds an existing Gravity Well object to this Emitter Manager.
       * @param well The Gravity Well to add to this Emitter Manager.
       */
      addGravityWell(well: Phaser.GameObjects.Particles.GravityWell): Phaser.GameObjects.Particles.GravityWell;

      /**
       * Creates a new Gravity Well, adds it to this Emitter Manager and returns a reference to it.
       * @param config Configuration settings for the Gravity Well to create.
       */
      createGravityWell(config: Phaser.Types.GameObjects.Particles.GravityWellConfig): Phaser.GameObjects.Particles.GravityWell;

      /**
       * Emits particles from each active emitter.
       * @param count The number of particles to release from each emitter. The default is the emitter's own {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.
       * @param x The x-coordinate to to emit particles from. The default is the x-coordinate of the emitter's current location.
       * @param y The y-coordinate to to emit particles from. The default is the y-coordinate of the emitter's current location.
       */
      emitParticle(count?: number, x?: number, y?: number): this;

      /**
       * Emits particles from each active emitter.
       * @param x The x-coordinate to to emit particles from. The default is the x-coordinate of the emitter's current location.
       * @param y The y-coordinate to to emit particles from. The default is the y-coordinate of the emitter's current location.
       * @param count The number of particles to release from each emitter. The default is the emitter's own {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.
       */
      emitParticleAt(x?: number, y?: number, count?: number): this;

      /**
       * Pauses this Emitter Manager.
       *
       * This has the effect of pausing all emitters, and all particles of those emitters, currently under its control.
       *
       * The particles will still render, but they will not have any of their logic updated.
       */
      pause(): this;

      /**
       * Resumes this Emitter Manager, should it have been previously paused.
       */
      resume(): this;

      /**
       * Gets all active particle processors (gravity wells).
       */
      getProcessors(): Phaser.GameObjects.Particles.GravityWell[];

      /**
       * Updates all active emitters.
       * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
       * @param delta The delta time, in ms, elapsed since the last frame.
       */
      preUpdate(time: number, delta: number): void;

      /**
       * The depth of this Game Object within the Scene.
       *
       * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
       * of Game Objects, without actually moving their position in the display list.
       *
       * The default depth is zero. A Game Object with a higher depth
       * value will always render in front of one with a lower value.
       *
       * Setting the depth will queue a depth sort event within the Scene.
       */
      depth: number;

      /**
       * The depth of this Game Object within the Scene.
       *
       * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
       * of Game Objects, without actually moving their position in the display list.
       *
       * The default depth is zero. A Game Object with a higher depth
       * value will always render in front of one with a lower value.
       *
       * Setting the depth will queue a depth sort event within the Scene.
       * @param value The depth of this Game Object.
       */
      setDepth(value: number): this;

      /**
       * The Mask this Game Object is using during render.
       */
      mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

      /**
       * Sets the mask that this Game Object will use to render with.
       *
       * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
       * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
       *
       * If a mask is already set on this Game Object it will be immediately replaced.
       *
       * Masks are positioned in global space and are not relative to the Game Object to which they
       * are applied. The reason for this is that multiple Game Objects can all share the same mask.
       *
       * Masks have no impact on physics or input detection. They are purely a rendering component
       * that allows you to limit what is visible during the render pass.
       * @param mask The mask this Game Object will use when rendering.
       */
      setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

      /**
       * Clears the mask that this Game Object was using.
       * @param destroyMask Destroy the mask before clearing it? Default false.
       */
      clearMask(destroyMask?: boolean): this;

      /**
       * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
       * including this one.
       *
       * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
       *
       * To create the mask you need to pass in a reference to a renderable Game Object.
       * A renderable Game Object is one that uses a texture to render with, such as an
       * Image, Sprite, Render Texture or BitmapText.
       *
       * If you do not provide a renderable object, and this Game Object has a texture,
       * it will use itself as the object. This means you can call this method to create
       * a Bitmap Mask from any renderable Game Object.
       * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
       */
      createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

      /**
       * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
       * including this one.
       *
       * To create the mask you need to pass in a reference to a Graphics Game Object.
       *
       * If you do not provide a graphics object, and this Game Object is an instance
       * of a Graphics object, then it will use itself to create the mask.
       *
       * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
       * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
       */
      createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

      /**
       * The initial WebGL pipeline of this Game Object.
       *
       * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
       */
      defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

      /**
       * The current WebGL pipeline of this Game Object.
       */
      pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

      /**
       * Does this Game Object have any Post Pipelines set?
       */
      hasPostPipeline: boolean;

      /**
       * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
       *
       * The pipelines are processed in the order in which they appear in this array.
       *
       * If you modify this array directly, be sure to set the
       * `hasPostPipeline` property accordingly.
       */
      postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

      /**
       * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
       */
      pipelineData: object;

      /**
       * Sets the initial WebGL Pipeline of this Game Object.
       *
       * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
       * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
       */
      initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

      /**
       * Sets the main WebGL Pipeline of this Game Object.
       *
       * Also sets the `pipelineData` property, if the parameter is given.
       *
       * Both the pipeline and post pipelines share the same pipeline data object.
       * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
       * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
       * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
       */
      setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

      /**
       * Sets one, or more, Post Pipelines on this Game Object.
       *
       * Post Pipelines are invoked after this Game Object has rendered to its target and
       * are commonly used for post-fx.
       *
       * The post pipelines are appended to the `postPipelines` array belonging to this
       * Game Object. When the renderer processes this Game Object, it iterates through the post
       * pipelines in the order in which they appear in the array. If you are stacking together
       * multiple effects, be aware that the order is important.
       *
       * If you call this method multiple times, the new pipelines will be appended to any existing
       * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
       *
       * You can optionally also sets the `pipelineData` property, if the parameter is given.
       *
       * Both the pipeline and post pipelines share the pipeline data object together.
       * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
       * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
       * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
       */
      setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

      /**
       * Adds an entry to the `pipelineData` object belonging to this Game Object.
       *
       * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
       *
       * If `value` is undefined, and `key` exists, `key` is removed from the data object.
       *
       * Both the pipeline and post pipelines share the pipeline data object together.
       * @param key The key of the pipeline data to set, update, or delete.
       * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
       */
      setPipelineData(key: string, value?: any): this;

      /**
       * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
       * @param pipeline The string-based name of the pipeline, or a pipeline class.
       */
      getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

      /**
       * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
       * @param resetPostPipelines Reset all of the post pipelines? Default false.
       * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
       */
      resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

      /**
       * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
       * the `destroy` method on each post pipeline and then clearing the local array.
       * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
       */
      resetPostPipeline(resetData?: boolean): void;

      /**
       * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
       *
       * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
       * @param pipeline The string-based name of the pipeline, or a pipeline class.
       */
      removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

      /**
       * Gets the name of the WebGL Pipeline this Game Object is currently using.
       */
      getPipelineName(): string;

      /**
       * The x position of this Game Object.
       */
      x: number;

      /**
       * The y position of this Game Object.
       */
      y: number;

      /**
       * The z position of this Game Object.
       *
       * Note: The z position does not control the rendering order of 2D Game Objects. Use
       * {@link Phaser.GameObjects.Components.Depth#depth} instead.
       */
      z: number;

      /**
       * The w position of this Game Object.
       */
      w: number;

      /**
       * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
       * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
       *
       * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
       * isn't the case, use the `scaleX` or `scaleY` properties instead.
       */
      scale: number;

      /**
       * The horizontal scale of this Game Object.
       */
      scaleX: number;

      /**
       * The vertical scale of this Game Object.
       */
      scaleY: number;

      /**
       * The angle of this Game Object as expressed in degrees.
       *
       * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
       * and -90 is up.
       *
       * If you prefer to work in radians, see the `rotation` property instead.
       */
      angle: number;

      /**
       * The angle of this Game Object in radians.
       *
       * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
       * and -PI/2 is up.
       *
       * If you prefer to work in degrees, see the `angle` property instead.
       */
      rotation: number;

      /**
       * Sets the position of this Game Object.
       * @param x The x position of this Game Object. Default 0.
       * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
       * @param z The z position of this Game Object. Default 0.
       * @param w The w position of this Game Object. Default 0.
       */
      setPosition(x?: number, y?: number, z?: number, w?: number): this;

      /**
       * Copies an object's coordinates to this Game Object's position.
       * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
       */
      copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

      /**
       * Sets the position of this Game Object to be a random position within the confines of
       * the given area.
       *
       * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
       *
       * The position does not factor in the size of this Game Object, meaning that only the origin is
       * guaranteed to be within the area.
       * @param x The x position of the top-left of the random area. Default 0.
       * @param y The y position of the top-left of the random area. Default 0.
       * @param width The width of the random area.
       * @param height The height of the random area.
       */
      setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

      /**
       * Sets the rotation of this Game Object.
       * @param radians The rotation of this Game Object, in radians. Default 0.
       */
      setRotation(radians?: number): this;

      /**
       * Sets the angle of this Game Object.
       * @param degrees The rotation of this Game Object, in degrees. Default 0.
       */
      setAngle(degrees?: number): this;

      /**
       * Sets the scale of this Game Object.
       * @param x The horizontal scale of this Game Object.
       * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
       */
      setScale(x: number, y?: number): this;

      /**
       * Sets the x position of this Game Object.
       * @param value The x position of this Game Object. Default 0.
       */
      setX(value?: number): this;

      /**
       * Sets the y position of this Game Object.
       * @param value The y position of this Game Object. Default 0.
       */
      setY(value?: number): this;

      /**
       * Sets the z position of this Game Object.
       *
       * Note: The z position does not control the rendering order of 2D Game Objects. Use
       * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
       * @param value The z position of this Game Object. Default 0.
       */
      setZ(value?: number): this;

      /**
       * Sets the w position of this Game Object.
       * @param value The w position of this Game Object. Default 0.
       */
      setW(value?: number): this;

      /**
       * Gets the local transform matrix for this Game Object.
       * @param tempMatrix The matrix to populate with the values from this Game Object.
       */
      getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

      /**
       * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
       * @param tempMatrix The matrix to populate with the values from this Game Object.
       * @param parentMatrix A temporary matrix to hold parent values during the calculations.
       */
      getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

      /**
       * Takes the given `x` and `y` coordinates and converts them into local space for this
       * Game Object, taking into account parent and local transforms, and the Display Origin.
       *
       * The returned Vector2 contains the translated point in its properties.
       *
       * A Camera needs to be provided in order to handle modified scroll factors. If no
       * camera is specified, it will use the `main` camera from the Scene to which this
       * Game Object belongs.
       * @param x The x position to translate.
       * @param y The y position to translate.
       * @param point A Vector2, or point-like object, to store the results in.
       * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
       */
      getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

      /**
       * Gets the sum total rotation of all of this Game Objects parent Containers.
       *
       * The returned value is in radians and will be zero if this Game Object has no parent container.
       */
      getParentRotation(): number;

      /**
       * The visible state of the Game Object.
       *
       * An invisible Game Object will skip rendering, but will still process update logic.
       */
      visible: boolean;

      /**
       * Sets the visibility of this Game Object.
       *
       * An invisible Game Object will skip rendering, but will still process update logic.
       * @param value The visible state of the Game Object.
       */
      setVisible(value: boolean): this;

    }

    namespace Zones {
      /**
       * A Death Zone.
       *
       * A Death Zone is a special type of zone that will kill a Particle as soon as it either enters, or leaves, the zone.
       *
       * The zone consists of a `source` which could be a Geometric shape, such as a Rectangle or Ellipse, or your own
       * object as long as it includes a `contains` method for which the Particles can be tested against.
       */
      class DeathZone {
        /**
         *
         * @param source An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.
         * @param killOnEnter Should the Particle be killed when it enters the zone? `true` or leaves it? `false`
         */
        constructor(source: Phaser.Types.GameObjects.Particles.DeathZoneSource, killOnEnter: boolean);

        /**
         * An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.
         * This could be a Geometry shape, such as `Phaser.Geom.Circle`, or your own custom object.
         */
        source: Phaser.Types.GameObjects.Particles.DeathZoneSource;

        /**
         * Set to `true` if the Particle should be killed if it enters this zone.
         * Set to `false` to kill the Particle if it leaves this zone.
         */
        killOnEnter: boolean;

        /**
         * Checks if the given Particle will be killed or not by this zone.
         * @param particle The Particle to be checked against this zone.
         */
        willKill(particle: Phaser.GameObjects.Particles.Particle): boolean;

      }

      /**
       * A zone that places particles on a shape's edges.
       */
      class EdgeZone {
        /**
         *
         * @param source An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.
         * @param quantity The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.
         * @param stepRate The distance between each particle. When set, `quantity` is implied and should be set to 0.
         * @param yoyo Whether particles are placed from start to end and then end to start. Default false.
         * @param seamless Whether one endpoint will be removed if it's identical to the other. Default true.
         */
        constructor(source: Phaser.Types.GameObjects.Particles.EdgeZoneSource, quantity: number, stepRate: number, yoyo?: boolean, seamless?: boolean);

        /**
         * An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.
         */
        source: Phaser.Types.GameObjects.Particles.EdgeZoneSource | Phaser.Types.GameObjects.Particles.RandomZoneSource;

        /**
         * The points placed on the source edge.
         */
        points: Phaser.Geom.Point[];

        /**
         * The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.
         */
        quantity: number;

        /**
         * The distance between each particle. When set, `quantity` is implied and should be set to 0.
         */
        stepRate: number;

        /**
         * Whether particles are placed from start to end and then end to start.
         */
        yoyo: boolean;

        /**
         * The counter used for iterating the EdgeZone's points.
         */
        counter: number;

        /**
         * Whether one endpoint will be removed if it's identical to the other.
         */
        seamless: boolean;

        /**
         * Update the {@link Phaser.GameObjects.Particles.Zones.EdgeZone#points} from the EdgeZone's
         * {@link Phaser.GameObjects.Particles.Zones.EdgeZone#source}.
         *
         * Also updates internal properties.
         */
        updateSource(): this;

        /**
         * Change the source of the EdgeZone.
         * @param source An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.
         */
        changeSource(source: Phaser.Types.GameObjects.Particles.EdgeZoneSource): this;

        /**
         * Get the next point in the Zone and set its coordinates on the given Particle.
         * @param particle The Particle.
         */
        getPoint(particle: Phaser.GameObjects.Particles.Particle): void;

      }

      /**
       * A zone that places particles randomly within a shapes area.
       */
      class RandomZone {
        /**
         *
         * @param source An object instance with a `getRandomPoint(point)` method.
         */
        constructor(source: Phaser.Types.GameObjects.Particles.RandomZoneSource);

        /**
         * An object instance with a `getRandomPoint(point)` method.
         */
        source: Phaser.Types.GameObjects.Particles.RandomZoneSource;

        /**
         * Get the next point in the Zone and set its coordinates on the given Particle.
         * @param particle The Particle.
         */
        getPoint(particle: Phaser.GameObjects.Particles.Particle): void;

      }

    }

  }

  /**
   * A PathFollower Game Object.
   *
   * A PathFollower is a Sprite Game Object with some extra helpers to allow it to follow a Path automatically.
   *
   * Anything you can do with a standard Sprite can be done with this PathFollower, such as animate it, tint it,
   * scale it and so on.
   *
   * PathFollowers are bound to a single Path at any one time and can traverse the length of the Path, from start
   * to finish, forwards or backwards, or from any given point on the Path to its end. They can optionally rotate
   * to face the direction of the path, be offset from the path coordinates or rotate independently of the Path.
   */
  class PathFollower extends Phaser.GameObjects.Sprite implements Phaser.GameObjects.Components.PathFollower {
    /**
     *
     * @param scene The Scene to which this PathFollower belongs.
     * @param path The Path this PathFollower is following. It can only follow one Path at a time.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     */
    constructor(scene: Phaser.Scene, path: Phaser.Curves.Path, x: number, y: number, texture: string | Phaser.Textures.Texture, frame?: string | number);

    /**
     * If the PathFollower is rotating to match the Path (@see Phaser.GameObjects.PathFollower#rotateToPath)
     * this value is added to the rotation value. This allows you to rotate objects to a path but control
     * the angle of the rotation as well.
     */
    pathRotationOffset: number;

    /**
     * An additional vector to add to the PathFollowers position, allowing you to offset it from the
     * Path coordinates.
     */
    pathOffset: Phaser.Math.Vector2;

    /**
     * A Vector2 that stores the current point of the path the follower is on.
     */
    pathVector: Phaser.Math.Vector2;

    /**
     * The distance the follower has traveled from the previous point to the current one, at the last update.
     */
    pathDelta: Phaser.Math.Vector2;

    /**
     * The Tween used for following the Path.
     */
    pathTween: Phaser.Tweens.Tween;

    /**
     * Settings for the PathFollower.
     */
    pathConfig: Phaser.Types.GameObjects.PathFollower.PathConfig;

    /**
     * Internal update handler that advances this PathFollower along the path.
     *
     * Called automatically by the Scene step, should not typically be called directly.
     * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param delta The delta time, in ms, elapsed since the last frame.
     */
    protected preUpdate(time: number, delta: number): void;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The horizontally flipped state of the Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipX: boolean;

    /**
     * The vertically flipped state of the Game Object.
     *
     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipY: boolean;

    /**
     * Toggles the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    toggleFlipX(): this;

    /**
     * Toggles the vertical flipped state of this Game Object.
     */
    toggleFlipY(): this;

    /**
     * Sets the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipX(value: boolean): this;

    /**
     * Sets the vertical flipped state of this Game Object.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipY(value: boolean): this;

    /**
     * Sets the horizontal and vertical flipped state of this Game Object.
     *
     * A Game Object that is flipped will render inversed on the flipped axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlip(x: boolean, y: boolean): this;

    /**
     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
     */
    resetFlip(): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the size of this Game Object to be that of the given Frame.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param frame The frame to base the size of this Game Object on.
     */
    setSizeToFrame(frame: Phaser.Textures.Frame): this;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * A boolean flag indicating if this Game Object is being cropped or not.
     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
     */
    isCropped: boolean;

    /**
     * Applies a crop to a texture based Game Object, such as a Sprite or Image.
     *
     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
     *
     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
     * changes what is shown when rendered.
     *
     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
     *
     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
     * half of it, you could call `setCrop(0, 0, 400, 600)`.
     *
     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
     *
     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
     *
     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
     *
     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
     * the renderer to skip several internal calculations.
     * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
     * @param y The y coordinate to start the crop from.
     * @param width The width of the crop rectangle in pixels.
     * @param height The height of the crop rectangle in pixels.
     */
    setCrop(x?: number | Phaser.Geom.Rectangle, y?: number, width?: number, height?: number): this;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     * @param frame The name or index of the frame within the Texture.
     * @param updateSize Should this call adjust the size of the Game Object? Default true.
     * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
     */
    setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;

    /**
     * The tint value being applied to the top-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopLeft: number;

    /**
     * The tint value being applied to the top-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopRight: number;

    /**
     * The tint value being applied to the bottom-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomLeft: number;

    /**
     * The tint value being applied to the bottom-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomRight: number;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * Clears all tint values associated with this Game Object.
     *
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     */
    clearTint(): this;

    /**
     * Sets an additive tint on this Game Object.
     *
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a fill-based tint on this Game Object.
     *
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     */
    tint: number;

    /**
     * Does this Game Object have a tint applied?
     *
     * It checks to see if the 4 tint properties are set to the value 0xffffff
     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
     */
    readonly isTinted: boolean;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

    /**
     * The Path this PathFollower is following. It can only follow one Path at a time.
     */
    path: Phaser.Curves.Path;

    /**
     * Should the PathFollower automatically rotate to point in the direction of the Path?
     */
    rotateToPath: boolean;

    /**
     * Set the Path that this PathFollower should follow.
     *
     * Optionally accepts {@link Phaser.Types.GameObjects.PathFollower.PathConfig} settings.
     * @param path The Path this PathFollower is following. It can only follow one Path at a time.
     * @param config Settings for the PathFollower.
     */
    setPath(path: Phaser.Curves.Path, config?: number | Phaser.Types.GameObjects.PathFollower.PathConfig | Phaser.Types.Tweens.NumberTweenBuilderConfig): this;

    /**
     * Set whether the PathFollower should automatically rotate to point in the direction of the Path.
     * @param value Whether the PathFollower should automatically rotate to point in the direction of the Path.
     * @param offset Rotation offset in degrees. Default 0.
     */
    setRotateToPath(value: boolean, offset?: number): this;

    /**
     * Is this PathFollower actively following a Path or not?
     *
     * To be considered as `isFollowing` it must be currently moving on a Path, and not paused.
     */
    isFollowing(): boolean;

    /**
     * Starts this PathFollower following its given Path.
     * @param config The duration of the follow, or a PathFollower config object. Default {}.
     * @param startAt Optional start position of the follow, between 0 and 1. Default 0.
     */
    startFollow(config?: number | Phaser.Types.GameObjects.PathFollower.PathConfig | Phaser.Types.Tweens.NumberTweenBuilderConfig, startAt?: number): this;

    /**
     * Pauses this PathFollower. It will still continue to render, but it will remain motionless at the
     * point on the Path at which you paused it.
     */
    pauseFollow(): this;

    /**
     * Resumes a previously paused PathFollower.
     *
     * If the PathFollower was not paused this has no effect.
     */
    resumeFollow(): this;

    /**
     * Stops this PathFollower from following the path any longer.
     *
     * This will invoke any 'stop' conditions that may exist on the Path, or for the follower.
     */
    stopFollow(): this;

    /**
     * Internal update handler that advances this PathFollower along the path.
     *
     * Called automatically by the Scene step, should not typically be called directly.
     */
    pathUpdate(): void;

  }

  /**
   * The Point Light Game Object provides a way to add a point light effect into your game,
   * without the expensive shader processing requirements of the traditional Light Game Object.
   *
   * The difference is that the Point Light renders using a custom shader, designed to give the
   * impression of a point light source, of variable radius, intensity and color, in your game.
   * However, unlike the Light Game Object, it does not impact any other Game Objects, or use their
   * normal maps for calcuations. This makes them extremely fast to render compared to Lights
   * and perfect for special effects, such as flickering torches or muzzle flashes.
   *
   * For maximum performance you should batch Point Light Game Objects together. This means
   * ensuring they follow each other consecutively on the display list. Ideally, use a Layer
   * Game Object and then add just Point Lights to it, so that it can batch together the rendering
   * of the lights. You don't _have_ to do this, and if you've only a handful of Point Lights in
   * your game then it's perfectly safe to mix them into the dislay list as normal. However, if
   * you're using a large number of them, please consider how they are mixed into the display list.
   *
   * The renderer will automatically cull Point Lights. Those with a radius that does not intersect
   * with the Camera will be skipped in the rendering list. This happens automatically and the
   * culled state is refreshed every frame, for every camera.
   *
   * The origin of a Point Light is always 0.5 and it cannot be changed.
   *
   * Point Lights are a WebGL only feature and do not have a Canvas counterpart.
   */
  class PointLight extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.AlphaSingle, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Point Light belongs. A Point Light can only belong to one Scene at a time.
     * @param x The horizontal position of this Point Light in the world.
     * @param y The vertical position of this Point Light in the world.
     * @param color The color of the Point Light, given as a hex value. Default 0xffffff.
     * @param radius The radius of the Point Light. Default 128.
     * @param intensity The intensity, or colr blend, of the Point Light. Default 1.
     * @param attenuation The attenuation  of the Point Light. This is the reduction of light from the center point. Default 0.1.
     */
    constructor(scene: Phaser.Scene, x: number, y: number, color?: number, radius?: number, intensity?: number, attenuation?: number);

    /**
     * The color of this Point Light. This property is an instance of a
     * Color object, so you can use the methods within it, such as `setTo(r, g, b)`
     * to change the color value.
     */
    color: Phaser.Display.Color;

    /**
     * The intensity of the Point Light.
     *
     * The colors of the light are multiplied by this value during rendering.
     */
    intensity: number;

    /**
     * The attenuation of the Point Light.
     *
     * This value controls the force with which the light falls-off from the center of the light.
     *
     * Use small float-based values, i.e. 0.1.
     */
    attenuation: number;

    /**
     * The radius of the Point Light.
     */
    radius: number;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * A Render Texture.
   *
   * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and
   * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic
   * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.
   *
   * Note that under WebGL a FrameBuffer, which is what the Render Texture uses internally, cannot be anti-aliased. This means
   * that when drawing objects such as Shapes to a Render Texture they will appear to be drawn with no aliasing, however this
   * is a technical limitation of WebGL. To get around it, create your shape as a texture in an art package, then draw that
   * to the Render Texture.
   */
  class RenderTexture extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Crop, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param width The width of the Render Texture. Default 32.
     * @param height The height of the Render Texture. Default 32.
     * @param key The texture key to make the RenderTexture from.
     * @param frame The frame to make the RenderTexture from.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, width?: number, height?: number, key?: string, frame?: string);

    /**
     * A reference to either the Canvas or WebGL Renderer that the Game instance is using.
     */
    renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer;

    /**
     * A reference to the Texture Manager.
     */
    textureManager: Phaser.Textures.TextureManager;

    /**
     * The tint of the Render Texture when rendered.
     */
    globalTint: number;

    /**
     * The alpha of the Render Texture when rendered.
     */
    globalAlpha: number;

    /**
     * The HTML Canvas Element that the Render Texture is drawing to when using the Canvas Renderer.
     */
    canvas: HTMLCanvasElement;

    /**
     * Is this Render Texture dirty or not? If not it won't spend time clearing or filling itself.
     */
    dirty: boolean;

    /**
     * The Texture corresponding to this Render Texture.
     */
    texture: Phaser.Textures.Texture;

    /**
     * The Frame corresponding to this Render Texture.
     */
    frame: Phaser.Textures.Frame;

    /**
     * A reference to the Rendering Context belonging to the Canvas Element this Render Texture is drawing to.
     */
    context: CanvasRenderingContext2D;

    /**
     * An internal Camera that can be used to move around the Render Texture.
     * Control it just like you would any Scene Camera. The difference is that it only impacts the placement of what
     * is drawn to the Render Texture. You can scroll, zoom and rotate this Camera.
     */
    camera: Phaser.Cameras.Scene2D.BaseCamera;

    /**
     * The Render Target that belongs to this Render Texture.
     *
     * A Render Target encapsulates a framebuffer and texture for the WebGL Renderer.
     *
     * This property remains `null` under Canvas.
     */
    renderTarget: Phaser.Renderer.WebGL.RenderTarget;

    /**
     * Sets the size of this Game Object.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Resizes the Render Texture to the new dimensions given.
     *
     * If Render Texture was created from specific frame, only the size of the frame will be changed. The size of the source
     * texture will not change.
     *
     * If Render Texture was not created from specific frame, the following will happen:
     *
     * In WebGL it will destroy and then re-create the frame buffer being used by the Render Texture.
     * In Canvas it will resize the underlying canvas element.
     *
     * Both approaches will erase everything currently drawn to the Render Texture.
     *
     * If the dimensions given are the same as those already being used, calling this method will do nothing.
     * @param width The new width of the Render Texture.
     * @param height The new height of the Render Texture. If not specified, will be set the same as the `width`. Default width.
     */
    resize(width: number, height?: number): this;

    /**
     * Set the tint to use when rendering this Render Texture.
     * @param tint The tint value.
     */
    setGlobalTint(tint: number): this;

    /**
     * Set the alpha to use when rendering this Render Texture.
     * @param alpha The alpha value.
     */
    setGlobalAlpha(alpha: number): this;

    /**
     * Stores a copy of this Render Texture in the Texture Manager using the given key.
     *
     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of this
     * Render Texture by using the texture key:
     *
     * ```javascript
     * var rt = this.add.renderTexture(0, 0, 128, 128);
     *
     * // Draw something to the Render Texture
     *
     * rt.saveTexture('doodle');
     *
     * this.add.image(400, 300, 'doodle');
     * ```
     *
     * Updating the contents of this Render Texture will automatically update _any_ Game Object
     * that is using it as a texture. Calling `saveTexture` again will not save another copy
     * of the same texture, it will just rename the key of the existing copy.
     *
     * By default it will create a single base texture. You can add frames to the texture
     * by using the `Texture.add` method. After doing this, you can then allow Game Objects
     * to use a specific frame from a Render Texture.
     *
     * If you destroy this Render Texture, any Game Object using it via the Texture Manager will
     * stop rendering. Ensure you remove the texture from the Texture Manager and any Game Objects
     * using it first, before destroying this Render Texture.
     * @param key The unique key to store the texture as within the global Texture Manager.
     */
    saveTexture(key: string): Phaser.Textures.Texture;

    /**
     * Fills the Render Texture with the given color.
     * @param rgb The color to fill the Render Texture with.
     * @param alpha The alpha value used by the fill. Default 1.
     * @param x The left coordinate of the fill rectangle. Default 0.
     * @param y The top coordinate of the fill rectangle. Default 0.
     * @param width The width of the fill rectangle. Default this.frame.cutWidth.
     * @param height The height of the fill rectangle. Default this.frame.cutHeight.
     */
    fill(rgb: number, alpha?: number, x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Clears the Render Texture.
     */
    clear(): this;

    /**
     * Draws the given object, or an array of objects, to this Render Texture using a blend mode of ERASE.
     * This has the effect of erasing any filled pixels in the objects from this Render Texture.
     *
     * It can accept any of the following:
     *
     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.
     * * Tilemap Layers.
     * * A Group. The contents of which will be iterated and drawn in turn.
     * * A Container. The contents of which will be iterated fully, and drawn in turn.
     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.
     * * Another Render Texture.
     * * A Texture Frame instance.
     * * A string. This is used to look-up a texture from the Texture Manager.
     *
     * Note: You cannot erase a Render Texture from itself.
     *
     * If passing in a Group or Container it will only draw children that return `true`
     * when their `willRender()` method is called. I.e. a Container with 10 children,
     * 5 of which have `visible=false` will only draw the 5 visible ones.
     *
     * If passing in an array of Game Objects it will draw them all, regardless if
     * they pass a `willRender` check or not.
     *
     * You can pass in a string in which case it will look for a texture in the Texture
     * Manager matching that string, and draw the base frame.
     *
     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of
     * the coordinates differ based on what objects are being drawn. If the object is
     * a Group, Container or Display List, the coordinates are _added_ to the positions
     * of the children. For all other types of object, the coordinates are exact.
     *
     * Calling this method causes the WebGL batch to flush, so it can write the texture
     * data to the framebuffer being used internally. The batch is flushed at the end,
     * after the entries have been iterated. So if you've a bunch of objects to draw,
     * try and pass them in an array in one single call, rather than making lots of
     * separate calls.
     * @param entries Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.
     * @param x The x position to draw the Frame at, or the offset applied to the object.
     * @param y The y position to draw the Frame at, or the offset applied to the object.
     */
    erase(entries: any, x?: number, y?: number): this;

    /**
     * Draws the given object, or an array of objects, to this Render Texture.
     *
     * It can accept any of the following:
     *
     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.
     * * Tilemap Layers.
     * * A Group. The contents of which will be iterated and drawn in turn.
     * * A Container. The contents of which will be iterated fully, and drawn in turn.
     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.
     * * Another Render Texture.
     * * A Texture Frame instance.
     * * A string. This is used to look-up a texture from the Texture Manager.
     *
     * Note: You cannot draw a Render Texture to itself.
     *
     * If passing in a Group or Container it will only draw children that return `true`
     * when their `willRender()` method is called. I.e. a Container with 10 children,
     * 5 of which have `visible=false` will only draw the 5 visible ones.
     *
     * If passing in an array of Game Objects it will draw them all, regardless if
     * they pass a `willRender` check or not.
     *
     * You can pass in a string in which case it will look for a texture in the Texture
     * Manager matching that string, and draw the base frame. If you need to specify
     * exactly which frame to draw then use the method `drawFrame` instead.
     *
     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of
     * the coordinates differ based on what objects are being drawn. If the object is
     * a Group, Container or Display List, the coordinates are _added_ to the positions
     * of the children. For all other types of object, the coordinates are exact.
     *
     * The `alpha` and `tint` values are only used by Texture Frames.
     * Game Objects use their own alpha and tint values when being drawn.
     *
     * Calling this method causes the WebGL batch to flush, so it can write the texture
     * data to the framebuffer being used internally. The batch is flushed at the end,
     * after the entries have been iterated. So if you've a bunch of objects to draw,
     * try and pass them in an array in one single call, rather than making lots of
     * separate calls.
     * @param entries Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.
     * @param x The x position to draw the Frame at, or the offset applied to the object.
     * @param y The y position to draw the Frame at, or the offset applied to the object.
     * @param alpha The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.
     * @param tint WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.
     */
    draw(entries: any, x?: number, y?: number, alpha?: number, tint?: number): this;

    /**
     * Draws the Texture Frame to the Render Texture at the given position.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     *
     * ```javascript
     * var rt = this.add.renderTexture(0, 0, 800, 600);
     * rt.drawFrame(key, frame);
     * ```
     *
     * You can optionally provide a position, alpha and tint value to apply to the frame
     * before it is drawn.
     *
     * Calling this method will cause a batch flush, so if you've got a stack of things to draw
     * in a tight loop, try using the `draw` method instead.
     *
     * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.
     * @param key The key of the texture to be used, as stored in the Texture Manager.
     * @param frame The name or index of the frame within the Texture.
     * @param x The x position to draw the frame at. Default 0.
     * @param y The y position to draw the frame at. Default 0.
     * @param alpha The alpha to use. If not specified it uses the `globalAlpha` property.
     * @param tint WebGL only. The tint color to use. If not specified it uses the `globalTint` property.
     */
    drawFrame(key: string, frame?: string | number, x?: number, y?: number, alpha?: number, tint?: number): this;

    /**
     * Use this method if you need to batch draw a large number of Game Objects to
     * this Render Texture in a single go, or on a frequent basis.
     *
     * This method starts the beginning of a batched draw.
     *
     * It is faster than calling `draw`, but you must be very careful to manage the
     * flow of code and remember to call `endDraw()`. If you don't need to draw large
     * numbers of objects it's much safer and easier to use the `draw` method instead.
     *
     * The flow should be:
     *
     * ```javascript
     * // Call once:
     * RenderTexture.beginDraw();
     *
     * // repeat n times:
     * RenderTexture.batchDraw();
     * // or
     * RenderTexture.batchDrawFrame();
     *
     * // Call once:
     * RenderTexture.endDraw();
     * ```
     *
     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you
     * have started a batch. Also, be very careful not to destroy this Render Texture while the
     * batch is still open, or call `beginDraw` again.
     */
    beginDraw(): this;

    /**
     * Use this method if you have already called `beginDraw` and need to batch
     * draw a large number of objects to this Render Texture.
     *
     * This method batches the drawing of the given objects to this Render Texture,
     * without causing a bind or batch flush.
     *
     * It is faster than calling `draw`, but you must be very careful to manage the
     * flow of code and remember to call `endDraw()`. If you don't need to draw large
     * numbers of objects it's much safer and easier to use the `draw` method instead.
     *
     * The flow should be:
     *
     * ```javascript
     * // Call once:
     * RenderTexture.beginDraw();
     *
     * // repeat n times:
     * RenderTexture.batchDraw();
     * // or
     * RenderTexture.batchDrawFrame();
     *
     * // Call once:
     * RenderTexture.endDraw();
     * ```
     *
     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you
     * have started a batch. Also, be very careful not to destroy this Render Texture while the
     * batch is still open, or call `beginDraw` again.
     *
     * Draws the given object, or an array of objects, to this Render Texture.
     *
     * It can accept any of the following:
     *
     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.
     * * Tilemap Layers.
     * * A Group. The contents of which will be iterated and drawn in turn.
     * * A Container. The contents of which will be iterated fully, and drawn in turn.
     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.
     * * Another Render Texture.
     * * A Texture Frame instance.
     * * A string. This is used to look-up a texture from the Texture Manager.
     *
     * Note: You cannot draw a Render Texture to itself.
     *
     * If passing in a Group or Container it will only draw children that return `true`
     * when their `willRender()` method is called. I.e. a Container with 10 children,
     * 5 of which have `visible=false` will only draw the 5 visible ones.
     *
     * If passing in an array of Game Objects it will draw them all, regardless if
     * they pass a `willRender` check or not.
     *
     * You can pass in a string in which case it will look for a texture in the Texture
     * Manager matching that string, and draw the base frame. If you need to specify
     * exactly which frame to draw then use the method `drawFrame` instead.
     *
     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of
     * the coordinates differ based on what objects are being drawn. If the object is
     * a Group, Container or Display List, the coordinates are _added_ to the positions
     * of the children. For all other types of object, the coordinates are exact.
     *
     * The `alpha` and `tint` values are only used by Texture Frames.
     * Game Objects use their own alpha and tint values when being drawn.
     * @param entries Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.
     * @param x The x position to draw the Frame at, or the offset applied to the object.
     * @param y The y position to draw the Frame at, or the offset applied to the object.
     * @param alpha The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.
     * @param tint WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.
     */
    batchDraw(entries: any, x?: number, y?: number, alpha?: number, tint?: number): this;

    /**
     * Use this method if you have already called `beginDraw` and need to batch
     * draw a large number of texture frames to this Render Texture.
     *
     * This method batches the drawing of the given frames to this Render Texture,
     * without causing a bind or batch flush.
     *
     * It is faster than calling `drawFrame`, but you must be very careful to manage the
     * flow of code and remember to call `endDraw()`. If you don't need to draw large
     * numbers of frames it's much safer and easier to use the `drawFrame` method instead.
     *
     * The flow should be:
     *
     * ```javascript
     * // Call once:
     * RenderTexture.beginDraw();
     *
     * // repeat n times:
     * RenderTexture.batchDraw();
     * // or
     * RenderTexture.batchDrawFrame();
     *
     * // Call once:
     * RenderTexture.endDraw();
     * ```
     *
     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you
     * have started a batch. Also, be very careful not to destroy this Render Texture while the
     * batch is still open, or call `beginDraw` again.
     *
     * Draws the Texture Frame to the Render Texture at the given position.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     *
     * ```javascript
     * var rt = this.add.renderTexture(0, 0, 800, 600);
     * rt.drawFrame(key, frame);
     * ```
     *
     * You can optionally provide a position, alpha and tint value to apply to the frame
     * before it is drawn.
     *
     * Calling this method will cause a batch flush, so if you've got a stack of things to draw
     * in a tight loop, try using the `draw` method instead.
     *
     * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.
     * @param key The key of the texture to be used, as stored in the Texture Manager.
     * @param frame The name or index of the frame within the Texture.
     * @param x The x position to draw the frame at. Default 0.
     * @param y The y position to draw the frame at. Default 0.
     * @param alpha The alpha to use. If not specified it uses the `globalAlpha` property.
     * @param tint WebGL only. The tint color to use. If not specified it uses the `globalTint` property.
     */
    batchDrawFrame(key: string, frame?: string | number, x?: number, y?: number, alpha?: number, tint?: number): this;

    /**
     * Use this method to finish batch drawing to this Render Texture.
     *
     * Never call this method without first calling `beginDraw`.
     *
     * It is faster than calling `draw`, but you must be very careful to manage the
     * flow of code and remember to call `endDraw()`. If you don't need to draw large
     * numbers of objects it's much safer and easier to use the `draw` method instead.
     *
     * The flow should be:
     *
     * ```javascript
     * // Call once:
     * RenderTexture.beginDraw();
     *
     * // repeat n times:
     * RenderTexture.batchDraw();
     * // or
     * RenderTexture.batchDrawFrame();
     *
     * // Call once:
     * RenderTexture.endDraw();
     * ```
     *
     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you
     * have started a batch. Also, be very careful not to destroy this Render Texture while the
     * batch is still open, or call `beginDraw` again.
     * @param erase Draws all objects in this batch using a blend mode of ERASE. This has the effect of erasing any filled pixels in the objects being drawn. Default false.
     */
    endDraw(erase?: boolean): this;

    /**
     * Takes a snapshot of the given area of this Render Texture.
     *
     * The snapshot is taken immediately.
     *
     * To capture the whole Render Texture see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.
     *
     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.
     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,
     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,
     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
     * @param x The x coordinate to grab from.
     * @param y The y coordinate to grab from.
     * @param width The width of the area to grab.
     * @param height The height of the area to grab.
     * @param callback The Function to invoke after the snapshot image is created.
     * @param type The format of the image to create, usually `image/png` or `image/jpeg`. Default 'image/png'.
     * @param encoderOptions The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`. Default 0.92.
     */
    snapshotArea(x: number, y: number, width: number, height: number, callback: Phaser.Types.Renderer.Snapshot.SnapshotCallback, type?: string, encoderOptions?: number): this;

    /**
     * Takes a snapshot of the whole of this Render Texture.
     *
     * The snapshot is taken immediately.
     *
     * To capture just a portion of the Render Texture see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.
     *
     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.
     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,
     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,
     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
     * @param callback The Function to invoke after the snapshot image is created.
     * @param type The format of the image to create, usually `image/png` or `image/jpeg`. Default 'image/png'.
     * @param encoderOptions The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`. Default 0.92.
     */
    snapshot(callback: Phaser.Types.Renderer.Snapshot.SnapshotCallback, type?: string, encoderOptions?: number): this;

    /**
     * Takes a snapshot of the given pixel from this Render Texture.
     *
     * The snapshot is taken immediately.
     *
     * To capture the whole Render Texture see the `snapshot` method. To capture a specific portion, see `snapshotArea`.
     *
     * Unlike the other two snapshot methods, this one will send your callback a `Color` object containing the color data for
     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,
     * using less memory, than the other snapshot methods.
     * @param x The x coordinate of the pixel to get.
     * @param y The y coordinate of the pixel to get.
     * @param callback The Function to invoke after the snapshot pixel data is extracted.
     */
    snapshotPixel(x: number, y: number, callback: Phaser.Types.Renderer.Snapshot.SnapshotCallback): this;

    /**
     * Internal destroy handler, called as part of the destroy process.
     */
    protected preDestroy(): void;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * A boolean flag indicating if this Game Object is being cropped or not.
     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
     */
    isCropped: boolean;

    /**
     * Applies a crop to a texture based Game Object, such as a Sprite or Image.
     *
     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
     *
     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
     * changes what is shown when rendered.
     *
     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
     *
     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
     * half of it, you could call `setCrop(0, 0, 400, 600)`.
     *
     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
     *
     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
     *
     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
     *
     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
     * the renderer to skip several internal calculations.
     * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
     * @param y The y coordinate to start the crop from.
     * @param width The width of the crop rectangle in pixels.
     * @param height The height of the crop rectangle in pixels.
     */
    setCrop(x?: number | Phaser.Geom.Rectangle, y?: number, width?: number, height?: number): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The horizontally flipped state of the Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipX: boolean;

    /**
     * The vertically flipped state of the Game Object.
     *
     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipY: boolean;

    /**
     * Toggles the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    toggleFlipX(): this;

    /**
     * Toggles the vertical flipped state of this Game Object.
     */
    toggleFlipY(): this;

    /**
     * Sets the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipX(value: boolean): this;

    /**
     * Sets the vertical flipped state of this Game Object.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipY(value: boolean): this;

    /**
     * Sets the horizontal and vertical flipped state of this Game Object.
     *
     * A Game Object that is flipped will render inversed on the flipped axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlip(x: boolean, y: boolean): this;

    /**
     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
     */
    resetFlip(): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The tint value being applied to the top-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopLeft: number;

    /**
     * The tint value being applied to the top-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopRight: number;

    /**
     * The tint value being applied to the bottom-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomLeft: number;

    /**
     * The tint value being applied to the bottom-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomRight: number;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * Clears all tint values associated with this Game Object.
     *
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     */
    clearTint(): this;

    /**
     * Sets an additive tint on this Game Object.
     *
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a fill-based tint on this Game Object.
     *
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     */
    tint: number;

    /**
     * Does this Game Object have a tint applied?
     *
     * It checks to see if the 4 tint properties are set to the value 0xffffff
     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
     */
    readonly isTinted: boolean;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * A Rope Game Object.
   *
   * The Rope object is WebGL only and does not have a Canvas counterpart.
   *
   * A Rope is a special kind of Game Object that has a texture that repeats along its entire length.
   * Unlike a Sprite, it isn't restricted to using just a quad and can have as many vertices as you define
   * when creating it. The vertices can be arranged in a horizontal or vertical strip and have their own
   * color and alpha values as well.
   *
   * A Ropes origin is always 0.5 x 0.5 and cannot be changed.
   */
  class Rope extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.AlphaSingle, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible, Phaser.GameObjects.Components.ScrollFactor {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager. If not given, `__DEFAULT` is used.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     * @param points An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided a simple quad is created. See `setPoints` to set this post-creation. Default 2.
     * @param horizontal Should the vertices of this Rope be aligned horizontally (`true`), or vertically (`false`)? Default true.
     * @param colors An optional array containing the color data for this Rope. You should provide one color value per pair of vertices.
     * @param alphas An optional array containing the alpha data for this Rope. You should provide one alpha value per pair of vertices.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, texture?: string, frame?: string | number | null, points?: number | Phaser.Types.Math.Vector2Like[], horizontal?: boolean, colors?: number[], alphas?: number[]);

    /**
     * The Animation State of this Rope.
     */
    anims: Phaser.Animations.AnimationState;

    /**
     * An array containing the points data for this Rope.
     *
     * Each point should be given as a Vector2Like object (i.e. a Vector2, Geom.Point or object with public x/y properties).
     *
     * The point coordinates are given in local space, where 0 x 0 is the start of the Rope strip.
     *
     * You can modify the contents of this array directly in real-time to create interesting effects.
     * If you do so, be sure to call `setDirty` _after_ modifying this array, so that the vertices data is
     * updated before the next render. Alternatively, you can use the `setPoints` method instead.
     *
     * Should you need to change the _size_ of this array, then you should always use the `setPoints` method.
     */
    points: Phaser.Types.Math.Vector2Like[];

    /**
     * An array containing the vertices data for this Rope.
     *
     * This data is calculated automatically in the `updateVertices` method, based on the points provided.
     */
    vertices: Float32Array;

    /**
     * An array containing the uv data for this Rope.
     *
     * This data is calculated automatically in the `setPoints` method, based on the points provided.
     */
    uv: Float32Array;

    /**
     * An array containing the color data for this Rope.
     *
     * Colors should be given as numeric RGB values, such as 0xff0000.
     * You should provide _two_ color values for every point in the Rope, one for the top and one for the bottom of each quad.
     *
     * You can modify the contents of this array directly in real-time, however, should you need to change the _size_
     * of the array, then you should use the `setColors` method instead.
     */
    colors: Uint32Array;

    /**
     * An array containing the alpha data for this Rope.
     *
     * Alphas should be given as float values, such as 0.5.
     * You should provide _two_ alpha values for every point in the Rope, one for the top and one for the bottom of each quad.
     *
     * You can modify the contents of this array directly in real-time, however, should you need to change the _size_
     * of the array, then you should use the `setAlphas` method instead.
     */
    alphas: Float32Array;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * If the Rope is marked as `dirty` it will automatically recalculate its vertices
     * the next time it renders. You can also force this by calling `updateVertices`.
     */
    dirty: boolean;

    /**
     * Are the Rope vertices aligned horizontally, in a strip, or vertically, in a column?
     *
     * This property is set during instantiation and cannot be changed directly.
     * See the `setVertical` and `setHorizontal` methods.
     */
    readonly horizontal: boolean;

    /**
     * You can optionally choose to render the vertices of this Rope to a Graphics instance.
     *
     * Achieve this by setting the `debugCallback` and the `debugGraphic` properties.
     *
     * You can do this in a single call via the `Rope.setDebug` method, which will use the
     * built-in debug function. You can also set it to your own callback. The callback
     * will be invoked _once per render_ and sent the following parameters:
     *
     * `debugCallback(src, meshLength, verts)`
     *
     * `src` is the Rope instance being debugged.
     * `meshLength` is the number of mesh vertices in total.
     * `verts` is an array of the translated vertex coordinates.
     *
     * To disable rendering, set this property back to `null`.
     */
    debugCallback: Function;

    /**
     * The Graphics instance that the debug vertices will be drawn to, if `setDebug` has
     * been called.
     */
    debugGraphic: Phaser.GameObjects.Graphics;

    /**
     * The Rope update loop.
     * @param time The current timestamp.
     * @param delta The delta time, in ms, elapsed since the last frame.
     */
    protected preUpdate(time: number, delta: number): void;

    /**
     * Start playing the given animation.
     * @param key The string-based key of the animation to play.
     * @param ignoreIfPlaying If an animation is already playing then ignore this call. Default false.
     * @param startFrame Optionally start the animation playing from this frame index. Default 0.
     */
    play(key: string, ignoreIfPlaying?: boolean, startFrame?: number): this;

    /**
     * Flags this Rope as being dirty. A dirty rope will recalculate all of its vertices data
     * the _next_ time it renders. You should set this rope as dirty if you update the points
     * array directly.
     */
    setDirty(): this;

    /**
     * Sets the alignment of the points in this Rope to be horizontal, in a strip format.
     *
     * Calling this method will reset this Rope. The current points, vertices, colors and alpha
     * values will be reset to thoes values given as parameters.
     * @param points An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided the current points length is used.
     * @param colors Either a single color value, or an array of values.
     * @param alphas Either a single alpha value, or an array of values.
     */
    setHorizontal(points?: number | Phaser.Types.Math.Vector2Like[], colors?: number | number[], alphas?: number | number[]): this;

    /**
     * Sets the alignment of the points in this Rope to be vertical, in a column format.
     *
     * Calling this method will reset this Rope. The current points, vertices, colors and alpha
     * values will be reset to thoes values given as parameters.
     * @param points An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided the current points length is used.
     * @param colors Either a single color value, or an array of values.
     * @param alphas Either a single alpha value, or an array of values.
     */
    setVertical(points?: number | Phaser.Types.Math.Vector2Like[], colors?: number | number[], alphas?: number | number[]): this;

    /**
     * Sets the tint fill mode.
     *
     * Mode 0 (`false`) is an additive tint, the default, which blends the vertices colors with the texture.
     * This mode respects the texture alpha.
     *
     * Mode 1 (`true`) is a fill tint. Unlike an additive tint, a fill-tint literally replaces the pixel colors
     * from the texture with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. This mode respects the texture alpha.
     *
     * See the `setColors` method for details of how to color each of the vertices.
     * @param value Set to `false` for an Additive tint or `true` fill tint with alpha. Default false.
     */
    setTintFill(value?: boolean): this;

    /**
     * Set the alpha values used by the Rope during rendering.
     *
     * You can provide the values in a number of ways:
     *
     * 1) One single numeric value: `setAlphas(0.5)` - This will set a single alpha for the whole Rope.
     * 2) Two numeric value: `setAlphas(1, 0.5)` - This will set a 'top' and 'bottom' alpha value across the whole Rope.
     * 3) An array of values: `setAlphas([ 1, 0.5, 0.2 ])`
     *
     * If you provide an array of values and the array has exactly the same number of values as `points` in the Rope, it
     * will use each alpha value per rope segment.
     *
     * If the provided array has a different number of values than `points` then it will use the values in order, from
     * the first Rope segment and on, until it runs out of values. This allows you to control the alpha values at all
     * vertices in the Rope.
     *
     * Note this method is called `setAlphas` (plural) and not `setAlpha`.
     * @param alphas Either a single alpha value, or an array of values. If nothing is provided alpha is reset to 1.
     * @param bottomAlpha An optional bottom alpha value. See the method description for details.
     */
    setAlphas(alphas?: number | number[], bottomAlpha?: number): this;

    /**
     * Set the color values used by the Rope during rendering.
     *
     * Colors are used to control the level of tint applied across the Rope texture.
     *
     * You can provide the values in a number of ways:
     *
     * * One single numeric value: `setColors(0xff0000)` - This will set a single color tint for the whole Rope.
     * * An array of values: `setColors([ 0xff0000, 0x00ff00, 0x0000ff ])`
     *
     * If you provide an array of values and the array has exactly the same number of values as `points` in the Rope, it
     * will use each color per rope segment.
     *
     * If the provided array has a different number of values than `points` then it will use the values in order, from
     * the first Rope segment and on, until it runs out of values. This allows you to control the color values at all
     * vertices in the Rope.
     * @param colors Either a single color value, or an array of values. If nothing is provided color is reset to 0xffffff.
     */
    setColors(colors?: number | number[]): this;

    /**
     * Sets the points used by this Rope.
     *
     * The points should be provided as an array of Vector2, or vector2-like objects (i.e. those with public x/y properties).
     *
     * Each point corresponds to one segment of the Rope. The more points in the array, the more segments the rope has.
     *
     * Point coordinates are given in local-space, not world-space, and are directly related to the size of the texture
     * this Rope object is using.
     *
     * For example, a Rope using a 512 px wide texture, split into 4 segments (128px each) would use the following points:
     *
     * ```javascript
     * rope.setPoints([
     *   { x: 0, y: 0 },
     *   { x: 128, y: 0 },
     *   { x: 256, y: 0 },
     *   { x: 384, y: 0 }
     * ]);
     * ```
     *
     * Or, you can provide an integer to do the same thing:
     *
     * ```javascript
     * rope.setPoints(4);
     * ```
     *
     * Which will divide the Rope into 4 equally sized segments based on the frame width.
     *
     * Note that calling this method with a different number of points than the Rope has currently will
     * _reset_ the color and alpha values, unless you provide them as arguments to this method.
     * @param points An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided a simple quad is created. Default 2.
     * @param colors Either a single color value, or an array of values.
     * @param alphas Either a single alpha value, or an array of values.
     */
    setPoints(points?: number | Phaser.Types.Math.Vector2Like[], colors?: number | number[], alphas?: number | number[]): this;

    /**
     * Updates all of the UVs based on the Rope.points and `flipX` and `flipY` settings.
     */
    updateUVs(): this;

    /**
     * Resizes all of the internal arrays: `vertices`, `uv`, `colors` and `alphas` to the new
     * given Rope segment total.
     * @param newSize The amount of segments to split the Rope in to.
     */
    resizeArrays(newSize: number): this;

    /**
     * Updates the vertices based on the Rope points.
     *
     * This method is called automatically during rendering if `Rope.dirty` is `true`, which is set
     * by the `setPoints` and `setDirty` methods. You should flag the Rope as being dirty if you modify
     * the Rope points directly.
     */
    updateVertices(): this;

    /**
     * This method enables rendering of the Rope vertices to the given Graphics instance.
     *
     * If you enable this feature, you **must** call `Graphics.clear()` in your Scene `update`,
     * otherwise the Graphics instance you provide to debug will fill-up with draw calls,
     * eventually crashing the browser. This is not done automatically to allow you to debug
     * draw multiple Rope objects to a single Graphics instance.
     *
     * The Rope class has a built-in debug rendering callback `Rope.renderDebugVerts`, however
     * you can also provide your own callback to be used instead. Do this by setting the `callback` parameter.
     *
     * The callback is invoked _once per render_ and sent the following parameters:
     *
     * `callback(src, meshLength, verts)`
     *
     * `src` is the Rope instance being debugged.
     * `meshLength` is the number of mesh vertices in total.
     * `verts` is an array of the translated vertex coordinates.
     *
     * If using your own callback you do not have to provide a Graphics instance to this method.
     *
     * To disable debug rendering, to either your own callback or the built-in one, call this method
     * with no arguments.
     * @param graphic The Graphic instance to render to if using the built-in callback.
     * @param callback The callback to invoke during debug render. Leave as undefined to use the built-in callback.
     */
    setDebug(graphic?: Phaser.GameObjects.Graphics, callback?: Function): this;

    /**
     * The built-in Rope vertices debug rendering method.
     *
     * See `Rope.setDebug` for more details.
     * @param src The Rope object being rendered.
     * @param meshLength The number of vertices in the mesh.
     * @param verts An array of translated vertex coordinates.
     */
    renderDebugVerts(src: Phaser.GameObjects.Rope, meshLength: number, verts: number[]): void;

    /**
     * The horizontally flipped state of the Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipX: boolean;

    /**
     * The vertically flipped state of the Game Object.
     *
     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipY: boolean;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Toggles the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    toggleFlipX(): this;

    /**
     * Toggles the vertical flipped state of this Game Object.
     */
    toggleFlipY(): this;

    /**
     * Sets the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipX(value: boolean): this;

    /**
     * Sets the vertical flipped state of this Game Object.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipY(value: boolean): this;

    /**
     * Sets the horizontal and vertical flipped state of this Game Object.
     *
     * A Game Object that is flipped will render inversed on the flipped axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlip(x: boolean, y: boolean): this;

    /**
     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
     */
    resetFlip(): this;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the size of this Game Object to be that of the given Frame.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param frame The frame to base the size of this Game Object on.
     */
    setSizeToFrame(frame: Phaser.Textures.Frame): this;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager, or a Texture instance.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string | Phaser.Textures.Texture, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     * @param frame The name or index of the frame within the Texture.
     * @param updateSize Should this call adjust the size of the Game Object? Default true.
     * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
     */
    setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

  }

  /**
   * A Shader Game Object.
   *
   * This Game Object allows you to easily add a quad with its own shader into the display list, and manipulate it
   * as you would any other Game Object, including scaling, rotating, positioning and adding to Containers. Shaders
   * can be masked with either Bitmap or Geometry masks and can also be used as a Bitmap Mask for a Camera or other
   * Game Object. They can also be made interactive and used for input events.
   *
   * It works by taking a reference to a `Phaser.Display.BaseShader` instance, as found in the Shader Cache. These can
   * be created dynamically at runtime, or loaded in via the GLSL File Loader:
   *
   * ```javascript
   * function preload ()
   * {
   *     this.load.glsl('fire', 'shaders/fire.glsl.js');
   * }
   *
   * function create ()
   * {
   *     this.add.shader('fire', 400, 300, 512, 512);
   * }
   * ```
   *
   * Please see the Phaser 3 Examples GitHub repo for examples of loading and creating shaders dynamically.
   *
   * Due to the way in which they work, you cannot directly change the alpha or blend mode of a Shader. This should
   * be handled via exposed uniforms in the shader code itself.
   *
   * By default a Shader will be created with a standard set of uniforms. These were added to match those
   * found on sites such as ShaderToy or GLSLSandbox, and provide common functionality a shader may need,
   * such as the timestamp, resolution or pointer position. You can replace them by specifying your own uniforms
   * in the Base Shader.
   *
   * These Shaders work by halting the current pipeline during rendering, creating a viewport matched to the
   * size of this Game Object and then renders a quad using the bound shader. At the end, the pipeline is restored.
   *
   * Because it blocks the pipeline it means it will interrupt any batching that is currently going on, so you should
   * use these Game Objects sparingly. If you need to have a fully batched custom shader, then please look at using
   * a custom pipeline instead. However, for background or special masking effects, they are extremely effective.
   */
  class Shader extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param key The key of the shader to use from the shader cache, or a BaseShader instance.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param width The width of the Game Object. Default 128.
     * @param height The height of the Game Object. Default 128.
     * @param textures Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.
     * @param textureData Additional texture data if you want to create shader with none NPOT textures.
     */
    constructor(scene: Phaser.Scene, key: string | Phaser.Display.BaseShader, x?: number, y?: number, width?: number, height?: number, textures?: string[], textureData?: any);

    /**
     * The underlying shader object being used.
     * Empty by default and set during a call to the `setShader` method.
     */
    shader: Phaser.Display.BaseShader;

    /**
     * A reference to the current renderer.
     * Shaders only work with the WebGL Renderer.
     */
    renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer;

    /**
     * The WebGL context belonging to the renderer.
     */
    gl: WebGLRenderingContext;

    /**
     * Raw byte buffer of vertices this Shader uses.
     */
    vertexData: ArrayBuffer;

    /**
     * The WebGL vertex buffer object this shader uses.
     */
    vertexBuffer: WebGLBuffer;

    /**
     * The WebGL shader program this shader uses.
     */
    program: WebGLProgram;

    /**
     * Uint8 view to the vertex raw buffer. Used for uploading vertex buffer resources to the GPU.
     */
    bytes: Uint8Array;

    /**
     * Float32 view of the array buffer containing the shaders vertices.
     */
    vertexViewF32: Float32Array;

    /**
     * The view matrix the shader uses during rendering.
     */
    readonly viewMatrix: Float32Array;

    /**
     * The projection matrix the shader uses during rendering.
     */
    readonly projectionMatrix: Float32Array;

    /**
     * The default uniform mappings. These can be added to (or replaced) by specifying your own uniforms when
     * creating this shader game object. The uniforms are updated automatically during the render step.
     *
     * The defaults are:
     *
     * `resolution` (2f) - Set to the size of this shader.
     * `time` (1f) - The elapsed game time, in seconds.
     * `mouse` (2f) - If a pointer has been bound (with `setPointer`), this uniform contains its position each frame.
     * `date` (4fv) - A vec4 containing the year, month, day and time in seconds.
     * `sampleRate` (1f) - Sound sample rate. 44100 by default.
     * `iChannel0...3` (sampler2D) - Input channels 0 to 3. `null` by default.
     */
    uniforms: any;

    /**
     * The pointer bound to this shader, if any.
     * Set via the chainable `setPointer` method, or by modifying this property directly.
     */
    pointer: Phaser.Input.Pointer;

    /**
     * A reference to the GL Frame Buffer this Shader is drawing to.
     * This property is only set if you have called `Shader.setRenderToTexture`.
     */
    framebuffer: WebGLFramebuffer;

    /**
     * A reference to the WebGLTexture this Shader is rendering to.
     * This property is only set if you have called `Shader.setRenderToTexture`.
     */
    glTexture: WebGLTexture;

    /**
     * A flag that indicates if this Shader has been set to render to a texture instead of the display list.
     *
     * This property is `true` if you have called `Shader.setRenderToTexture`, otherwise it's `false`.
     *
     * A Shader that is rendering to a texture _does not_ appear on the display list.
     */
    readonly renderToTexture: boolean;

    /**
     * A reference to the Phaser.Textures.Texture that has been stored in the Texture Manager for this Shader.
     *
     * This property is only set if you have called `Shader.setRenderToTexture`, otherwise it is `null`.
     */
    texture: Phaser.Textures.Texture;

    /**
     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
     * Also checks the Game Object against the given Cameras exclusion list.
     * @param camera The Camera to check against this Game Object.
     */
    willRender(camera: Phaser.Cameras.Scene2D.Camera): boolean;

    /**
     * Changes this Shader so instead of rendering to the display list it renders to a
     * WebGL Framebuffer and WebGL Texture instead. This allows you to use the output
     * of this shader as an input for another shader, by mapping a sampler2D uniform
     * to it.
     *
     * After calling this method the `Shader.framebuffer` and `Shader.glTexture` properties
     * are populated.
     *
     * Additionally, you can provide a key to this method. Doing so will create a Phaser Texture
     * from this Shader and save it into the Texture Manager, allowing you to then use it for
     * any texture-based Game Object, such as a Sprite or Image:
     *
     * ```javascript
     * var shader = this.add.shader('myShader', x, y, width, height);
     *
     * shader.setRenderToTexture('doodle');
     *
     * this.add.image(400, 300, 'doodle');
     * ```
     *
     * Note that it stores an active reference to this Shader. That means as this shader updates,
     * so does the texture and any object using it to render with. Also, if you destroy this
     * shader, be sure to clear any objects that may have been using it as a texture too.
     *
     * You can access the Phaser Texture that is created via the `Shader.texture` property.
     *
     * By default it will create a single base texture. You can add frames to the texture
     * by using the `Texture.add` method. After doing this, you can then allow Game Objects
     * to use a specific frame from a Render Texture.
     * @param key The unique key to store the texture as within the global Texture Manager.
     * @param flipY Does this texture need vertically flipping before rendering? This should usually be set to `true` if being fed from a buffer. Default false.
     */
    setRenderToTexture(key?: string, flipY?: boolean): this;

    /**
     * Sets the fragment and, optionally, the vertex shader source code that this Shader will use.
     * This will immediately delete the active shader program, if set, and then create a new one
     * with the given source. Finally, the shader uniforms are initialized.
     * @param key The key of the shader to use from the shader cache, or a BaseShader instance.
     * @param textures Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.
     * @param textureData Additional texture data.
     */
    setShader(key: string | Phaser.Display.BaseShader, textures?: string[], textureData?: any): this;

    /**
     * Binds a Phaser Pointer object to this Shader.
     *
     * The screen position of the pointer will be set in to the shaders `mouse` uniform
     * automatically every frame. Call this method with no arguments to unbind the pointer.
     * @param pointer The Pointer to bind to this shader.
     */
    setPointer(pointer?: Phaser.Input.Pointer): this;

    /**
     * Sets this shader to use an orthographic projection matrix.
     * This matrix is stored locally in the `projectionMatrix` property,
     * as well as being bound to the `uProjectionMatrix` uniform.
     * @param left The left value.
     * @param right The right value.
     * @param bottom The bottom value.
     * @param top The top value.
     */
    projOrtho(left: number, right: number, bottom: number, top: number): void;

    /**
     * Sets a sampler2D uniform on this shader where the source texture is a WebGLTexture.
     *
     * This allows you to feed the output from one Shader into another:
     *
     * ```javascript
     * let shader1 = this.add.shader(baseShader1, 0, 0, 512, 512).setRenderToTexture();
     * let shader2 = this.add.shader(baseShader2, 0, 0, 512, 512).setRenderToTexture('output');
     *
     * shader1.setSampler2DBuffer('iChannel0', shader2.glTexture, 512, 512);
     * shader2.setSampler2DBuffer('iChannel0', shader1.glTexture, 512, 512);
     * ```
     *
     * In the above code, the result of baseShader1 is fed into Shader2 as the `iChannel0` sampler2D uniform.
     * The result of baseShader2 is then fed back into shader1 again, creating a feedback loop.
     *
     * If you wish to use an image from the Texture Manager as a sampler2D input for this shader,
     * see the `Shader.setSampler2D` method.
     * @param uniformKey The key of the sampler2D uniform to be updated, i.e. `iChannel0`.
     * @param texture A WebGLTexture reference.
     * @param width The width of the texture.
     * @param height The height of the texture.
     * @param textureIndex The texture index. Default 0.
     * @param textureData Additional texture data.
     */
    setSampler2DBuffer(uniformKey: string, texture: WebGLTexture, width: number, height: number, textureIndex?: number, textureData?: any): this;

    /**
     * Sets a sampler2D uniform on this shader.
     *
     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame
     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.
     *
     * If you wish to use another Shader as a sampler2D input for this shader, see the `Shader.setSampler2DBuffer` method.
     * @param uniformKey The key of the sampler2D uniform to be updated, i.e. `iChannel0`.
     * @param textureKey The key of the texture, as stored in the Texture Manager. Must already be loaded.
     * @param textureIndex The texture index. Default 0.
     * @param textureData Additional texture data.
     */
    setSampler2D(uniformKey: string, textureKey: string, textureIndex?: number, textureData?: any): this;

    /**
     * Sets a property of a uniform already present on this shader.
     *
     * To modify the value of a uniform such as a 1f or 1i use the `value` property directly:
     *
     * ```javascript
     * shader.setUniform('size.value', 16);
     * ```
     *
     * You can use dot notation to access deeper values, for example:
     *
     * ```javascript
     * shader.setUniform('resolution.value.x', 512);
     * ```
     *
     * The change to the uniform will take effect the next time the shader is rendered.
     * @param key The key of the uniform to modify. Use dots for deep properties, i.e. `resolution.value.x`.
     * @param value The value to set into the uniform.
     */
    setUniform(key: string, value: any): this;

    /**
     * Returns the uniform object for the given key, or `null` if the uniform couldn't be found.
     * @param key The key of the uniform to return the value for.
     */
    getUniform(key: string): any;

    /**
     * A short-cut method that will directly set the texture being used by the `iChannel0` sampler2D uniform.
     *
     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame
     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.
     * @param textureKey The key of the texture, as stored in the Texture Manager. Must already be loaded.
     * @param textureData Additional texture data.
     */
    setChannel0(textureKey: string, textureData?: any): this;

    /**
     * A short-cut method that will directly set the texture being used by the `iChannel1` sampler2D uniform.
     *
     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame
     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.
     * @param textureKey The key of the texture, as stored in the Texture Manager. Must already be loaded.
     * @param textureData Additional texture data.
     */
    setChannel1(textureKey: string, textureData?: any): this;

    /**
     * A short-cut method that will directly set the texture being used by the `iChannel2` sampler2D uniform.
     *
     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame
     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.
     * @param textureKey The key of the texture, as stored in the Texture Manager. Must already be loaded.
     * @param textureData Additional texture data.
     */
    setChannel2(textureKey: string, textureData?: any): this;

    /**
     * A short-cut method that will directly set the texture being used by the `iChannel3` sampler2D uniform.
     *
     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame
     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.
     * @param textureKey The key of the texture, as stored in the Texture Manager. Must already be loaded.
     * @param textureData Additional texture data.
     */
    setChannel3(textureKey: string, textureData?: any): this;

    /**
     * Called automatically during render.
     *
     * This method performs matrix ITRS and then stores the resulting value in the `uViewMatrix` uniform.
     * It then sets up the vertex buffer and shader, updates and syncs the uniforms ready
     * for flush to be called.
     * @param matrix2D The transform matrix to use during rendering.
     */
    load(matrix2D?: Phaser.GameObjects.Components.TransformMatrix): void;

    /**
     * Called automatically during render.
     *
     * Sets the active shader, loads the vertex buffer and then draws.
     */
    flush(): void;

    /**
     * Internal destroy handler, called as part of the destroy process.
     */
    protected preDestroy(): void;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports both fill and stroke colors.
   *
   * When it renders it displays an arc shape. You can control the start and end angles of the arc,
   * as well as if the angles are winding clockwise or anti-clockwise. With the default settings
   * it renders as a complete circle. By changing the angles you can create other arc shapes,
   * such as half-circles.
   *
   * Arcs also have an `iterations` property and corresponding `setIterations` method. This allows
   * you to control how smooth the shape renders in WebGL, by controlling the number of iterations
   * that take place during construction.
   */
  class Arc extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param radius The radius of the arc. Default 128.
     * @param startAngle The start angle of the arc, in degrees. Default 0.
     * @param endAngle The end angle of the arc, in degrees. Default 360.
     * @param anticlockwise The winding order of the start and end angles. Default false.
     * @param fillColor The color the arc will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, radius?: number, startAngle?: number, endAngle?: number, anticlockwise?: boolean, fillColor?: number, fillAlpha?: number);

    /**
     * The number of iterations used when drawing the arc.
     * Increase this value for smoother arcs, at the cost of more polygons being rendered.
     * Modify this value by small amounts, such as 0.01.
     */
    iterations: number;

    /**
     * The radius of the arc.
     */
    radius: number;

    /**
     * The start angle of the arc, in degrees.
     */
    startAngle: number;

    /**
     * The end angle of the arc, in degrees.
     */
    endAngle: number;

    /**
     * The winding order of the start and end angles.
     */
    anticlockwise: boolean;

    /**
     * Sets the radius of the arc.
     * This call can be chained.
     * @param value The value to set the radius to.
     */
    setRadius(value: number): this;

    /**
     * Sets the number of iterations used when drawing the arc.
     * Increase this value for smoother arcs, at the cost of more polygons being rendered.
     * Modify this value by small amounts, such as 0.01.
     * This call can be chained.
     * @param value The value to set the iterations to.
     */
    setIterations(value: number): this;

    /**
     * Sets the starting angle of the arc, in degrees.
     * This call can be chained.
     * @param value The value to set the starting angle to.
     */
    setStartAngle(value: number): this;

    /**
     * Sets the ending angle of the arc, in degrees.
     * This call can be chained.
     * @param value The value to set the ending angle to.
     */
    setEndAngle(value: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Curve Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports both fill and stroke colors.
   *
   * To render a Curve Shape you must first create a `Phaser.Curves.Curve` object, then pass it to
   * the Curve Shape in the constructor.
   *
   * The Curve shape also has a `smoothness` property and corresponding `setSmoothness` method.
   * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations
   * that take place during construction. Increase and decrease the default value for smoother, or more
   * jagged, shapes.
   */
  class Curve extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param curve The Curve object to use to create the Shape.
     * @param fillColor The color the curve will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the curve will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, curve?: Phaser.Curves.Curve, fillColor?: number, fillAlpha?: number);

    /**
     * The smoothness of the curve. The number of points used when rendering it.
     * Increase this value for smoother curves, at the cost of more polygons being rendered.
     */
    smoothness: number;

    /**
     * Sets the smoothness of the curve. The number of points used when rendering it.
     * Increase this value for smoother curves, at the cost of more polygons being rendered.
     * This call can be chained.
     * @param value The value to set the smoothness to.
     */
    setSmoothness(value: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports both fill and stroke colors.
   *
   * When it renders it displays an ellipse shape. You can control the width and height of the ellipse.
   * If the width and height match it will render as a circle. If the width is less than the height,
   * it will look more like an egg shape.
   *
   * The Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.
   * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations
   * that take place during construction. Increase and decrease the default value for smoother, or more
   * jagged, shapes.
   */
  class Ellipse extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param width The width of the ellipse. An ellipse with equal width and height renders as a circle. Default 128.
     * @param height The height of the ellipse. An ellipse with equal width and height renders as a circle. Default 128.
     * @param fillColor The color the ellipse will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the ellipse will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, width?: number, height?: number, fillColor?: number, fillAlpha?: number);

    /**
     * The smoothness of the ellipse. The number of points used when rendering it.
     * Increase this value for a smoother ellipse, at the cost of more polygons being rendered.
     */
    smoothness: number;

    /**
     * Sets the size of the ellipse by changing the underlying geometry data, rather than scaling the object.
     * This call can be chained.
     * @param width The width of the ellipse.
     * @param height The height of the ellipse.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the smoothness of the ellipse. The number of points used when rendering it.
     * Increase this value for a smoother ellipse, at the cost of more polygons being rendered.
     * This call can be chained.
     * @param value The value to set the smoothness to.
     */
    setSmoothness(value: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Grid Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports only fill colors and cannot be stroked.
   *
   * A Grid Shape allows you to display a grid in your game, where you can control the size of the
   * grid as well as the width and height of the grid cells. You can set a fill color for each grid
   * cell as well as an alternate fill color. When the alternate fill color is set then the grid
   * cells will alternate the fill colors as they render, creating a chess-board effect. You can
   * also optionally have an outline fill color. If set, this draws lines between the grid cells
   * in the given color. If you specify an outline color with an alpha of zero, then it will draw
   * the cells spaced out, but without the lines between them.
   */
  class Grid extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param width The width of the grid. Default 128.
     * @param height The height of the grid. Default 128.
     * @param cellWidth The width of one cell in the grid. Default 32.
     * @param cellHeight The height of one cell in the grid. Default 32.
     * @param fillColor The color the grid cells will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     * @param outlineFillColor The color of the lines between the grid cells. See the `setOutline` method.
     * @param outlineFillAlpha The alpha of the lines between the grid cells.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, width?: number, height?: number, cellWidth?: number, cellHeight?: number, fillColor?: number, fillAlpha?: number, outlineFillColor?: number, outlineFillAlpha?: number);

    /**
     * The width of each grid cell.
     * Must be a positive value.
     */
    cellWidth: number;

    /**
     * The height of each grid cell.
     * Must be a positive value.
     */
    cellHeight: number;

    /**
     * Will the grid render its cells in the `fillColor`?
     */
    showCells: boolean;

    /**
     * The color of the lines between each grid cell.
     */
    outlineFillColor: number;

    /**
     * The alpha value for the color of the lines between each grid cell.
     */
    outlineFillAlpha: number;

    /**
     * Will the grid display the lines between each cell when it renders?
     */
    showOutline: boolean;

    /**
     * Will the grid render the alternating cells in the `altFillColor`?
     */
    showAltCells: boolean;

    /**
     * The color the alternating grid cells will be filled with, i.e. 0xff0000 for red.
     */
    altFillColor: number;

    /**
     * The alpha the alternating grid cells will be filled with.
     * You can also set the alpha of the overall Shape using its `alpha` property.
     */
    altFillAlpha: number;

    /**
     * Sets the fill color and alpha level the grid cells will use when rendering.
     *
     * If this method is called with no values then the grid cells will not be rendered,
     * however the grid lines and alternating cells may still be.
     *
     * Also see the `setOutlineStyle` and `setAltFillStyle` methods.
     *
     * This call can be chained.
     * @param fillColor The color the grid cells will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property. Default 1.
     */
    setFillStyle(fillColor?: number, fillAlpha?: number): this;

    /**
     * Sets the fill color and alpha level that the alternating grid cells will use.
     *
     * If this method is called with no values then alternating grid cells will not be rendered in a different color.
     *
     * Also see the `setOutlineStyle` and `setFillStyle` methods.
     *
     * This call can be chained.
     * @param fillColor The color the alternating grid cells will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the alternating grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property. Default 1.
     */
    setAltFillStyle(fillColor?: number, fillAlpha?: number): this;

    /**
     * Sets the fill color and alpha level that the lines between each grid cell will use.
     *
     * If this method is called with no values then the grid lines will not be rendered at all, however
     * the cells themselves may still be if they have colors set.
     *
     * Also see the `setFillStyle` and `setAltFillStyle` methods.
     *
     * This call can be chained.
     * @param fillColor The color the lines between the grid cells will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the lines between the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property. Default 1.
     */
    setOutlineStyle(fillColor?: number, fillAlpha?: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The IsoBox Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports only fill colors and cannot be stroked.
   *
   * An IsoBox is an 'isometric' rectangle. Each face of it has a different fill color. You can set
   * the color of the top, left and right faces of the rectangle respectively. You can also choose
   * which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.
   *
   * You cannot view an IsoBox from under-neath, however you can change the 'angle' by setting
   * the `projection` property.
   */
  class IsoBox extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param size The width of the iso box in pixels. The left and right faces will be exactly half this value. Default 48.
     * @param height The height of the iso box. The left and right faces will be this tall. The overall height of the isobox will be this value plus half the `size` value. Default 32.
     * @param fillTop The fill color of the top face of the iso box. Default 0xeeeeee.
     * @param fillLeft The fill color of the left face of the iso box. Default 0x999999.
     * @param fillRight The fill color of the right face of the iso box. Default 0xcccccc.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, size?: number, height?: number, fillTop?: number, fillLeft?: number, fillRight?: number);

    /**
     * The projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.
     */
    projection: number;

    /**
     * The color used to fill in the top of the iso box.
     */
    fillTop: number;

    /**
     * The color used to fill in the left-facing side of the iso box.
     */
    fillLeft: number;

    /**
     * The color used to fill in the right-facing side of the iso box.
     */
    fillRight: number;

    /**
     * Controls if the top-face of the iso box be rendered.
     */
    showTop: boolean;

    /**
     * Controls if the left-face of the iso box be rendered.
     */
    showLeft: boolean;

    /**
     * Controls if the right-face of the iso box be rendered.
     */
    showRight: boolean;

    /**
     * Sets the projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.
     * This call can be chained.
     * @param value The value to set the projection to.
     */
    setProjection(value: number): this;

    /**
     * Sets which faces of the iso box will be rendered.
     * This call can be chained.
     * @param showTop Show the top-face of the iso box. Default true.
     * @param showLeft Show the left-face of the iso box. Default true.
     * @param showRight Show the right-face of the iso box. Default true.
     */
    setFaces(showTop?: boolean, showLeft?: boolean, showRight?: boolean): this;

    /**
     * Sets the fill colors for each face of the iso box.
     * This call can be chained.
     * @param fillTop The color used to fill the top of the iso box.
     * @param fillLeft The color used to fill in the left-facing side of the iso box.
     * @param fillRight The color used to fill in the right-facing side of the iso box.
     */
    setFillStyle(fillTop?: number, fillLeft?: number, fillRight?: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The IsoTriangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports only fill colors and cannot be stroked.
   *
   * An IsoTriangle is an 'isometric' triangle. Think of it like a pyramid. Each face has a different
   * fill color. You can set the color of the top, left and right faces of the triangle respectively
   * You can also choose which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.
   *
   * You cannot view an IsoTriangle from under-neath, however you can change the 'angle' by setting
   * the `projection` property. The `reversed` property controls if the IsoTriangle is rendered upside
   * down or not.
   */
  class IsoTriangle extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param size The width of the iso triangle in pixels. The left and right faces will be exactly half this value. Default 48.
     * @param height The height of the iso triangle. The left and right faces will be this tall. The overall height of the iso triangle will be this value plus half the `size` value. Default 32.
     * @param reversed Is the iso triangle upside down? Default false.
     * @param fillTop The fill color of the top face of the iso triangle. Default 0xeeeeee.
     * @param fillLeft The fill color of the left face of the iso triangle. Default 0x999999.
     * @param fillRight The fill color of the right face of the iso triangle. Default 0xcccccc.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, size?: number, height?: number, reversed?: boolean, fillTop?: number, fillLeft?: number, fillRight?: number);

    /**
     * The projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.
     */
    projection: number;

    /**
     * The color used to fill in the top of the iso triangle. This is only used if the triangle is reversed.
     */
    fillTop: number;

    /**
     * The color used to fill in the left-facing side of the iso triangle.
     */
    fillLeft: number;

    /**
     * The color used to fill in the right-facing side of the iso triangle.
     */
    fillRight: number;

    /**
     * Controls if the top-face of the iso triangle be rendered.
     */
    showTop: boolean;

    /**
     * Controls if the left-face of the iso triangle be rendered.
     */
    showLeft: boolean;

    /**
     * Controls if the right-face of the iso triangle be rendered.
     */
    showRight: boolean;

    /**
     * Sets if the iso triangle will be rendered upside down or not.
     */
    isReversed: boolean;

    /**
     * Sets the projection level of the iso triangle. Change this to change the 'angle' at which you are looking at the pyramid.
     * This call can be chained.
     * @param value The value to set the projection to.
     */
    setProjection(value: number): this;

    /**
     * Sets if the iso triangle will be rendered upside down or not.
     * This call can be chained.
     * @param reversed Sets if the iso triangle will be rendered upside down or not.
     */
    setReversed(reversed: boolean): this;

    /**
     * Sets which faces of the iso triangle will be rendered.
     * This call can be chained.
     * @param showTop Show the top-face of the iso triangle (only if `reversed` is true) Default true.
     * @param showLeft Show the left-face of the iso triangle. Default true.
     * @param showRight Show the right-face of the iso triangle. Default true.
     */
    setFaces(showTop?: boolean, showLeft?: boolean, showRight?: boolean): this;

    /**
     * Sets the fill colors for each face of the iso triangle.
     * This call can be chained.
     * @param fillTop The color used to fill the top of the iso triangle.
     * @param fillLeft The color used to fill in the left-facing side of the iso triangle.
     * @param fillRight The color used to fill in the right-facing side of the iso triangle.
     */
    setFillStyle(fillTop?: number, fillLeft?: number, fillRight?: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Line Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports only stroke colors and cannot be filled.
   *
   * A Line Shape allows you to draw a line between two points in your game. You can control the
   * stroke color and thickness of the line. In WebGL only you can also specify a different
   * thickness for the start and end of the line, allowing you to render lines that taper-off.
   *
   * If you need to draw multiple lines in a sequence you may wish to use the Polygon Shape instead.
   *
   * Be aware that as with all Game Objects the default origin is 0.5. If you need to draw a Line
   * between two points and want the x1/y1 values to match the x/y values, then set the origin to 0.
   */
  class Line extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param x1 The horizontal position of the start of the line. Default 0.
     * @param y1 The vertical position of the start of the line. Default 0.
     * @param x2 The horizontal position of the end of the line. Default 128.
     * @param y2 The vertical position of the end of the line. Default 0.
     * @param strokeColor The color the line will be drawn in, i.e. 0xff0000 for red.
     * @param strokeAlpha The alpha the line will be drawn in. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, x1?: number, y1?: number, x2?: number, y2?: number, strokeColor?: number, strokeAlpha?: number);

    /**
     * The width (or thickness) of the line.
     * See the setLineWidth method for extra details on changing this on WebGL.
     */
    lineWidth: number;

    /**
     * Sets the width of the line.
     *
     * When using the WebGL renderer you can have different start and end widths.
     * When using the Canvas renderer only the `startWidth` value is used. The `endWidth` is ignored.
     *
     * This call can be chained.
     * @param startWidth The start width of the line.
     * @param endWidth The end width of the line. Only used in WebGL.
     */
    setLineWidth(startWidth: number, endWidth?: number): this;

    /**
     * Sets the start and end coordinates of this Line.
     * @param x1 The horizontal position of the start of the line. Default 0.
     * @param y1 The vertical position of the start of the line. Default 0.
     * @param x2 The horizontal position of the end of the line. Default 0.
     * @param y2 The vertical position of the end of the line. Default 0.
     */
    setTo(x1?: number, y1?: number, x2?: number, y2?: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports both fill and stroke colors.
   *
   * The Polygon Shape is created by providing a list of points, which are then used to create an
   * internal Polygon geometry object. The points can be set from a variety of formats:
   *
   * - A string containing paired values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`
   * - An array of Point or Vector2 objects: `[new Phaser.Math.Vector2(x1, y1), ...]`
   * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
   * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
   * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
   *
   * By default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending
   * on the coordinates of the points provided, the final shape may be rendered offset from its origin.
   */
  class Polygon extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param points The points that make up the polygon.
     * @param fillColor The color the polygon will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the polygon will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, points?: any, fillColor?: number, fillAlpha?: number);

    /**
     * Smooths the polygon over the number of iterations specified.
     * The base polygon data will be updated and replaced with the smoothed values.
     * This call can be chained.
     * @param iterations The number of times to apply the polygon smoothing. Default 1.
     */
    smooth(iterations?: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports both fill and stroke colors.
   *
   * You can change the size of the rectangle by changing the `width` and `height` properties.
   */
  class Rectangle extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param width The width of the rectangle. Default 128.
     * @param height The height of the rectangle. Default 128.
     * @param fillColor The color the rectangle will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the rectangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    constructor(scene: Phaser.Scene, x: number, y: number, width?: number, height?: number, fillColor?: number, fillAlpha?: number);

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Shape Game Object is a base class for the various different shapes, such as the Arc, Star or Polygon.
   * You cannot add a Shape directly to your Scene, it is meant as a base for your own custom Shape classes.
   */
  class Shape extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.AlphaSingle, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param type The internal type of the Shape.
     * @param data The data of the source shape geometry, if any.
     */
    constructor(scene: Phaser.Scene, type?: string, data?: any);

    /**
     * The source Shape data. Typically a geometry object.
     * You should not manipulate this directly.
     */
    readonly geom: any;

    /**
     * Holds the polygon path data for filled rendering.
     */
    readonly pathData: number[];

    /**
     * Holds the earcut polygon path index data for filled rendering.
     */
    readonly pathIndexes: number[];

    /**
     * The fill color used by this Shape.
     */
    fillColor: number;

    /**
     * The fill alpha value used by this Shape.
     */
    fillAlpha: number;

    /**
     * The stroke color used by this Shape.
     */
    strokeColor: number;

    /**
     * The stroke alpha value used by this Shape.
     */
    strokeAlpha: number;

    /**
     * The stroke line width used by this Shape.
     */
    lineWidth: number;

    /**
     * Controls if this Shape is filled or not.
     * Note that some Shapes do not support being filled (such as Line shapes)
     */
    isFilled: boolean;

    /**
     * Controls if this Shape is stroked or not.
     * Note that some Shapes do not support being stroked (such as Iso Box shapes)
     */
    isStroked: boolean;

    /**
     * Controls if this Shape path is closed during rendering when stroked.
     * Note that some Shapes are always closed when stroked (such as Ellipse shapes)
     */
    closePath: boolean;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * Sets the fill color and alpha for this Shape.
     *
     * If you wish for the Shape to not be filled then call this method with no arguments, or just set `isFilled` to `false`.
     *
     * Note that some Shapes do not support fill colors, such as the Line shape.
     *
     * This call can be chained.
     * @param color The color used to fill this shape. If not provided the Shape will not be filled.
     * @param alpha The alpha value used when filling this shape, if a fill color is given. Default 1.
     */
    setFillStyle(color?: number, alpha?: number): this;

    /**
     * Sets the stroke color and alpha for this Shape.
     *
     * If you wish for the Shape to not be stroked then call this method with no arguments, or just set `isStroked` to `false`.
     *
     * Note that some Shapes do not support being stroked, such as the Iso Box shape.
     *
     * This call can be chained.
     * @param lineWidth The width of line to stroke with. If not provided or undefined the Shape will not be stroked.
     * @param color The color used to stroke this shape. If not provided the Shape will not be stroked.
     * @param alpha The alpha value used when stroking this shape, if a stroke color is given. Default 1.
     */
    setStrokeStyle(lineWidth?: number, color?: number, alpha?: number): this;

    /**
     * Sets if this Shape path is closed during rendering when stroked.
     * Note that some Shapes are always closed when stroked (such as Ellipse shapes)
     *
     * This call can be chained.
     * @param value Set to `true` if the Shape should be closed when stroked, otherwise `false`.
     */
    setClosePath(value: boolean): this;

    /**
     * Sets the display size of this Shape.
     *
     * Calling this will adjust the scale.
     * @param width The display width of this Shape.
     * @param height The display height of this Shape.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * Internal destroy handler, called as part of the destroy process.
     */
    protected preDestroy(): void;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Star Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports both fill and stroke colors.
   *
   * As the name implies, the Star shape will display a star in your game. You can control several
   * aspects of it including the number of points that constitute the star. The default is 5. If
   * you change it to 4 it will render as a diamond. If you increase them, you'll get a more spiky
   * star shape.
   *
   * You can also control the inner and outer radius, which is how 'long' each point of the star is.
   * Modify these values to create more interesting shapes.
   */
  class Star extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param points The number of points on the star. Default 5.
     * @param innerRadius The inner radius of the star. Default 32.
     * @param outerRadius The outer radius of the star. Default 64.
     * @param fillColor The color the star will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the star will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, points?: number, innerRadius?: number, outerRadius?: number, fillColor?: number, fillAlpha?: number);

    /**
     * Sets the number of points that make up the Star shape.
     * This call can be chained.
     * @param value The amount of points the Star will have.
     */
    setPoints(value: number): this;

    /**
     * Sets the inner radius of the Star shape.
     * This call can be chained.
     * @param value The amount to set the inner radius to.
     */
    setInnerRadius(value: number): this;

    /**
     * Sets the outer radius of the Star shape.
     * This call can be chained.
     * @param value The amount to set the outer radius to.
     */
    setOuterRadius(value: number): this;

    /**
     * The number of points that make up the Star shape.
     */
    points: number;

    /**
     * The inner radius of the Star shape.
     */
    innerRadius: number;

    /**
     * The outer radius of the Star shape.
     */
    outerRadius: number;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
   * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
   * it for input or physics. It provides a quick and easy way for you to render this shape in your
   * game without using a texture, while still taking advantage of being fully batched in WebGL.
   *
   * This shape supports both fill and stroke colors.
   *
   * The Triangle consists of 3 lines, joining up to form a triangular shape. You can control the
   * position of each point of these lines. The triangle is always closed and cannot have an open
   * face. If you require that, consider using a Polygon instead.
   */
  class Triangle extends Phaser.GameObjects.Shape {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world. Default 0.
     * @param y The vertical position of this Game Object in the world. Default 0.
     * @param x1 The horizontal position of the first point in the triangle. Default 0.
     * @param y1 The vertical position of the first point in the triangle. Default 128.
     * @param x2 The horizontal position of the second point in the triangle. Default 64.
     * @param y2 The vertical position of the second point in the triangle. Default 0.
     * @param x3 The horizontal position of the third point in the triangle. Default 128.
     * @param y3 The vertical position of the third point in the triangle. Default 128.
     * @param fillColor The color the triangle will be filled with, i.e. 0xff0000 for red.
     * @param fillAlpha The alpha the triangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     */
    constructor(scene: Phaser.Scene, x?: number, y?: number, x1?: number, y1?: number, x2?: number, y2?: number, x3?: number, y3?: number, fillColor?: number, fillAlpha?: number);

    /**
     * Sets the data for the lines that make up this Triangle shape.
     * @param x1 The horizontal position of the first point in the triangle. Default 0.
     * @param y1 The vertical position of the first point in the triangle. Default 0.
     * @param x2 The horizontal position of the second point in the triangle. Default 0.
     * @param y2 The vertical position of the second point in the triangle. Default 0.
     * @param x3 The horizontal position of the third point in the triangle. Default 0.
     * @param y3 The vertical position of the third point in the triangle. Default 0.
     */
    setTo(x1?: number, y1?: number, x2?: number, y2?: number, x3?: number, y3?: number): this;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * @param value The alpha value applied across the whole Game Object. Default 1.
     */
    setAlpha(value?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * A Sprite Game Object.
   *
   * A Sprite Game Object is used for the display of both static and animated images in your game.
   * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled
   * and animated.
   *
   * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.
   * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation
   * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.
   */
  class Sprite extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.TextureCrop, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param texture The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frame An optional frame from the Texture this Game Object is rendering with.
     */
    constructor(scene: Phaser.Scene, x: number, y: number, texture: string | Phaser.Textures.Texture, frame?: string | number);

    /**
     * The Animation State component of this Sprite.
     *
     * This component provides features to apply animations to this Sprite.
     * It is responsible for playing, loading, queuing animations for later playback,
     * mixing between animations and setting the current animation frame to this Sprite.
     */
    anims: Phaser.Animations.AnimationState;

    /**
     * Update this Sprite's animations.
     * @param time The current timestamp.
     * @param delta The delta time, in ms, elapsed since the last frame.
     */
    protected preUpdate(time: number, delta: number): void;

    /**
     * Start playing the given animation on this Sprite.
     *
     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.
     *
     * The benefit of a global animation is that multiple Sprites can all play the same animation, without
     * having to duplicate the data. You can just create it once and then play it on any Sprite.
     *
     * The following code shows how to create a global repeating animation. The animation will be created
     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':
     *
     * ```javascript
     * var config = {
     *     key: 'run',
     *     frames: 'muybridge',
     *     frameRate: 15,
     *     repeat: -1
     * };
     *
     * //  This code should be run from within a Scene:
     * this.anims.create(config);
     * ```
     *
     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,
     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when
     * creating a global animation, however the resulting data is kept locally in this Sprite.
     *
     * With the animation created, either globally or locally, you can now play it on this Sprite:
     *
     * ```javascript
     * this.add.sprite(x, y).play('run');
     * ```
     *
     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config
     * object instead:
     *
     * ```javascript
     * this.add.sprite(x, y).play({ key: 'run', frameRate: 24 });
     * ```
     *
     * When playing an animation on a Sprite it will first check to see if it can find a matching key
     * locally within the Sprite. If it can, it will play the local animation. If not, it will then
     * search the global Animation Manager and look for it there.
     *
     * If you need a Sprite to be able to play both local and global animations, make sure they don't
     * have conflicting keys.
     *
     * See the documentation for the `PlayAnimationConfig` config object for more details about this.
     *
     * Also, see the documentation in the Animation Manager for further details on creating animations.
     * @param key The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.
     * @param ignoreIfPlaying If an animation is already playing then ignore this call. Default false.
     */
    play(key: string | Phaser.Animations.Animation | Phaser.Types.Animations.PlayAnimationConfig, ignoreIfPlaying?: boolean): this;

    /**
     * Start playing the given animation on this Sprite, in reverse.
     *
     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.
     *
     * The benefit of a global animation is that multiple Sprites can all play the same animation, without
     * having to duplicate the data. You can just create it once and then play it on any Sprite.
     *
     * The following code shows how to create a global repeating animation. The animation will be created
     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':
     *
     * ```javascript
     * var config = {
     *     key: 'run',
     *     frames: 'muybridge',
     *     frameRate: 15,
     *     repeat: -1
     * };
     *
     * //  This code should be run from within a Scene:
     * this.anims.create(config);
     * ```
     *
     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,
     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when
     * creating a global animation, however the resulting data is kept locally in this Sprite.
     *
     * With the animation created, either globally or locally, you can now play it on this Sprite:
     *
     * ```javascript
     * this.add.sprite(x, y).playReverse('run');
     * ```
     *
     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config
     * object instead:
     *
     * ```javascript
     * this.add.sprite(x, y).playReverse({ key: 'run', frameRate: 24 });
     * ```
     *
     * When playing an animation on a Sprite it will first check to see if it can find a matching key
     * locally within the Sprite. If it can, it will play the local animation. If not, it will then
     * search the global Animation Manager and look for it there.
     *
     * If you need a Sprite to be able to play both local and global animations, make sure they don't
     * have conflicting keys.
     *
     * See the documentation for the `PlayAnimationConfig` config object for more details about this.
     *
     * Also, see the documentation in the Animation Manager for further details on creating animations.
     * @param key The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.
     * @param ignoreIfPlaying If an animation is already playing then ignore this call. Default false.
     */
    playReverse(key: string | Phaser.Animations.Animation | Phaser.Types.Animations.PlayAnimationConfig, ignoreIfPlaying?: boolean): this;

    /**
     * Waits for the specified delay, in milliseconds, then starts playback of the given animation.
     *
     * If the animation _also_ has a delay value set in its config, it will be **added** to the delay given here.
     *
     * If an animation is already running and a new animation is given to this method, it will wait for
     * the given delay before starting the new animation.
     *
     * If no animation is currently running, the given one begins after the delay.
     *
     * When playing an animation on a Sprite it will first check to see if it can find a matching key
     * locally within the Sprite. If it can, it will play the local animation. If not, it will then
     * search the global Animation Manager and look for it there.
     *
     * Prior to Phaser 3.50 this method was called 'delayedPlay'.
     * @param key The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.
     * @param delay The delay, in milliseconds, to wait before starting the animation playing.
     */
    playAfterDelay(key: string | Phaser.Animations.Animation | Phaser.Types.Animations.PlayAnimationConfig, delay: number): this;

    /**
     * Waits for the current animation to complete the `repeatCount` number of repeat cycles, then starts playback
     * of the given animation.
     *
     * You can use this to ensure there are no harsh jumps between two sets of animations, i.e. going from an
     * idle animation to a walking animation, by making them blend smoothly into each other.
     *
     * If no animation is currently running, the given one will start immediately.
     *
     * When playing an animation on a Sprite it will first check to see if it can find a matching key
     * locally within the Sprite. If it can, it will play the local animation. If not, it will then
     * search the global Animation Manager and look for it there.
     * @param key The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.
     * @param repeatCount How many times should the animation repeat before the next one starts? Default 1.
     */
    playAfterRepeat(key: string | Phaser.Animations.Animation | Phaser.Types.Animations.PlayAnimationConfig, repeatCount?: number): this;

    /**
     * Sets an animation, or an array of animations, to be played immediately after the current one completes or stops.
     *
     * The current animation must enter a 'completed' state for this to happen, i.e. finish all of its repeats, delays, etc,
     * or have the `stop` method called directly on it.
     *
     * An animation set to repeat forever will never enter a completed state.
     *
     * You can chain a new animation at any point, including before the current one starts playing, during it,
     * or when it ends (via its `animationcomplete` event).
     *
     * Chained animations are specific to a Game Object, meaning different Game Objects can have different chained
     * animations without impacting the animation they're playing.
     *
     * Call this method with no arguments to reset all currently chained animations.
     *
     * When playing an animation on a Sprite it will first check to see if it can find a matching key
     * locally within the Sprite. If it can, it will play the local animation. If not, it will then
     * search the global Animation Manager and look for it there.
     * @param key The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object, or an array of them.
     */
    chain(key: string | Phaser.Animations.Animation | Phaser.Types.Animations.PlayAnimationConfig | string[] | Phaser.Animations.Animation[] | Phaser.Types.Animations.PlayAnimationConfig[]): this;

    /**
     * Immediately stops the current animation from playing and dispatches the `ANIMATION_STOP` events.
     *
     * If no animation is playing, no event will be dispatched.
     *
     * If there is another animation queued (via the `chain` method) then it will start playing immediately.
     */
    stop(): this;

    /**
     * Stops the current animation from playing after the specified time delay, given in milliseconds.
     *
     * It then dispatches the `ANIMATION_STOP` event.
     *
     * If no animation is running, no events will be dispatched.
     *
     * If there is another animation in the queue (set via the `chain` method) then it will start playing,
     * when the current one stops.
     * @param delay The number of milliseconds to wait before stopping this animation.
     */
    stopAfterDelay(delay: number): this;

    /**
     * Stops the current animation from playing after the given number of repeats.
     *
     * It then dispatches the `ANIMATION_STOP` event.
     *
     * If no animation is running, no events will be dispatched.
     *
     * If there is another animation in the queue (set via the `chain` method) then it will start playing,
     * when the current one stops.
     * @param repeatCount How many times should the animation repeat before stopping? Default 1.
     */
    stopAfterRepeat(repeatCount?: number): this;

    /**
     * Stops the current animation from playing when it next sets the given frame.
     * If this frame doesn't exist within the animation it will not stop it from playing.
     *
     * It then dispatches the `ANIMATION_STOP` event.
     *
     * If no animation is running, no events will be dispatched.
     *
     * If there is another animation in the queue (set via the `chain` method) then it will start playing,
     * when the current one stops.
     * @param frame The frame to check before stopping this animation.
     */
    stopOnFrame(frame: Phaser.Animations.AnimationFrame): this;

    /**
     * Build a JSON representation of this Sprite.
     */
    toJSON(): Phaser.Types.GameObjects.JSONGameObject;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The horizontally flipped state of the Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipX: boolean;

    /**
     * The vertically flipped state of the Game Object.
     *
     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipY: boolean;

    /**
     * Toggles the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    toggleFlipX(): this;

    /**
     * Toggles the vertical flipped state of this Game Object.
     */
    toggleFlipY(): this;

    /**
     * Sets the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipX(value: boolean): this;

    /**
     * Sets the vertical flipped state of this Game Object.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipY(value: boolean): this;

    /**
     * Sets the horizontal and vertical flipped state of this Game Object.
     *
     * A Game Object that is flipped will render inversed on the flipped axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlip(x: boolean, y: boolean): this;

    /**
     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
     */
    resetFlip(): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the size of this Game Object to be that of the given Frame.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param frame The frame to base the size of this Game Object on.
     */
    setSizeToFrame(frame: Phaser.Textures.Frame): this;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * A boolean flag indicating if this Game Object is being cropped or not.
     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
     */
    isCropped: boolean;

    /**
     * Applies a crop to a texture based Game Object, such as a Sprite or Image.
     *
     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
     *
     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
     * changes what is shown when rendered.
     *
     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
     *
     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
     * half of it, you could call `setCrop(0, 0, 400, 600)`.
     *
     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
     *
     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
     *
     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
     *
     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
     * the renderer to skip several internal calculations.
     * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
     * @param y The y coordinate to start the crop from.
     * @param width The width of the crop rectangle in pixels.
     * @param height The height of the crop rectangle in pixels.
     */
    setCrop(x?: number | Phaser.Geom.Rectangle, y?: number, width?: number, height?: number): this;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     * @param frame The name or index of the frame within the Texture.
     * @param updateSize Should this call adjust the size of the Game Object? Default true.
     * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
     */
    setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;

    /**
     * The tint value being applied to the top-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopLeft: number;

    /**
     * The tint value being applied to the top-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopRight: number;

    /**
     * The tint value being applied to the bottom-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomLeft: number;

    /**
     * The tint value being applied to the bottom-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomRight: number;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * Clears all tint values associated with this Game Object.
     *
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     */
    clearTint(): this;

    /**
     * Sets an additive tint on this Game Object.
     *
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a fill-based tint on this Game Object.
     *
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     */
    tint: number;

    /**
     * Does this Game Object have a tint applied?
     *
     * It checks to see if the 4 tint properties are set to the value 0xffffff
     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
     */
    readonly isTinted: boolean;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * Returns an object containing dimensions of the Text object.
   * @param text The Text object to calculate the size from.
   * @param size The Text metrics to use when calculating the size.
   * @param lines The lines of text to calculate the size from.
   */
  function GetTextSize(text: Phaser.GameObjects.Text, size: Phaser.Types.GameObjects.Text.TextMetrics, lines: string[]): Phaser.Types.GameObjects.Text.GetTextSizeObject;

  /**
   * Calculates the ascent, descent and fontSize of a given font style.
   * @param textStyle The TextStyle object to measure.
   */
  function MeasureText(textStyle: Phaser.GameObjects.TextStyle): Phaser.Types.GameObjects.Text.TextMetrics;

  /**
   * A Text Game Object.
   *
   * Text objects work by creating their own internal hidden Canvas and then renders text to it using
   * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered
   * to your game during the render pass.
   *
   * Because it uses the Canvas API you can take advantage of all the features this offers, such as
   * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts
   * loaded externally, such as Google or TypeKit Web fonts.
   *
   * **Important:** The font name must be quoted if it contains certain combinations of digits or
   * special characters, either when creating the Text object, or when setting the font via `setFont`
   * or `setFontFamily`, e.g.:
   *
   * ```javascript
   * this.add.text(0, 0, 'Hello World', { fontFamily: 'Georgia, "Goudy Bookletter 1911", Times, serif' });
   * ```
   *
   * ```javascript
   * this.add.text(0, 0, 'Hello World', { font: '"Press Start 2P"' });
   * ```
   *
   * You can only display fonts that are currently loaded and available to the browser: therefore fonts must
   * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,
   * or have the fonts ready available in the CSS on the page in which your Phaser game resides.
   *
   * See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts
   * across mobile browsers.
   *
   * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being
   * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the
   * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of
   * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text
   * instead, as it benefits from batching and avoids expensive Canvas API calls.
   */
  class Text extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Crop, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param text The text this Text object will display.
     * @param style The text style configuration object.
     */
    constructor(scene: Phaser.Scene, x: number, y: number, text: string | string[], style: Phaser.Types.GameObjects.Text.TextStyle);

    /**
     * The renderer in use by this Text object.
     */
    renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer;

    /**
     * The canvas element that the text is rendered to.
     */
    canvas: HTMLCanvasElement;

    /**
     * The context of the canvas element that the text is rendered to.
     */
    context: CanvasRenderingContext2D;

    /**
     * The Text Style object.
     *
     * Manages the style of this Text object.
     */
    style: Phaser.GameObjects.TextStyle;

    /**
     * Whether to automatically round line positions.
     */
    autoRound: boolean;

    /**
     * The Regular Expression that is used to split the text up into lines, in
     * multi-line text. By default this is `/(?:\r\n|\r|\n)/`.
     * You can change this RegExp to be anything else that you may need.
     */
    splitRegExp: object;

    /**
     * Specify a padding value which is added to the line width and height when calculating the Text size.
     * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions.
     */
    padding: Phaser.Types.GameObjects.Text.TextPadding;

    /**
     * The width of this Text object.
     */
    width: number;

    /**
     * The height of this Text object.
     */
    height: number;

    /**
     * The line spacing value.
     * This value is added to the font height to calculate the overall line height.
     * Only has an effect if this Text object contains multiple lines of text.
     *
     * If you update this property directly, instead of using the `setLineSpacing` method, then
     * be sure to call `updateText` after, or you won't see the change reflected in the Text object.
     */
    lineSpacing: number;

    /**
     * Whether the text or its settings have changed and need updating.
     */
    dirty: boolean;

    /**
     * Initialize right to left text.
     */
    initRTL(): void;

    /**
     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal
     * bounds.
     * @param text The text to perform word wrap detection against.
     */
    runWordWrap(text: string): string;

    /**
     * Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal
     * bounds. Consecutive spaces will be collapsed and replaced with a single space. Lines will be
     * trimmed of white space before processing. Throws an error if wordWrapWidth is less than a
     * single character.
     * @param text The text to perform word wrap detection against.
     * @param context The Canvas Rendering Context.
     * @param wordWrapWidth The word wrap width.
     */
    advancedWordWrap(text: string, context: CanvasRenderingContext2D, wordWrapWidth: number): string;

    /**
     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal
     * bounds. Spaces are not collapsed and whitespace is not trimmed.
     * @param text The text to perform word wrap detection against.
     * @param context The Canvas Rendering Context.
     * @param wordWrapWidth The word wrap width.
     */
    basicWordWrap(text: string, context: CanvasRenderingContext2D, wordWrapWidth: number): string;

    /**
     * Runs the given text through this Text objects word wrapping and returns the results as an
     * array, where each element of the array corresponds to a wrapped line of text.
     * @param text The text for which the wrapping will be calculated. If unspecified, the Text objects current text will be used.
     */
    getWrappedText(text: string): string[];

    /**
     * Set the text to display.
     *
     * An array of strings will be joined with `\n` line breaks.
     * @param value The string, or array of strings, to be set as the content of this Text object.
     */
    setText(value: string | string[]): this;

    /**
     * Set the text style.
     * @param style The style settings to set.
     */
    setStyle(style: object): this;

    /**
     * Set the font.
     *
     * If a string is given, the font family is set.
     *
     * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`
     * properties of that object are set.
     *
     * **Important:** The font name must be quoted if it contains certain combinations of digits or
     * special characters:
     *
     * ```javascript
     * Text.setFont('"Press Start 2P"');
     * ```
     *
     * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all
     * quoted properly, too:
     *
     * ```javascript
     * Text.setFont('Georgia, "Goudy Bookletter 1911", Times, serif');
     * ```
     * @param font The font family or font settings to set.
     */
    setFont(font: string): this;

    /**
     * Set the font family.
     *
     * **Important:** The font name must be quoted if it contains certain combinations of digits or
     * special characters:
     *
     * ```javascript
     * Text.setFont('"Press Start 2P"');
     * ```
     *
     * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all
     * quoted properly, too:
     *
     * ```javascript
     * Text.setFont('Georgia, "Goudy Bookletter 1911", Times, serif');
     * ```
     * @param family The font family.
     */
    setFontFamily(family: string): this;

    /**
     * Set the font size.
     * @param size The font size.
     */
    setFontSize(size: number): this;

    /**
     * Set the font style.
     * @param style The font style.
     */
    setFontStyle(style: string): this;

    /**
     * Set a fixed width and height for the text.
     *
     * Pass in `0` for either of these parameters to disable fixed width or height respectively.
     * @param width The fixed width to set. `0` disables fixed width.
     * @param height The fixed height to set. `0` disables fixed height.
     */
    setFixedSize(width: number, height: number): this;

    /**
     * Set the background color.
     * @param color The background color.
     */
    setBackgroundColor(color: string): this;

    /**
     * Set the fill style to be used by the Text object.
     *
     * This can be any valid CanvasRenderingContext2D fillStyle value, such as
     * a color (in hex, rgb, rgba, hsl or named values), a gradient or a pattern.
     *
     * See the [MDN fillStyle docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle) for more details.
     * @param color The text fill style. Can be any valid CanvasRenderingContext `fillStyle` value.
     */
    setFill(color: string | any): this;

    /**
     * Set the text fill color.
     * @param color The text fill color.
     */
    setColor(color: string): this;

    /**
     * Set the stroke settings.
     * @param color The stroke color.
     * @param thickness The stroke thickness.
     */
    setStroke(color: string, thickness: number): this;

    /**
     * Set the shadow settings.
     * @param x The horizontal shadow offset. Default 0.
     * @param y The vertical shadow offset. Default 0.
     * @param color The shadow color. Default '#000'.
     * @param blur The shadow blur radius. Default 0.
     * @param shadowStroke Whether to stroke the shadow. Default false.
     * @param shadowFill Whether to fill the shadow. Default true.
     */
    setShadow(x?: number, y?: number, color?: string, blur?: number, shadowStroke?: boolean, shadowFill?: boolean): this;

    /**
     * Set the shadow offset.
     * @param x The horizontal shadow offset.
     * @param y The vertical shadow offset.
     */
    setShadowOffset(x: number, y: number): this;

    /**
     * Set the shadow color.
     * @param color The shadow color.
     */
    setShadowColor(color: string): this;

    /**
     * Set the shadow blur radius.
     * @param blur The shadow blur radius.
     */
    setShadowBlur(blur: number): this;

    /**
     * Enable or disable shadow stroke.
     * @param enabled Whether shadow stroke is enabled or not.
     */
    setShadowStroke(enabled: boolean): this;

    /**
     * Enable or disable shadow fill.
     * @param enabled Whether shadow fill is enabled or not.
     */
    setShadowFill(enabled: boolean): this;

    /**
     * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.
     * @param width The maximum width of a line in pixels. Set to null to remove wrapping.
     * @param useAdvancedWrap Whether or not to use the advanced wrapping
     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,
     * spaces and whitespace are left as is. Default false.
     */
    setWordWrapWidth(width: number, useAdvancedWrap?: boolean): this;

    /**
     * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.
     * @param callback A custom function that will be responsible for wrapping the
     * text. It will receive two arguments: text (the string to wrap), textObject (this Text
     * instance). It should return the wrapped lines either as an array of lines or as a string with
     * newline characters in place to indicate where breaks should happen.
     * @param scope The scope that will be applied when the callback is invoked. Default null.
     */
    setWordWrapCallback(callback: TextStyleWordWrapCallback, scope?: object): this;

    /**
     * Set the alignment of the text in this Text object.
     *
     * The argument can be one of: `left`, `right`, `center` or `justify`.
     *
     * Alignment only works if the Text object has more than one line of text.
     * @param align The text alignment for multi-line text. Default 'left'.
     */
    setAlign(align?: string): this;

    /**
     * Set the resolution used by this Text object.
     *
     * By default it will be set to match the resolution set in the Game Config,
     * but you can override it via this method, or by specifying it in the Text style configuration object.
     *
     * It allows for much clearer text on High DPI devices, at the cost of memory because it uses larger
     * internal Canvas textures for the Text.
     *
     * Therefore, please use with caution, as the more high res Text you have, the more memory it uses.
     * @param value The resolution for this Text object to use.
     */
    setResolution(value: number): this;

    /**
     * Sets the line spacing value.
     *
     * This value is _added_ to the height of the font when calculating the overall line height.
     * This only has an effect if this Text object consists of multiple lines of text.
     * @param value The amount to add to the font height to achieve the overall line height.
     */
    setLineSpacing(value: number): this;

    /**
     * Set the text padding.
     *
     * 'left' can be an object.
     *
     * If only 'left' and 'top' are given they are treated as 'x' and 'y'.
     * @param left The left padding value, or a padding config object.
     * @param top The top padding value.
     * @param right The right padding value.
     * @param bottom The bottom padding value.
     */
    setPadding(left: number | Phaser.Types.GameObjects.Text.TextPadding, top?: number, right?: number, bottom?: number): this;

    /**
     * Set the maximum number of lines to draw.
     * @param max The maximum number of lines to draw. Default 0.
     */
    setMaxLines(max?: number): this;

    /**
     * Update the displayed text.
     */
    updateText(): this;

    /**
     * Get the current text metrics.
     */
    getTextMetrics(): Phaser.Types.GameObjects.Text.TextMetrics;

    /**
     * The text string being rendered by this Text Game Object.
     */
    text: string;

    /**
     * Build a JSON representation of the Text object.
     */
    toJSON(): Phaser.Types.GameObjects.JSONGameObject;

    /**
     * Internal destroy handler, called as part of the destroy process.
     */
    protected preDestroy(): void;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * A boolean flag indicating if this Game Object is being cropped or not.
     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
     */
    isCropped: boolean;

    /**
     * Applies a crop to a texture based Game Object, such as a Sprite or Image.
     *
     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
     *
     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
     * changes what is shown when rendered.
     *
     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
     *
     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
     * half of it, you could call `setCrop(0, 0, 400, 600)`.
     *
     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
     *
     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
     *
     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
     *
     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
     * the renderer to skip several internal calculations.
     * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
     * @param y The y coordinate to start the crop from.
     * @param width The width of the crop rectangle in pixels.
     * @param height The height of the crop rectangle in pixels.
     */
    setCrop(x?: number | Phaser.Geom.Rectangle, y?: number, width?: number, height?: number): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The horizontally flipped state of the Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipX: boolean;

    /**
     * The vertically flipped state of the Game Object.
     *
     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipY: boolean;

    /**
     * Toggles the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    toggleFlipX(): this;

    /**
     * Toggles the vertical flipped state of this Game Object.
     */
    toggleFlipY(): this;

    /**
     * Sets the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipX(value: boolean): this;

    /**
     * Sets the vertical flipped state of this Game Object.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipY(value: boolean): this;

    /**
     * Sets the horizontal and vertical flipped state of this Game Object.
     *
     * A Game Object that is flipped will render inversed on the flipped axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlip(x: boolean, y: boolean): this;

    /**
     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
     */
    resetFlip(): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The tint value being applied to the top-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopLeft: number;

    /**
     * The tint value being applied to the top-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopRight: number;

    /**
     * The tint value being applied to the bottom-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomLeft: number;

    /**
     * The tint value being applied to the bottom-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomRight: number;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * Clears all tint values associated with this Game Object.
     *
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     */
    clearTint(): this;

    /**
     * Sets an additive tint on this Game Object.
     *
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a fill-based tint on this Game Object.
     *
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     */
    tint: number;

    /**
     * Does this Game Object have a tint applied?
     *
     * It checks to see if the 4 tint properties are set to the value 0xffffff
     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
     */
    readonly isTinted: boolean;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * A TextStyle class manages all of the style settings for a Text object.
   *
   * Text Game Objects create a TextStyle instance automatically, which is
   * accessed via the `Text.style` property. You do not normally need to
   * instantiate one yourself.
   */
  class TextStyle {
    /**
     *
     * @param text The Text object that this TextStyle is styling.
     * @param style The style settings to set.
     */
    constructor(text: Phaser.GameObjects.Text, style: Phaser.Types.GameObjects.Text.TextStyle);

    /**
     * The Text object that this TextStyle is styling.
     */
    parent: Phaser.GameObjects.Text;

    /**
     * The font family.
     */
    fontFamily: string;

    /**
     * The font size.
     */
    fontSize: string;

    /**
     * The font style.
     */
    fontStyle: string;

    /**
     * The background color.
     */
    backgroundColor: string;

    /**
     * The text fill color.
     */
    color: string;

    /**
     * The text stroke color.
     */
    stroke: string;

    /**
     * The text stroke thickness.
     */
    strokeThickness: number;

    /**
     * The horizontal shadow offset.
     */
    shadowOffsetX: number;

    /**
     * The vertical shadow offset.
     */
    shadowOffsetY: number;

    /**
     * The shadow color.
     */
    shadowColor: string;

    /**
     * The shadow blur radius.
     */
    shadowBlur: number;

    /**
     * Whether shadow stroke is enabled or not.
     */
    shadowStroke: boolean;

    /**
     * Whether shadow fill is enabled or not.
     */
    shadowFill: boolean;

    /**
     * The text alignment.
     */
    align: string;

    /**
     * The maximum number of lines to draw.
     */
    maxLines: number;

    /**
     * The fixed width of the text.
     *
     * `0` means no fixed with.
     */
    fixedWidth: number;

    /**
     * The fixed height of the text.
     *
     * `0` means no fixed height.
     */
    fixedHeight: number;

    /**
     * The resolution the text is rendered to its internal canvas at.
     * The default is 0, which means it will use the resolution set in the Game Config.
     */
    resolution: number;

    /**
     * Whether the text should render right to left.
     */
    rtl: boolean;

    /**
     * The test string to use when measuring the font.
     */
    testString: string;

    /**
     * The amount of horizontal padding added to the width of the text when calculating the font metrics.
     */
    baselineX: number;

    /**
     * The amount of vertical padding added to the height of the text when calculating the font metrics.
     */
    baselineY: number;

    /**
     * The maximum width of a line of text in pixels. Null means no line wrapping. Setting this
     * property directly will not re-run the word wrapping algorithm. To change the width and
     * re-wrap, use {@link Phaser.GameObjects.TextStyle#setWordWrapWidth}.
     */
    wordWrapWidth: number | null;

    /**
     * A custom function that will be responsible for wrapping the text. It will receive two
     * arguments: text (the string to wrap), textObject (this Text instance). It should return
     * the wrapped lines either as an array of lines or as a string with newline characters in
     * place to indicate where breaks should happen. Setting this directly will not re-run the
     * word wrapping algorithm. To change the callback and re-wrap, use
     * {@link Phaser.GameObjects.TextStyle#setWordWrapCallback}.
     */
    wordWrapCallback: TextStyleWordWrapCallback | null;

    /**
     * The scope that will be applied when the wordWrapCallback is invoked. Setting this directly will not re-run the
     * word wrapping algorithm. To change the callback and re-wrap, use
     * {@link Phaser.GameObjects.TextStyle#setWordWrapCallback}.
     */
    wordWrapCallbackScope: object | null;

    /**
     * Whether or not to use the advanced wrapping algorithm. If true, spaces are collapsed and
     * whitespace is trimmed from lines. If false, spaces and whitespace are left as is. Setting
     * this property directly will not re-run the word wrapping algorithm. To change the
     * advanced setting and re-wrap, use {@link Phaser.GameObjects.TextStyle#setWordWrapWidth}.
     */
    wordWrapUseAdvanced: boolean;

    /**
     * Set the text style.
     * @param style The style settings to set.
     * @param updateText Whether to update the text immediately. Default true.
     * @param setDefaults Use the default values is not set, or the local values. Default false.
     */
    setStyle(style: Phaser.Types.GameObjects.Text.TextStyle, updateText?: boolean, setDefaults?: boolean): Phaser.GameObjects.Text;

    /**
     * Synchronize the font settings to the given Canvas Rendering Context.
     * @param canvas The Canvas Element.
     * @param context The Canvas Rendering Context.
     */
    syncFont(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D): void;

    /**
     * Synchronize the text style settings to the given Canvas Rendering Context.
     * @param canvas The Canvas Element.
     * @param context The Canvas Rendering Context.
     */
    syncStyle(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D): void;

    /**
     * Synchronize the shadow settings to the given Canvas Rendering Context.
     * @param context The Canvas Rendering Context.
     * @param enabled Whether shadows are enabled or not.
     */
    syncShadow(context: CanvasRenderingContext2D, enabled: boolean): void;

    /**
     * Update the style settings for the parent Text object.
     * @param recalculateMetrics Whether to recalculate font and text metrics.
     */
    update(recalculateMetrics: boolean): Phaser.GameObjects.Text;

    /**
     * Set the font.
     *
     * If a string is given, the font family is set.
     *
     * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`
     * properties of that object are set.
     * @param font The font family or font settings to set.
     * @param updateText Whether to update the text immediately. Default true.
     */
    setFont(font: string | object, updateText?: boolean): Phaser.GameObjects.Text;

    /**
     * Set the font family.
     * @param family The font family.
     */
    setFontFamily(family: string): Phaser.GameObjects.Text;

    /**
     * Set the font style.
     * @param style The font style.
     */
    setFontStyle(style: string): Phaser.GameObjects.Text;

    /**
     * Set the font size.
     * @param size The font size.
     */
    setFontSize(size: number | string): Phaser.GameObjects.Text;

    /**
     * Set the test string to use when measuring the font.
     * @param string The test string to use when measuring the font.
     */
    setTestString(string: string): Phaser.GameObjects.Text;

    /**
     * Set a fixed width and height for the text.
     *
     * Pass in `0` for either of these parameters to disable fixed width or height respectively.
     * @param width The fixed width to set.
     * @param height The fixed height to set.
     */
    setFixedSize(width: number, height: number): Phaser.GameObjects.Text;

    /**
     * Set the background color.
     * @param color The background color.
     */
    setBackgroundColor(color: string): Phaser.GameObjects.Text;

    /**
     * Set the text fill color.
     * @param color The text fill color.
     */
    setFill(color: string): Phaser.GameObjects.Text;

    /**
     * Set the text fill color.
     * @param color The text fill color.
     */
    setColor(color: string): Phaser.GameObjects.Text;

    /**
     * Set the resolution used by the Text object.
     *
     * By default it will be set to match the resolution set in the Game Config,
     * but you can override it via this method. It allows for much clearer text on High DPI devices,
     * at the cost of memory because it uses larger internal Canvas textures for the Text.
     *
     * Please use with caution, as the more high res Text you have, the more memory it uses up.
     * @param value The resolution for this Text object to use.
     */
    setResolution(value: number): Phaser.GameObjects.Text;

    /**
     * Set the stroke settings.
     * @param color The stroke color.
     * @param thickness The stroke thickness.
     */
    setStroke(color: string, thickness: number): Phaser.GameObjects.Text;

    /**
     * Set the shadow settings.
     *
     * Calling this method always re-measures the parent Text object,
     * so only call it when you actually change the shadow settings.
     * @param x The horizontal shadow offset. Default 0.
     * @param y The vertical shadow offset. Default 0.
     * @param color The shadow color. Default '#000'.
     * @param blur The shadow blur radius. Default 0.
     * @param shadowStroke Whether to stroke the shadow. Default false.
     * @param shadowFill Whether to fill the shadow. Default true.
     */
    setShadow(x?: number, y?: number, color?: string, blur?: number, shadowStroke?: boolean, shadowFill?: boolean): Phaser.GameObjects.Text;

    /**
     * Set the shadow offset.
     * @param x The horizontal shadow offset. Default 0.
     * @param y The vertical shadow offset. Default 0.
     */
    setShadowOffset(x?: number, y?: number): Phaser.GameObjects.Text;

    /**
     * Set the shadow color.
     * @param color The shadow color. Default '#000'.
     */
    setShadowColor(color?: string): Phaser.GameObjects.Text;

    /**
     * Set the shadow blur radius.
     * @param blur The shadow blur radius. Default 0.
     */
    setShadowBlur(blur?: number): Phaser.GameObjects.Text;

    /**
     * Enable or disable shadow stroke.
     * @param enabled Whether shadow stroke is enabled or not.
     */
    setShadowStroke(enabled: boolean): Phaser.GameObjects.Text;

    /**
     * Enable or disable shadow fill.
     * @param enabled Whether shadow fill is enabled or not.
     */
    setShadowFill(enabled: boolean): Phaser.GameObjects.Text;

    /**
     * Set the width (in pixels) to use for wrapping lines.
     *
     * Pass in null to remove wrapping by width.
     * @param width The maximum width of a line in pixels. Set to null to remove wrapping.
     * @param useAdvancedWrap Whether or not to use the advanced wrapping
     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,
     * spaces and whitespace are left as is. Default false.
     */
    setWordWrapWidth(width: number, useAdvancedWrap?: boolean): Phaser.GameObjects.Text;

    /**
     * Set a custom callback for wrapping lines.
     *
     * Pass in null to remove wrapping by callback.
     * @param callback A custom function that will be responsible for wrapping the
     * text. It will receive two arguments: text (the string to wrap), textObject (this Text
     * instance). It should return the wrapped lines either as an array of lines or as a string with
     * newline characters in place to indicate where breaks should happen.
     * @param scope The scope that will be applied when the callback is invoked. Default null.
     */
    setWordWrapCallback(callback: TextStyleWordWrapCallback, scope?: object): Phaser.GameObjects.Text;

    /**
     * Set the alignment of the text in this Text object.
     *
     * The argument can be one of: `left`, `right`, `center` or `justify`.
     *
     * Alignment only works if the Text object has more than one line of text.
     * @param align The text alignment for multi-line text. Default 'left'.
     */
    setAlign(align?: string): Phaser.GameObjects.Text;

    /**
     * Set the maximum number of lines to draw.
     * @param max The maximum number of lines to draw. Default 0.
     */
    setMaxLines(max?: number): Phaser.GameObjects.Text;

    /**
     * Get the current text metrics.
     */
    getTextMetrics(): Phaser.Types.GameObjects.Text.TextMetrics;

    /**
     * Build a JSON representation of this Text Style.
     */
    toJSON(): object;

    /**
     * Destroy this Text Style.
     */
    destroy(): void;

  }

  /**
   * A TileSprite is a Sprite that has a repeating texture.
   *
   * The texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and
   * are designed so that you can create game backdrops using seamless textures as a source.
   *
   * You shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background
   * that scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`
   * property to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will
   * consume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to
   * adjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.
   *
   * An important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide
   * seamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means
   * they need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a
   * TileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then
   * scaled back down again during rendering to the original dimensions. While this works, in that it allows you to use
   * any size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,
   * due to the interpolation that took place when it was resized into a POT texture. This is especially visible in
   * pixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you
   * provide POT textures for Tile Sprites.
   */
  class TileSprite extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Crop, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param width The width of the Game Object. If zero it will use the size of the texture frame.
     * @param height The height of the Game Object. If zero it will use the size of the texture frame.
     * @param textureKey The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param frameKey An optional frame from the Texture this Game Object is rendering with.
     */
    constructor(scene: Phaser.Scene, x: number, y: number, width: number, height: number, textureKey: string, frameKey?: string | number);

    /**
     * Whether the Tile Sprite has changed in some way, requiring an re-render of its tile texture.
     *
     * Such changes include the texture frame and scroll position of the Tile Sprite.
     */
    dirty: boolean;

    /**
     * The renderer in use by this Tile Sprite.
     */
    renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer;

    /**
     * The Canvas element that the TileSprite renders its fill pattern in to.
     * Only used in Canvas mode.
     */
    canvas: HTMLCanvasElement;

    /**
     * The Context of the Canvas element that the TileSprite renders its fill pattern in to.
     * Only used in Canvas mode.
     */
    context: CanvasRenderingContext2D;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * The next power of two value from the width of the Fill Pattern frame.
     */
    potWidth: number;

    /**
     * The next power of two value from the height of the Fill Pattern frame.
     */
    potHeight: number;

    /**
     * The Canvas that the TileSprites texture is rendered to.
     * This is used to create a WebGL texture from.
     */
    fillCanvas: HTMLCanvasElement;

    /**
     * The Canvas Context used to render the TileSprites texture.
     */
    fillContext: CanvasRenderingContext2D;

    /**
     * The texture that the Tile Sprite is rendered to, which is then rendered to a Scene.
     * In WebGL this is a WebGLTexture. In Canvas it's a Canvas Fill Pattern.
     */
    fillPattern: WebGLTexture | CanvasPattern;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     * @param frame The name or index of the frame within the Texture.
     */
    setFrame(frame: string | number): this;

    /**
     * Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.
     * @param x The x position of this sprite's tiling texture.
     * @param y The y position of this sprite's tiling texture.
     */
    setTilePosition(x?: number, y?: number): this;

    /**
     * Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.
     * @param x The horizontal scale of the tiling texture. If not given it will use the current `tileScaleX` value.
     * @param y The vertical scale of the tiling texture. If not given it will use the `x` value. Default x.
     */
    setTileScale(x?: number, y?: number): this;

    /**
     * Internal destroy handler, called as part of the destroy process.
     */
    protected preDestroy(): void;

    /**
     * The horizontal scroll position of the Tile Sprite.
     */
    tilePositionX: number;

    /**
     * The vertical scroll position of the Tile Sprite.
     */
    tilePositionY: number;

    /**
     * The horizontal scale of the Tile Sprite texture.
     */
    tileScaleX: number;

    /**
     * The vertical scale of the Tile Sprite texture.
     */
    tileScaleY: number;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * A boolean flag indicating if this Game Object is being cropped or not.
     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
     */
    isCropped: boolean;

    /**
     * Applies a crop to a texture based Game Object, such as a Sprite or Image.
     *
     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
     *
     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
     * changes what is shown when rendered.
     *
     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
     *
     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
     * half of it, you could call `setCrop(0, 0, 400, 600)`.
     *
     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
     *
     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
     *
     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
     *
     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
     * the renderer to skip several internal calculations.
     * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
     * @param y The y coordinate to start the crop from.
     * @param width The width of the crop rectangle in pixels.
     * @param height The height of the crop rectangle in pixels.
     */
    setCrop(x?: number | Phaser.Geom.Rectangle, y?: number, width?: number, height?: number): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The horizontally flipped state of the Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipX: boolean;

    /**
     * The vertically flipped state of the Game Object.
     *
     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipY: boolean;

    /**
     * Toggles the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    toggleFlipX(): this;

    /**
     * Toggles the vertical flipped state of this Game Object.
     */
    toggleFlipY(): this;

    /**
     * Sets the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipX(value: boolean): this;

    /**
     * Sets the vertical flipped state of this Game Object.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipY(value: boolean): this;

    /**
     * Sets the horizontal and vertical flipped state of this Game Object.
     *
     * A Game Object that is flipped will render inversed on the flipped axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlip(x: boolean, y: boolean): this;

    /**
     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
     */
    resetFlip(): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The tint value being applied to the top-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopLeft: number;

    /**
     * The tint value being applied to the top-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopRight: number;

    /**
     * The tint value being applied to the bottom-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomLeft: number;

    /**
     * The tint value being applied to the bottom-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomRight: number;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * Clears all tint values associated with this Game Object.
     *
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     */
    clearTint(): this;

    /**
     * Sets an additive tint on this Game Object.
     *
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a fill-based tint on this Game Object.
     *
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     */
    tint: number;

    /**
     * Does this Game Object have a tint applied?
     *
     * It checks to see if the 4 tint properties are set to the value 0xffffff
     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
     */
    readonly isTinted: boolean;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * The Update List plugin.
   *
   * Update Lists belong to a Scene and maintain the list Game Objects to be updated every frame.
   *
   * Some or all of these Game Objects may also be part of the Scene's [Display List]{@link Phaser.GameObjects.DisplayList}, for Rendering.
   */
  class UpdateList extends Phaser.Structs.ProcessQueue<Phaser.GameObjects.GameObject> {
    /**
     *
     * @param scene The Scene that the Update List belongs to.
     */
    constructor(scene: Phaser.Scene);

    /**
     * The Scene that the Update List belongs to.
     */
    scene: Phaser.Scene;

    /**
     * The Scene's Systems.
     */
    systems: Phaser.Scenes.Systems;

    /**
     * The update step.
     *
     * Pre-updates every active Game Object in the list.
     * @param time The current timestamp.
     * @param delta The delta time elapsed since the last frame.
     */
    sceneUpdate(time: number, delta: number): void;

    /**
     * The Scene that owns this plugin is shutting down.
     *
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     */
    shutdown(): void;

    /**
     * The Scene that owns this plugin is being destroyed.
     *
     * We need to shutdown and then kill off all external references.
     */
    destroy(): void;

  }

  /**
   * A Video Game Object.
   *
   * This Game Object is capable of handling playback of a previously loaded video from the Phaser Video Cache,
   * or playing a video based on a given URL. Videos can be either local, or streamed.
   *
   * ```javascript
   * preload () {
   *   this.load.video('pixar', 'nemo.mp4');
   * }
   *
   * create () {
   *   this.add.video(400, 300, 'pixar');
   * }
   * ```
   *
   * To all intents and purposes, a video is a standard Game Object, just like a Sprite. And as such, you can do
   * all the usual things to it, such as scaling, rotating, cropping, tinting, making interactive, giving a
   * physics body, etc.
   *
   * Transparent videos are also possible via the WebM file format. Providing the video file has was encoded with
   * an alpha channel, and providing the browser supports WebM playback (not all of them do), then it will render
   * in-game with full transparency.
   *
   * ### Autoplaying Videos
   *
   * Videos can only autoplay if the browser has been unlocked with an interaction, or satisfies the MEI settings.
   * The policies that control autoplaying are vast and vary between browser.
   * You can, and should, read more about it here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide
   *
   * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is _loaded_,
   * and it will often allow the video to play immediately:
   *
   * ```javascript
   * preload () {
   *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);
   * }
   * ```
   *
   * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without
   * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies
   * the browsers MEI settings. See the MDN Autoplay Guide for further details.
   *
   * Note that due to a bug in IE11 you cannot play a video texture to a Sprite in WebGL. For IE11 force Canvas mode.
   *
   * More details about video playback and the supported media formats can be found on MDN:
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement
   * https://developer.mozilla.org/en-US/docs/Web/Media/Formats
   */
  class Video extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.TextureCrop, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param key Optional key of the Video this Game Object will play, as stored in the Video Cache.
     */
    constructor(scene: Phaser.Scene, x: number, y: number, key?: string);

    /**
     * A reference to the HTML Video Element this Video Game Object is playing.
     * Will be `null` until a video is loaded for playback.
     */
    video: HTMLVideoElement;

    /**
     * The Phaser Texture this Game Object is using to render the video to.
     * Will be `null` until a video is loaded for playback.
     */
    videoTexture: Phaser.Textures.Texture;

    /**
     * A reference to the TextureSource belong to the `videoTexture` Texture object.
     * Will be `null` until a video is loaded for playback.
     */
    videoTextureSource: Phaser.Textures.TextureSource;

    /**
     * A Phaser CanvasTexture instance that holds the most recent snapshot taken from the video.
     * This will only be set if `snapshot` or `snapshotArea` have been called, and will be `null` until that point.
     */
    snapshotTexture: Phaser.Textures.CanvasTexture;

    /**
     * If you have saved this video to a texture via the `saveTexture` method, this controls if the video
     * is rendered with `flipY` in WebGL or not. You often need to set this if you wish to use the video texture
     * as the input source for a shader. If you find your video is appearing upside down within a shader or
     * custom pipeline, flip this property.
     */
    flipY: boolean;

    /**
     * An internal flag holding the current state of the video lock, should document interaction be required
     * before playback can begin.
     */
    touchLocked: boolean;

    /**
     * Should the video auto play when document interaction is required and happens?
     */
    playWhenUnlocked: boolean;

    /**
     * When starting playback of a video Phaser will monitor its `readyState` using a `setTimeout` call.
     * The `setTimeout` happens once every `Video.retryInterval` ms. It will carry on monitoring the video
     * state in this manner until the `retryLimit` is reached and then abort.
     */
    retryLimit: number;

    /**
     * The current retry attempt.
     */
    retry: number;

    /**
     * The number of ms between each retry while monitoring the ready state of a downloading video.
     */
    retryInterval: number;

    /**
     * An object containing in and out markers for sequence playback.
     */
    markers: any;

    /**
     * Should the Video element that this Video is using, be removed from the DOM
     * when this Video is destroyed?
     */
    removeVideoElementOnDestroy: boolean;

    /**
     * Starts this video playing.
     *
     * If the video is already playing, or has been queued to play with `changeSource` then this method just returns.
     *
     * Videos can only autoplay if the browser has been unlocked. This happens if you have interacted with the browser, i.e.
     * by clicking on it or pressing a key, or due to server settings. The policies that control autoplaying are vast and
     * vary between browser. You can read more here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide
     *
     * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is loaded,
     * and it will often allow the video to play immediately:
     *
     * ```javascript
     * preload () {
     *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);
     * }
     * ```
     *
     * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without
     * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies
     * the browsers MEI settings. See the MDN Autoplay Guide for details.
     *
     * If you need audio in your videos, then you'll have to consider the fact that the video cannot start playing until the
     * user has interacted with the browser, into your game flow.
     * @param loop Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats. Default false.
     * @param markerIn Optional in marker time, in seconds, for playback of a sequence of the video.
     * @param markerOut Optional out marker time, in seconds, for playback of a sequence of the video.
     */
    play(loop?: boolean, markerIn?: number, markerOut?: number): this;

    /**
     * This method allows you to change the source of the current video element. It works by first stopping the
     * current video, if playing. Then deleting the video texture, if one has been created. Finally, it makes a
     * new video texture and starts playback of the new source through the existing video element.
     *
     * The reason you may wish to do this is because videos that require interaction to unlock, remain in an unlocked
     * state, even if you change the source of the video. By changing the source to a new video you avoid having to
     * go through the unlock process again.
     * @param key The key of the Video this Game Object will swap to playing, as stored in the Video Cache.
     * @param autoplay Should the video start playing immediately, once the swap is complete? Default true.
     * @param loop Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats. Default false.
     * @param markerIn Optional in marker time, in seconds, for playback of a sequence of the video.
     * @param markerOut Optional out marker time, in seconds, for playback of a sequence of the video.
     */
    changeSource(key: string, autoplay?: boolean, loop?: boolean, markerIn?: number, markerOut?: number): this;

    /**
     * Adds a sequence marker to this video.
     *
     * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds.
     *
     * You can then play back specific markers via the `playMarker` method.
     *
     * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for
     * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.
     *
     * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.
     * @param key A unique name to give this marker.
     * @param markerIn The time, in seconds, representing the start of this marker.
     * @param markerOut The time, in seconds, representing the end of this marker.
     */
    addMarker(key: string, markerIn: number, markerOut: number): this;

    /**
     * Plays a pre-defined sequence in this video.
     *
     * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds and
     * specified via the `addMarker` method.
     *
     * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for
     * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.
     *
     * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.
     * @param key The name of the marker sequence to play.
     * @param loop Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats. Default false.
     */
    playMarker(key: string, loop?: boolean): this;

    /**
     * Removes a previously set marker from this video.
     *
     * If the marker is currently playing it will _not_ stop playback.
     * @param key The name of the marker to remove.
     */
    removeMarker(key: string): this;

    /**
     * Takes a snapshot of the current frame of the video and renders it to a CanvasTexture object,
     * which is then returned. You can optionally resize the grab by passing a width and height.
     *
     * This method returns a reference to the `Video.snapshotTexture` object. Calling this method
     * multiple times will overwrite the previous snapshot with the most recent one.
     * @param width The width of the resulting CanvasTexture.
     * @param height The height of the resulting CanvasTexture.
     */
    snapshot(width?: number, height?: number): Phaser.Textures.CanvasTexture;

    /**
     * Takes a snapshot of the specified area of the current frame of the video and renders it to a CanvasTexture object,
     * which is then returned. You can optionally resize the grab by passing a different `destWidth` and `destHeight`.
     *
     * This method returns a reference to the `Video.snapshotTexture` object. Calling this method
     * multiple times will overwrite the previous snapshot with the most recent one.
     * @param x The horizontal location of the top-left of the area to grab from. Default 0.
     * @param y The vertical location of the top-left of the area to grab from. Default 0.
     * @param srcWidth The width of area to grab from the video. If not given it will grab the full video dimensions.
     * @param srcHeight The height of area to grab from the video. If not given it will grab the full video dimensions.
     * @param destWidth The destination width of the grab, allowing you to resize it.
     * @param destHeight The destination height of the grab, allowing you to resize it.
     */
    snapshotArea(x?: number, y?: number, srcWidth?: number, srcHeight?: number, destWidth?: number, destHeight?: number): Phaser.Textures.CanvasTexture;

    /**
     * Stores a copy of this Videos `snapshotTexture` in the Texture Manager using the given key.
     *
     * This texture is created when the `snapshot` or `snapshotArea` methods are called.
     *
     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of the
     * snapshot by using the texture key:
     *
     * ```javascript
     * var vid = this.add.video(0, 0, 'intro');
     *
     * vid.snapshot();
     *
     * vid.saveSnapshotTexture('doodle');
     *
     * this.add.image(400, 300, 'doodle');
     * ```
     *
     * Updating the contents of the `snapshotTexture`, for example by calling `snapshot` again,
     * will automatically update _any_ Game Object that is using it as a texture.
     * Calling `saveSnapshotTexture` again will not save another copy of the same texture,
     * it will just rename the existing one.
     *
     * By default it will create a single base texture. You can add frames to the texture
     * by using the `Texture.add` method. After doing this, you can then allow Game Objects
     * to use a specific frame.
     * @param key The unique key to store the texture as within the global Texture Manager.
     */
    saveSnapshotTexture(key: string): Phaser.Textures.CanvasTexture;

    /**
     * Loads a Video from the given URL, ready for playback with the `Video.play` method.
     *
     * You can control at what point the browser determines the video as being ready for playback via
     * the `loadEvent` parameter. See https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement
     * for more details.
     * @param url The URL of the video to load or be streamed.
     * @param loadEvent The load event to listen for. Either `loadeddata`, `canplay` or `canplaythrough`. Default 'loadeddata'.
     * @param noAudio Does the video have an audio track? If not you can enable auto-playing on it. Default false.
     */
    loadURL(url: string, loadEvent?: string, noAudio?: boolean): this;

    /**
     * Loads a Video from the given MediaStream object, ready for playback with the `Video.play` method.
     *
     * You can control at what point the browser determines the video as being ready for playback via
     * the `loadEvent` parameter. See https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement
     * for more details.
     * @param stream The MediaStream object.
     * @param loadEvent The load event to listen for. Either `loadeddata`, `canplay` or `canplaythrough`. Default 'loadeddata'.
     * @param noAudio Does the video have an audio track? If not you can enable auto-playing on it. Default false.
     */
    loadMediaStream(stream: string, loadEvent?: string, noAudio?: boolean): this;

    /**
     * Called when the video emits a `playing` event during load.
     *
     * This is only listened for if the browser doesn't support Promises.
     */
    playHandler(): void;

    /**
     * Called when the video completes playback, i.e. reaches an `ended` state.
     *
     * This will never happen if the video is coming from a live stream, where the duration is `Infinity`.
     */
    completeHandler(): void;

    /**
     * Called when the video emits a `timeUpdate` event during playback.
     *
     * This event is too slow and irregular to be used for actual video timing or texture updating,
     * but we can use it to determine if a video has looped.
     */
    timeUpdateHandler(): void;

    /**
     * Internal method that is called when enough video data has been received in order to create a texture
     * from it. The texture is assigned to the `Video.videoTexture` property and given a base frame that
     * encompases the whole video size.
     */
    updateTexture(): void;

    /**
     * Returns the key of the currently played video, as stored in the Video Cache.
     * If the video did not come from the cache this will return an empty string.
     */
    getVideoKey(): string;

    /**
     * Seeks to a given point in the video. The value is given as a float between 0 and 1,
     * where 0 represents the start of the video and 1 represents the end.
     *
     * Seeking only works if the video has a duration, so will not work for live streams.
     *
     * When seeking begins, this video will emit a `seeking` event. When the video completes
     * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.
     *
     * If you wish to seek based on time instead, use the `Video.setCurrentTime` method.
     * @param value The point in the video to seek to. A value between 0 and 1.
     */
    seekTo(value: number): this;

    /**
     * A double-precision floating-point value indicating the current playback time in seconds.
     * If the media has not started to play and has not been seeked, this value is the media's initial playback time.
     */
    getCurrentTime(): number;

    /**
     * Seeks to a given playback time in the video. The value is given in _seconds_ or as a string.
     *
     * Seeking only works if the video has a duration, so will not work for live streams.
     *
     * When seeking begins, this video will emit a `seeking` event. When the video completes
     * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.
     *
     * You can provide a string prefixed with either a `+` or a `-`, such as `+2.5` or `-2.5`.
     * In this case it will seek to +/- the value given, relative to the _current time_.
     *
     * If you wish to seek based on a duration percentage instead, use the `Video.seekTo` method.
     * @param value The playback time to seek to in seconds. Can be expressed as a string, such as `+2` to seek 2 seconds ahead from the current time.
     */
    setCurrentTime(value: string | number): this;

    /**
     * Returns a boolean indicating if this Video is currently seeking, or not.
     */
    isSeeking(): boolean;

    /**
     * Returns the current progress of the video. Progress is defined as a value between 0 (the start)
     * and 1 (the end).
     *
     * Progress can only be returned if the video has a duration, otherwise it will always return zero.
     */
    getProgress(): number;

    /**
     * A double-precision floating-point value which indicates the duration (total length) of the media in seconds,
     * on the media's timeline. If no media is present on the element, or the media is not valid, the returned value is NaN.
     *
     * If the media has no known end (such as for live streams of unknown duration, web radio, media incoming from WebRTC,
     * and so forth), this value is +Infinity.
     */
    getDuration(): number;

    /**
     * Sets the muted state of the currently playing video, if one is loaded.
     * @param value The mute value. `true` if the video should be muted, otherwise `false`. Default true.
     */
    setMute(value?: boolean): this;

    /**
     * Returns a boolean indicating if this Video is currently muted.
     */
    isMuted(): boolean;

    /**
     * Sets the paused state of the currently loaded video.
     *
     * If the video is playing, calling this method with `true` will pause playback.
     * If the video is paused, calling this method with `false` will resume playback.
     *
     * If no video is loaded, this method does nothing.
     * @param value The paused value. `true` if the video should be paused, `false` to resume it. Default true.
     */
    setPaused(value?: boolean): this;

    /**
     * Returns a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).
     */
    getVolume(): number;

    /**
     * Sets the volume of the currently playing video.
     *
     * The value given is a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).
     * @param value A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest). Default 1.
     */
    setVolume(value?: number): this;

    /**
     * Returns a double that indicates the rate at which the media is being played back.
     */
    getPlaybackRate(): number;

    /**
     * Sets the playback rate of the current video.
     *
     * The value given is a double that indicates the rate at which the media is being played back.
     * @param rate A double that indicates the rate at which the media is being played back.
     */
    setPlaybackRate(rate?: number): this;

    /**
     * Returns a boolean which indicates whether the media element should start over when it reaches the end.
     */
    getLoop(): boolean;

    /**
     * Sets the loop state of the current video.
     *
     * The value given is a boolean which indicates whether the media element will start over when it reaches the end.
     *
     * Not all videos can loop, for example live streams.
     *
     * Please note that not all browsers support _seamless_ video looping for all encoding formats.
     * @param value A boolean which indicates whether the media element will start over when it reaches the end. Default true.
     */
    setLoop(value?: boolean): this;

    /**
     * Returns a boolean which indicates whether the video is currently playing.
     */
    isPlaying(): boolean;

    /**
     * Returns a boolean which indicates whether the video is currently paused.
     */
    isPaused(): boolean;

    /**
     * Stores this Video in the Texture Manager using the given key as a dynamic texture,
     * which any texture-based Game Object, such as a Sprite, can use as its texture:
     *
     * ```javascript
     * var vid = this.add.video(0, 0, 'intro');
     *
     * vid.play();
     *
     * vid.saveTexture('doodle');
     *
     * this.add.image(400, 300, 'doodle');
     * ```
     *
     * The saved texture is automatically updated as the video plays. If you pause this video,
     * or change its source, then the saved texture updates instantly.
     *
     * Calling `saveTexture` again will not save another copy of the same texture, it will just rename the existing one.
     *
     * By default it will create a single base texture. You can add frames to the texture
     * by using the `Texture.add` method. After doing this, you can then allow Game Objects
     * to use a specific frame.
     *
     * If you intend to save the texture so you can use it as the input for a Shader, you may need to set the
     * `flipY` parameter to `true` if you find the video renders upside down in your shader.
     * @param key The unique key to store the texture as within the global Texture Manager.
     * @param flipY Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y` during upload? Default false.
     */
    saveTexture(key: string, flipY?: boolean): Phaser.Textures.Texture;

    /**
     * Stops the video playing and clears all internal event listeners.
     *
     * If you only wish to pause playback of the video, and resume it a later time, use the `Video.pause` method instead.
     *
     * If the video hasn't finished downloading, calling this method will not abort the download. To do that you need to
     * call `destroy` instead.
     */
    stop(): this;

    /**
     * Removes the Video element from the DOM by calling parentNode.removeChild on itself.
     *
     * Also removes the autoplay and src attributes and nulls the Video reference.
     *
     * You should not call this method if you were playing a video from the Video Cache that
     * you wish to play again in your game, or if another Video object is also using the same
     * video.
     *
     * If you loaded an external video via `Video.loadURL` then you should call this function
     * to clear up once you are done with the instance.
     */
    removeVideoElement(): void;

    /**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     */
    clearAlpha(): this;

    /**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
     * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
     * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
     */
    setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     */
    alpha: number;

    /**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopLeft: number;

    /**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaTopRight: number;

    /**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomLeft: number;

    /**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     */
    alphaBottomRight: number;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     */
    blendMode: Phaser.BlendModes | string;

    /**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     * @param value The BlendMode value. Either a string or a CONST.
     */
    setBlendMode(value: string | Phaser.BlendModes): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * The horizontally flipped state of the Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    flipX: boolean;

    /**
     * Toggles the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     */
    toggleFlipX(): this;

    /**
     * Toggles the vertical flipped state of this Game Object.
     */
    toggleFlipY(): this;

    /**
     * Sets the horizontal flipped state of this Game Object.
     *
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipX(value: boolean): this;

    /**
     * Sets the vertical flipped state of this Game Object.
     * @param value The flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlipY(value: boolean): this;

    /**
     * Sets the horizontal and vertical flipped state of this Game Object.
     *
     * A Game Object that is flipped will render inversed on the flipped axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     */
    setFlip(x: boolean, y: boolean): this;

    /**
     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
     */
    resetFlip(): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The Mask this Game Object is using during render.
     */
    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;

    /**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     *
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     *
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * @param mask The mask this Game Object will use when rendering.
     */
    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;

    /**
     * Clears the mask that this Game Object was using.
     * @param destroyMask Destroy the mask before clearing it? Default false.
     */
    clearMask(destroyMask?: boolean): this;

    /**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
     */
    createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;

    /**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     *
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
     */
    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The initial WebGL pipeline of this Game Object.
     *
     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.
     */
    defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * The current WebGL pipeline of this Game Object.
     */
    pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

    /**
     * Does this Game Object have any Post Pipelines set?
     */
    hasPostPipeline: boolean;

    /**
     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.
     *
     * The pipelines are processed in the order in which they appear in this array.
     *
     * If you modify this array directly, be sure to set the
     * `hasPostPipeline` property accordingly.
     */
    postPipelines: Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.
     */
    pipelineData: object;

    /**
     * Sets the initial WebGL Pipeline of this Game Object.
     *
     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     */
    initPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline): boolean;

    /**
     * Sets the main WebGL Pipeline of this Game Object.
     *
     * Also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the same pipeline data object.
     * @param pipeline Either the string-based name of the pipeline, or a pipeline instance to set.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPipeline(pipeline: string | Phaser.Renderer.WebGL.WebGLPipeline, pipelineData?: object, copyData?: boolean): this;

    /**
     * Sets one, or more, Post Pipelines on this Game Object.
     *
     * Post Pipelines are invoked after this Game Object has rendered to its target and
     * are commonly used for post-fx.
     *
     * The post pipelines are appended to the `postPipelines` array belonging to this
     * Game Object. When the renderer processes this Game Object, it iterates through the post
     * pipelines in the order in which they appear in the array. If you are stacking together
     * multiple effects, be aware that the order is important.
     *
     * If you call this method multiple times, the new pipelines will be appended to any existing
     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.
     *
     * You can optionally also sets the `pipelineData` property, if the parameter is given.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param pipelines Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.
     * @param pipelineData Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.
     * @param copyData Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead. Default true.
     */
    setPostPipeline(pipelines: string | string[] | Function | Function[] | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[], pipelineData?: object, copyData?: boolean): this;

    /**
     * Adds an entry to the `pipelineData` object belonging to this Game Object.
     *
     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.
     *
     * If `value` is undefined, and `key` exists, `key` is removed from the data object.
     *
     * Both the pipeline and post pipelines share the pipeline data object together.
     * @param key The key of the pipeline data to set, update, or delete.
     * @param value The value to be set with the key. If `undefined` then `key` will be deleted from the object.
     */
    setPipelineData(key: string, value?: any): this;

    /**
     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    getPostPipeline(pipeline: string | Function | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): Phaser.Renderer.WebGL.Pipelines.PostFXPipeline | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[];

    /**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     * @param resetPostPipelines Reset all of the post pipelines? Default false.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPipeline(resetPostPipelines?: boolean, resetData?: boolean): boolean;

    /**
     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling
     * the `destroy` method on each post pipeline and then clearing the local array.
     * @param resetData Reset the `pipelineData` object to being an empty object? Default false.
     */
    resetPostPipeline(resetData?: boolean): void;

    /**
     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.
     *
     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.
     * @param pipeline The string-based name of the pipeline, or a pipeline class.
     */
    removePostPipeline(pipeline: string | Phaser.Renderer.WebGL.Pipelines.PostFXPipeline): this;

    /**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     */
    getPipelineName(): string;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The native (un-scaled) width of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     *
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     */
    height: number;

    /**
     * The displayed width of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     *
     * This value takes into account the scale factor.
     *
     * Setting this value will adjust the Game Object's scale property.
     */
    displayHeight: number;

    /**
     * Sets the size of this Game Object to be that of the given Frame.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param frame The frame to base the size of this Game Object on.
     */
    setSizeToFrame(frame: Phaser.Textures.Frame): this;

    /**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     *
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     *
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setSize(width: number, height: number): this;

    /**
     * Sets the display size of this Game Object.
     *
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * The Texture this Game Object is using to render with.
     */
    texture: Phaser.Textures.Texture | Phaser.Textures.CanvasTexture;

    /**
     * The Texture Frame this Game Object is using to render with.
     */
    frame: Phaser.Textures.Frame;

    /**
     * A boolean flag indicating if this Game Object is being cropped or not.
     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
     */
    isCropped: boolean;

    /**
     * Applies a crop to a texture based Game Object, such as a Sprite or Image.
     *
     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
     *
     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
     * changes what is shown when rendered.
     *
     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
     *
     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
     * half of it, you could call `setCrop(0, 0, 400, 600)`.
     *
     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
     *
     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
     *
     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
     *
     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
     * the renderer to skip several internal calculations.
     * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
     * @param y The y coordinate to start the crop from.
     * @param width The width of the crop rectangle in pixels.
     * @param height The height of the crop rectangle in pixels.
     */
    setCrop(x?: number | Phaser.Geom.Rectangle, y?: number, width?: number, height?: number): this;

    /**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * @param key The key of the texture to be used, as stored in the Texture Manager.
     * @param frame The name or index of the frame within the Texture.
     */
    setTexture(key: string, frame?: string | number): this;

    /**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     * @param frame The name or index of the frame within the Texture.
     * @param updateSize Should this call adjust the size of the Game Object? Default true.
     * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
     */
    setFrame(frame: string | number, updateSize?: boolean, updateOrigin?: boolean): this;

    /**
     * The tint value being applied to the top-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopLeft: number;

    /**
     * The tint value being applied to the top-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintTopRight: number;

    /**
     * The tint value being applied to the bottom-left vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomLeft: number;

    /**
     * The tint value being applied to the bottom-right vertice of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.
     */
    tintBottomRight: number;

    /**
     * The tint fill mode.
     *
     * `false` = An additive tint (the default), where vertices colors are blended with the texture.
     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
     */
    tintFill: boolean;

    /**
     * Clears all tint values associated with this Game Object.
     *
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     */
    clearTint(): this;

    /**
     * Sets an additive tint on this Game Object.
     *
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTint(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * Sets a fill-based tint on this Game Object.
     *
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     *
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     *
     * To remove a tint call `clearTint`.
     *
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
     * @param topRight The tint being applied to the top-right of the Game Object.
     * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
     * @param bottomRight The tint being applied to the bottom-right of the Game Object.
     */
    setTintFill(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

    /**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     */
    tint: number;

    /**
     * Does this Game Object have a tint applied?
     *
     * It checks to see if the 4 tint properties are set to the value 0xffffff
     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.
     */
    readonly isTinted: boolean;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

  /**
   * A Zone Game Object.
   *
   * A Zone is a non-rendering rectangular Game Object that has a position and size.
   * It has no texture and never displays, but does live on the display list and
   * can be moved, scaled and rotated like any other Game Object.
   *
   * Its primary use is for creating Drop Zones and Input Hit Areas and it has a couple of helper methods
   * specifically for this. It is also useful for object overlap checks, or as a base for your own
   * non-displaying Game Objects.
   * The default origin is 0.5, the center of the Zone, the same as with Game Objects.
   */
  class Zone extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Visible {
    /**
     *
     * @param scene The Scene to which this Game Object belongs.
     * @param x The horizontal position of this Game Object in the world.
     * @param y The vertical position of this Game Object in the world.
     * @param width The width of the Game Object. Default 1.
     * @param height The height of the Game Object. Default 1.
     */
    constructor(scene: Phaser.Scene, x: number, y: number, width?: number, height?: number);

    /**
     * The native (un-scaled) width of this Game Object.
     */
    width: number;

    /**
     * The native (un-scaled) height of this Game Object.
     */
    height: number;

    /**
     * The Blend Mode of the Game Object.
     * Although a Zone never renders, it still has a blend mode to allow it to fit seamlessly into
     * display lists without causing a batch flush.
     */
    blendMode: number;

    /**
     * The displayed width of this Game Object.
     * This value takes into account the scale factor.
     */
    displayWidth: number;

    /**
     * The displayed height of this Game Object.
     * This value takes into account the scale factor.
     */
    displayHeight: number;

    /**
     * Sets the size of this Game Object.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     * @param resizeInput If this Zone has a Rectangle for a hit area this argument will resize the hit area as well. Default true.
     */
    setSize(width: number, height: number, resizeInput?: boolean): this;

    /**
     * Sets the display size of this Game Object.
     * Calling this will adjust the scale.
     * @param width The width of this Game Object.
     * @param height The height of this Game Object.
     */
    setDisplaySize(width: number, height: number): this;

    /**
     * Sets this Zone to be a Circular Drop Zone.
     * The circle is centered on this Zones `x` and `y` coordinates.
     * @param radius The radius of the Circle that will form the Drop Zone.
     */
    setCircleDropZone(radius: number): this;

    /**
     * Sets this Zone to be a Rectangle Drop Zone.
     * The rectangle is centered on this Zones `x` and `y` coordinates.
     * @param width The width of the rectangle drop zone.
     * @param height The height of the rectangle drop zone.
     */
    setRectangleDropZone(width: number, height: number): this;

    /**
     * Allows you to define your own Geometry shape to be used as a Drop Zone.
     * @param hitArea A Geometry shape instance, such as Phaser.Geom.Ellipse, or your own custom shape.
     * @param hitAreaCallback A function that will return `true` if the given x/y coords it is sent are within the shape.
     */
    setDropZone(hitArea: object, hitAreaCallback: Phaser.Types.Input.HitAreaCallback): this;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     */
    depth: number;

    /**
     * The depth of this Game Object within the Scene.
     *
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The default depth is zero. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * @param value The depth of this Game Object.
     */
    setDepth(value: number): this;

    /**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     */
    getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

    /**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getLeftCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getRightCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomCenter<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     * @param output An object to store the values in. If not provided a new Vector2 will be created.
     * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
     */
    getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

    /**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     * @param output An object to store the values in. If not provided a new Rectangle will be created.
     */
    getBounds<O extends Phaser.Geom.Rectangle>(output?: O): O;

    /**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     */
    originX: number;

    /**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     */
    originY: number;

    /**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginX: number;

    /**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     */
    displayOriginY: number;

    /**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     * @param x The horizontal origin value. Default 0.5.
     * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setOrigin(x?: number, y?: number): this;

    /**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     */
    setOriginFromFrame(): this;

    /**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     * @param x The horizontal display origin value. Default 0.
     * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
     */
    setDisplayOrigin(x?: number, y?: number): this;

    /**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     */
    updateDisplayOrigin(): this;

    /**
     * The x position of this Game Object.
     */
    x: number;

    /**
     * The y position of this Game Object.
     */
    y: number;

    /**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     */
    z: number;

    /**
     * The w position of this Game Object.
     */
    w: number;

    /**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     */
    scale: number;

    /**
     * The horizontal scale of this Game Object.
     */
    scaleX: number;

    /**
     * The vertical scale of this Game Object.
     */
    scaleY: number;

    /**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     */
    angle: number;

    /**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     */
    rotation: number;

    /**
     * Sets the position of this Game Object.
     * @param x The x position of this Game Object. Default 0.
     * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
     * @param z The z position of this Game Object. Default 0.
     * @param w The w position of this Game Object. Default 0.
     */
    setPosition(x?: number, y?: number, z?: number, w?: number): this;

    /**
     * Copies an object's coordinates to this Game Object's position.
     * @param source An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.
     */
    copyPosition(source: Phaser.Types.Math.Vector2Like | Phaser.Types.Math.Vector3Like | Phaser.Types.Math.Vector4Like): this;

    /**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     * @param x The x position of the top-left of the random area. Default 0.
     * @param y The y position of the top-left of the random area. Default 0.
     * @param width The width of the random area.
     * @param height The height of the random area.
     */
    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

    /**
     * Sets the rotation of this Game Object.
     * @param radians The rotation of this Game Object, in radians. Default 0.
     */
    setRotation(radians?: number): this;

    /**
     * Sets the angle of this Game Object.
     * @param degrees The rotation of this Game Object, in degrees. Default 0.
     */
    setAngle(degrees?: number): this;

    /**
     * Sets the scale of this Game Object.
     * @param x The horizontal scale of this Game Object.
     * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScale(x: number, y?: number): this;

    /**
     * Sets the x position of this Game Object.
     * @param value The x position of this Game Object. Default 0.
     */
    setX(value?: number): this;

    /**
     * Sets the y position of this Game Object.
     * @param value The y position of this Game Object. Default 0.
     */
    setY(value?: number): this;

    /**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     * @param value The z position of this Game Object. Default 0.
     */
    setZ(value?: number): this;

    /**
     * Sets the w position of this Game Object.
     * @param value The w position of this Game Object. Default 0.
     */
    setW(value?: number): this;

    /**
     * Gets the local transform matrix for this Game Object.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     */
    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     * @param tempMatrix The matrix to populate with the values from this Game Object.
     * @param parentMatrix A temporary matrix to hold parent values during the calculations.
     */
    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

    /**
     * Takes the given `x` and `y` coordinates and converts them into local space for this
     * Game Object, taking into account parent and local transforms, and the Display Origin.
     *
     * The returned Vector2 contains the translated point in its properties.
     *
     * A Camera needs to be provided in order to handle modified scroll factors. If no
     * camera is specified, it will use the `main` camera from the Scene to which this
     * Game Object belongs.
     * @param x The x position to translate.
     * @param y The y position to translate.
     * @param point A Vector2, or point-like object, to store the results in.
     * @param camera The Camera which is being tested against. If not given will use the Scene default camera.
     */
    getLocalPoint(x: number, y: number, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

    /**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     */
    getParentRotation(): number;

    /**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorX: number;

    /**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     */
    scrollFactorY: number;

    /**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     *
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     * @param x The horizontal scroll factor of this Game Object.
     * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
     */
    setScrollFactor(x: number, y?: number): this;

    /**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     */
    visible: boolean;

    /**
     * Sets the visibility of this Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     * @param value The visible state of the Game Object.
     */
    setVisible(value: boolean): this;

  }

}